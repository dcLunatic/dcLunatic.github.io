<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://dcLunatic.github.io/"/>
  <updated>2018-10-03T14:56:25.835Z</updated>
  <id>http://dcLunatic.github.io/</id>
  
  <author>
    <name>dcLunatic</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Kali安装Virtualbox</title>
    <link href="http://dcLunatic.github.io/2018/09/30/Kali%E5%AE%89%E8%A3%85Virtualbox/"/>
    <id>http://dcLunatic.github.io/2018/09/30/Kali安装Virtualbox/</id>
    <published>2018-09-30T01:54:42.000Z</published>
    <updated>2018-10-03T14:56:25.835Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关于Kali-Linux安装Virtualbox出现需要重新安装头文件的问题"><a href="#关于Kali-Linux安装Virtualbox出现需要重新安装头文件的问题" class="headerlink" title="关于Kali Linux安装Virtualbox出现需要重新安装头文件的问题"></a>关于Kali Linux安装Virtualbox出现需要重新安装头文件的问题</h1><blockquote><p> 一般的问题可以参考一下这篇<a href="https://www.cnblogs.com/lfoder/p/5777899.html" target="_blank" rel="noopener">文章</a>,基本可以解决大部分问题了。</p></blockquote><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>但是呢，笔者在解决virtualbox编译进内核的时候，遇到了问题。</p><p><img src="https://images2015.cnblogs.com/blog/800952/201608/800952-20160816205847296-827850444.png" alt="img"></p><p>一般的来说，这个问题只需要一句<code>apt-get install linux-headers-$(uname -r)</code>就可以解决了，但是由于kali 官网上已经不提供一些比较旧的头文件了，所以安装会出现无法定位什么的问题。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>所以这个时候我们需要重新编译内核，使用更高版本的内核。</p><p>笔者原先的是linux-4.12.0-kali1-amd64,但是无法找到对应的linux-headers-4.12.0-kali1-amd64，所以最后使用了4.15.0的。</p><blockquote><p>kail对应的资源文件可以在<a href="http://http.kali.org/kali/pool/main/l/linux/" target="_blank" rel="noopener">这里</a>下载</p></blockquote><p>下载对应的内核文件自己编译，具体方法如下:</p><ol><li><p>下载inux-kbuild<br>这里我下载的是<a href="http://http.kali.org/kali/pool/main/l/linux/linux-kbuild-4.15_4.15.11-1kali1_amd64.deb" target="_blank" rel="noopener">linux-kbuild-4.15_4.15.11-1kali1_amd64.deb</a> </p></li><li><p>编译linux-kbuild</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dkpg -i linux-kbuild-4.15_4.15.11-1kali1_amd64.deb</span><br></pre></td></tr></table></figure></li><li><p>下载linux-header-common和linux-header<br>这里我下载的是<a href="http://http.kali.org/kali/pool/main/l/linux/linux-headers-4.15.0-kali2-common_4.15.11-1kali1_all.deb" target="_blank" rel="noopener">linux-headers-4.15.0-kali2-common_4.15.11-1kali1_all.deb</a> 和<a href="http://http.kali.org/kali/pool/main/l/linux/linux-headers-4.15.0-kali2-amd64_4.15.11-1kali1_amd64.deb" target="_blank" rel="noopener">linux-headers-4.15.0-kali2-amd64_4.15.11-1kali1_amd64.deb</a> </p></li><li><p>编译linux-headers</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dkpg -i linux-headers-4.15.0-kali2-comon_4.15.11-1kali1_all.deb</span><br><span class="line">dkpg -i linux-headers-4.15.0-kali2-amd64_4.15.11-1kali1_amd64.deb</span><br></pre></td></tr></table></figure><p>如果这里出现依赖错误，自行下载对应deb然后编译安装解决，不解决也可能不会影响后续操作，但可能会影响以后使用。</p></li><li><p>下载linux-image<br>这里下载<a href="http://http.kali.org/kali/pool/main/l/linux/linux-image-4.15.0-kali2-amd64_4.15.11-1kali1_amd64.deb" target="_blank" rel="noopener">linux-image-4.15.0-kali2-amd64_4.15.11-1kali1_amd64.deb</a> </p></li><li><p>编译linux-image</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dkpg -i linux-image-4.15.0-kali2-amd64_4.15.11-1kali1_amd64.deb</span><br></pre></td></tr></table></figure></li></ol><p><strong>到这里基本上就完成了。记住下载的版本要一致。</strong></p><ol start="7"><li><p>重启进新内核</p><p>然后重启电脑，进入advance kali，可以看到两个内核版本，一个是4.12.0，一个是4.15.0，选择4.15.0的进入就可以了。</p></li></ol><p>使用uname -a就可以查看内核版本的信息了。</p><p>至此，再重新运行一下/sbin/vboxconfig就可以了，virtualbox就可以正常使用了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;关于Kali-Linux安装Virtualbox出现需要重新安装头文件的问题&quot;&gt;&lt;a href=&quot;#关于Kali-Linux安装Virtualbox出现需要重新安装头文件的问题&quot; class=&quot;headerlink&quot; title=&quot;关于Kali Linux安装Vi
      
    
    </summary>
    
    
      <category term="kali" scheme="http://dcLunatic.github.io/tags/kali/"/>
    
      <category term="virtualbox" scheme="http://dcLunatic.github.io/tags/virtualbox/"/>
    
  </entry>
  
  <entry>
    <title>Linux进程管理</title>
    <link href="http://dcLunatic.github.io/2018/09/30/Linux%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
    <id>http://dcLunatic.github.io/2018/09/30/Linux进程管理/</id>
    <published>2018-09-30T01:52:51.000Z</published>
    <updated>2018-10-03T14:56:38.796Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux进程"><a href="#Linux进程" class="headerlink" title="Linux进程"></a>Linux进程</h1><p>[TOC]</p><blockquote><p>进程是执行中一段程序，即一旦程序被载入到内存中并准备执行，它就是一个进程。进程是表示资源分配的的基本概念，又是调度运行的基本单位，是系统中的并发执行的单位。<br>线程：单个进程中执行中每个任务就是一个线程。线程是进程中执行运算的最小单位。<br>换句话说，进程线程都是对CPU工作时间段的描述（通过task_struct)。</p></blockquote><h2 id="而在Linux系统运行中，程序对应的进程是怎么被创建，被管理，被切换，被调度的呢？"><a href="#而在Linux系统运行中，程序对应的进程是怎么被创建，被管理，被切换，被调度的呢？" class="headerlink" title="而在Linux系统运行中，程序对应的进程是怎么被创建，被管理，被切换，被调度的呢？"></a>而在Linux系统运行中，程序对应的进程是怎么被创建，被管理，被切换，被调度的呢？</h2><h3 id="进程的组成，创建，状态机"><a href="#进程的组成，创建，状态机" class="headerlink" title="进程的组成，创建，状态机"></a>进程的组成，创建，状态机</h3><h4 id="进程的组成，创建"><a href="#进程的组成，创建" class="headerlink" title="进程的组成，创建"></a>进程的组成，创建</h4><blockquote><p>所有进程都会有一个共同的父进程，PID为1的init(systemd)进程，它是内核引导后启动的第一个进程，主要用来执行一些开机初始化脚本和监视进程，读取配置文件/etc/inittab，永远不会停止。必要的时候可以作为参照。如果某个进程突然成为游离进程(其父进程终止了)，此时，这个进程会将init进程作为参照，作为它们的父进程，然后gg。<code>父进程死了它的子进程也会死。</code>可以通过pstree查看系统内正在运行的各个进程的之间的继承关系。<br>inittab 是一个不可执行的文本文件，每行的基本格式为:<em>id:runlevels:action:process</em></p><ul><li>id: 1-2个字符，配置行的唯一标识，不能重复。</li><li>runlevels: 配置行适用的运行级别，可以填入多个运行级别，如12345或者35。<ul><li>0: 关机</li><li>1: 单用户字符界面</li><li>2: 不具备网络文件系统(NFS)功能的多用户文字界面</li><li>3: 具备网络功能的多用户字符界面</li><li>4: 保留</li><li>5: 具有网络功能的图形用户界面</li><li>6: 重新启动系统</li></ul></li><li>action: 表示init的行为，行为表略。</li><li>process: 为init执行的进程，这些进程都保存在/etc/rcX.d/中，其中X代表运行级别，rc程序接受参数X，然后执行/etc/rcX.d/下面的程序。<ul><li>这些程序其实都是符号链接，以S打头的表示启动该程序，而以K打头的标识终止该程序，后面的数字标识执行顺序，越小越先执行，剩下的标识程序名。</li><li>系统启动或者切换到该运行级别时会执行以S打头的程序，系统切换到其他运行级别是会终止以K打头的程序。</li><li>可以通过chkconfig程序进行管理<br>init程序也是一个进程，和普通进程拥有一样的属性，比如修改了/etc/inittab，想要立即生效，可以通过运行kill -SIGHUP 1来实现，也可以通过init q来实现。</li></ul></li></ul></blockquote><blockquote><p>kill命令的工作原理是：向Linux系统的内核发送一个系统操作信号和某个程序的进程标识号，然后系统内核就可以对进程标识号指定的进程进行操作。</p></blockquote><p><code>在Linux内核中，进程通过一个双向链表来进行管理，每一个进程包含一个进程描述符(task_struct)</code></p><ul><li><h5 id="进程描述符"><a href="#进程描述符" class="headerlink" title="进程描述符"></a>进程描述符</h5><ul><li>​当把一个程序加载到内存当中，此时，这个时候就有了进程，关于进程，有一个相关的叫做进程控制块（PCB），这个是系统为了方便进行管理进程所设置的一个数据结构，通过PCB，就可以记录进程的特征以及一些信息。 内核当中使用进程描述符task_struct。 这个task_struct就是一个定义的一个结构体，通过这个结构体，可以对进程的所有的相关的信息进行维护，对进程进行管理。</li><li>推荐一篇<a href="https://blog.csdn.net/qq_26768741/article/details/54348586" target="_blank" rel="noopener">文章</a></li></ul></li><li><h5 id="进程的组成"><a href="#进程的组成" class="headerlink" title="进程的组成"></a>进程的组成</h5><ul><li>程序读取的上下文，表示程序读取执行的状态</li><li>程序当前执行的目录</li><li>程序服务的文件与目录</li><li>程序访问的权限</li><li>内存和其他分配给进程的系统资源</li></ul></li></ul><ul><li><h5 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h5><ul><li><p>进程总是通过fork系列的系统调用来创建的，最终都是调用do_fork函数，只是参数上的不同而已</p><ul><li><p>fork(do_fork(CLONE_SIGCHLD, …))</p><ul><li>fork创建一个进程时，子进程只是完全复制父进程的资源，复制出来的子进程有自己的task_struct结构和pid,但却复制父进程其它资源（用户空间、文件描述符集）。</li><li>采用cow(copy on write)写时复制来降低系统调用的开销。</li><li>一次返回两个值，对于父进程，是子程序的pid，而对于子程序，成功状态下是0。</li><li>在fork之后，子进程会获得父进程的数据段，堆栈段的副本，而代码段则是共享的。</li></ul></li><li><p>clone(do_fork(CLONE_VM|CLONE_FS|CLONE_FILES|CLONE_SIGCHLD, …))</p><ul><li>fork()是全部复制，vfork()是共享内存，而clone()是则可以将父进程资源有选择地复制给子进程，前两者都是不带参数的，后者有参数clone_flags。</li></ul></li><li><p>vfork(do_fork(CLONE_VFORK|CLONE_VM|CLONE_SIGCHLD, …))</p><ul><li><p>vfork系统调用不同于fork，用vfork创建的子进程与父进程共享地址空间，也就是说子进程完全运行在父进程的地址空间上，如果这时子进程修改了某个变量，这将影响到父进程。</p></li><li><p>vfork也是在父进程中返回子进程的进程号，在子进程中返回0。</p></li><li><p>用 vfork创建子进程后，父进程会被阻塞直到子进程调用exec(exec，将一个新的可执行文件载入到地址空间并执行之)或exit。</p></li><li><p>vfork的好处是在子进程被创建后往往仅仅是为了调用exec执行另一个程序，因为它就不会对父进程的地址空间有任何引用，所以对地址空间的复制是多余的 ，因此通过vfork共享内存可以减少不必要的开销。</p></li></ul></li><li><p>三者的区别</p><ul><li>拷贝内容</li><li>访问次序控制<ul><li>fork不对父子进程的执行次序进行任何限制，运行顺序由内核的调度算法决定。</li><li>vfork调用后，子进程先运行，父进程挂起，直到子进程调用了exec或者exit后，父子进程的执行次序才不再有限制。</li><li>clone中有标志CLONE_VFORK来决定子进程在运行是父进程是阻塞的还是运行的，如果没有设置，则同时进行，设置了，与fork一样。</li></ul></li></ul></li></ul></li></ul></li><li><blockquote><p>CLONE_VM标识：表示共享地址空间（变量等）</p><p>CLONE_FILES标志：表示共享文件描述符表</p><p>CLONE_VFORK标识：标识父进程会被阻塞，子进程会把父进程的地址空间锁住，直到子进程退出或执行exec时才释放该锁</p><p>SIGCHLD标识：共享信号</p></blockquote></li><li><p>内核也可以通过kernel_thread函数来创建内核进程</p></li></ul><h4 id="Linux-进程状态机"><a href="#Linux-进程状态机" class="headerlink" title="Linux 进程状态机"></a>Linux 进程状态机</h4><p><img src="https://images0.cnblogs.com/i/401155/201404/201153238078305.jpg" alt="进程状态转换关系图"></p><ul><li>虽然进程的状态有好多种，但是进程状态的变迁只有两个方向，从TASK_RUNNING到非TASK_RUNNING，或者相反。总之，进程状态的转换必然会经过TASK_RUNNING，不可能在两个非RUN状态直接转换。</li><li>进程从非TASK_RUNNING状态变为TASK_RUNNING状态，是由别的进程（也可能是中断处理程序）执行唤醒操作来实现的。执行唤醒的进程设置被唤醒进程的状态为TASK_RUNNING，然后将其task_struct结构加入到某个CPU的可执行队列中。于是被唤醒的进程将有机会被调度执行。</li><li>进程从TASK_RUNNING状态变为非TASK_RUNNING状态，有两种途径。<ul><li>响应信号而进入TASK_STOPED状态，或者TASK_DEAD状态</li><li>执行程序主动进入TASK_INTERRUPTIBLE状态（如nanosleep调用)，或者是TASK_DEAD状态（如exit系统调用)，另一方面，也有可能是由于执行系统调用需要的资源得不到满足，而进入TASK_INTERRUPTIBLE状态或TASK_UNINTERRUPTIBLE状态（如select系统调用）。</li></ul></li><li>可以通过ps命令来查看系统中存在的进程，以及它们的状态。</li><li>系统中绝大部分进程都处于TASK_INTERRUPTIBLE状态，因为CPU也就那么几个，所以绝大部分进程都处于睡眠状态。</li><li>TASK_UNINTERRUPTIBLE，不可中断的睡眠状态，指该进程不接受异步信号，如kill -9无法杀死该类进程，这种状态的意义在于，<strong>内核中的某些处理流程是不能被打断的，如果响应了异步信号，程序的执行流程中就会给插入了一段处理异步信号的流程（可能只存在于内核态，也可能会延伸到用户态）于是乎，原有的流程就给中断了。</strong> <em>而且，一般系统进程中存在于这个状态的进程是非常少，而且正常来说，都是非常短暂的，基本无法察觉得到的。</em>其实通过vfork调用后，父进程就是处于一种TASK_UNINTERRUPTIBLE的状态，知道子进程调用exec或者exit。</li><li>TASK_STOPPED 或者 TASK_TRACED，暂停状态或跟踪状态。<ul><li>向某个进程发送SIGSTOP信号或者SIGCONT信号可以进入TASK_STOPPED或者恢复到TASK_RUNNING。</li><li>TASK_TRACED状态一般只发生在该进程被调试暂停的时候，该进程停下来，等待跟踪它的进程对其进行操作，TASK_TRACED状态下的进程不响应SIGCONT信号，只能是调试它的进程来恢复它，或者调试进程退出时也会恢复。</li></ul></li><li>TASK_DEAD - EXIT_ZOMBIE，退出状态，进程成为僵尸进程。<ul><li>进程在退出的过程中，处于TASK_DEAD状态，在退出过程中，进程所占有的资源将会被回收，除了task_struct结构(以及少数资源)，也就是说，进程表只存在这个进程对应的task_struct这个空壳，所以叫做僵尸，由父进程负责收集，收尸。从这个尸体(task_struct)中可以得到很多有用的信息，如子进程的退出码，一些统计信息（虽然内核也可以吧这些信息保存在其他的地方，但是不这么做）。父进程可以通过wait系列的系统调用来等待子进程的退出，然后获取退出信息，然后wait系列的系统调用会清理尸体(task_struct)。</li><li>子进程在退出的时候，内核会给父进程发送一个信号(SIGCHLD)来通知父进程过来收尸。</li><li>进程可以通过调用exit来进入该状态。</li></ul></li><li>TASK_DEAD - EXIT_DEAD，退出状态，进程即将给销毁。<ul><li>进程也有可能不会经历TASK_DEAD - EXIT_ZOMBIE状态而直接销毁。如detach过的进程，SIGCHLD信号的handle为SIG_IGN，忽略了SIGCHLD信号。</li></ul></li></ul><h3 id="进程的调度"><a href="#进程的调度" class="headerlink" title="进程的调度"></a>进程的调度</h3><blockquote><p>无论是在<a href="https://baike.baidu.com/item/%E6%89%B9%E5%A4%84%E7%90%86%E7%B3%BB%E7%BB%9F" target="_blank" rel="noopener">批处理系统</a>还是<a href="https://baike.baidu.com/item/%E5%88%86%E6%97%B6%E7%B3%BB%E7%BB%9F" target="_blank" rel="noopener">分时系统</a>中，用户进程数一般都多于<a href="https://baike.baidu.com/item/%E5%A4%84%E7%90%86%E6%9C%BA" target="_blank" rel="noopener">处理机</a>数、这将导致它们互相争夺处理机。另外，系统进程也同样需要使用<a href="https://baike.baidu.com/item/%E5%A4%84%E7%90%86%E6%9C%BA" target="_blank" rel="noopener">处理机</a>。这就要求进程调度程序按一定的策略，动态地把<a href="https://baike.baidu.com/item/%E5%A4%84%E7%90%86%E6%9C%BA" target="_blank" rel="noopener">处理机</a>分配给处于就绪队列中的某一个<a href="https://baike.baidu.com/item/%E8%BF%9B%E7%A8%8B" target="_blank" rel="noopener">进程</a>，以使之执行。这就是进程调度。</p></blockquote><p>当cpu中正在执行的进程(process A)被移出(suspend),cpu中当前进程的相关信息写到需要移除的进程的进程描述符(task_strut)中,下一个进程(process B)被内核读取(该过程称为resume，恢复)到cpu中, 注意：进程的切换也是必须由内核来执行的。进程的切换就是通过<strong>用户空间和内核模式的不断切换</strong>来完成的。<strong>进程切换=CPU加载上下文+CPU执行+CPU保存上下文</strong></p><h4 id="Linux-进程调度的目标"><a href="#Linux-进程调度的目标" class="headerlink" title="Linux 进程调度的目标"></a>Linux 进程调度的目标</h4><ul><li>高效性: 高效性意味着在相同时间下要完成更多的任务。调度程序会被频繁的执行，所以调度程序要尽可能的高效。</li><li>加强交互性能: 在系统相当的负载下，也要保证系统的响应时间。</li><li>保证公平和避免饥渴</li><li>SMP调度: 调度程序必须支持多处理系统。</li><li>软实时调度: 系统必须有效的调用实时进程，但不保证一定满足其要求。</li></ul><h4 id="Linux-进程优先级"><a href="#Linux-进程优先级" class="headerlink" title="Linux 进程优先级"></a>Linux 进程优先级</h4><ol><li><h5 id="普通进程的优先级"><a href="#普通进程的优先级" class="headerlink" title="普通进程的优先级"></a>普通进程的优先级</h5><ul><li>使用SCHED_NORMAL调度策略</li></ul></li><li><h5 id="实时进程的优先级"><a href="#实时进程的优先级" class="headerlink" title="实时进程的优先级"></a>实时进程的优先级</h5><ul><li>使用SCHED_FIFO(一次机会做完) 或者 SCHED_RR(多次轮转) 调度策略</li></ul></li></ol><blockquote><p>任何时候，实时进程的优先级都高于普通进程，实时进程只会被更高级的实时进程抢占</p></blockquote><h4 id="Linux-进程调度"><a href="#Linux-进程调度" class="headerlink" title="Linux 进程调度"></a>Linux 进程调度</h4><ul><li><h5 id="实时进程调度"><a href="#实时进程调度" class="headerlink" title="实时进程调度"></a>实时进程调度</h5><ul><li><p>实时进程，只有静态优先级，因为内核不会根据休眠等因素对其静态优先级做调整，范围是在0 - MAX_RT_PRIO - 1 之间。而nice值，影响的优先级在MAX_RT_PRIO - MAX_RT_PRIO + 40之间的进程。</p></li><li><p>MAX_RT_PRIO: 默认配置为100.</p></li><li><p>不同于普通进程，实时进程高的进程总是先于优先级低的进程执行，直到实时优先级高的实时进程无法执行，实时进程总是被认为处于活动状态。</p></li><li><p>如果有数个进程相同的实时进程，那么系统会按照进程在队列上的顺序选择进程。</p></li><li><p>例如CPU运行实时进程A的实时优先级为a，而此时有一个实时优先级为b的实时进程B进入可运行状态，那么只要b &gt; a，系统将会中断A的执行，而优先执行B，直到B无法执行。</p></li><li><h6 id="调度策略"><a href="#调度策略" class="headerlink" title="调度策略"></a>调度策略</h6><ul><li>FIFO 的进程，意味着只有当前进程执行完毕才会轮到其他进程执行。</li><li>RR 的进程，内核会为进程分配时间片，一旦时间片消耗完毕，内核会将该进程置于进程队列的末尾，然后运行其他相同优先级别的进程，如果没有其他相同优先级的进程，则该进程会继续执行。</li></ul></li></ul></li></ul><blockquote><p>对于实时进程，高优先级别的进程执行到无法执行了，才会轮到低优先级别的进程执行。</p></blockquote><ul><li><h5 id="非实时进程调度"><a href="#非实时进程调度" class="headerlink" title="非实时进程调度"></a>非实时进程调度</h5><ul><li><p>Linux 对于普通进程，根据动态优先级进行调整，而动态优先级是由静态优先级(static_prio)调整而来的。 静态优先级是用户不可见的，隐藏在内核中，而内核会给用户一个可以影响静态优先级的接口，那就是nice值。</p></li><li><blockquote><p>static_prio = MAX_RT_PRIO + nice + 20</p></blockquote></li><li><p>nice 值与静态优先级的关系如上所示。nice值的范围是-20 - 19之间，所以静态优先级范围在100 - 139之间。</p></li><li><p>普通进程的动态优先级越低，优先越高，与实时进程相反，也就是说，nice的值越大，优先级越低。</p></li></ul></li></ul><blockquote><p> 进程时间片是完全依赖于static_prio 定制的，如下所示</p><p> $$<br> base\ time\ quantum(ms) =<br> \begin{cases}<br> (140 - \text{static_prio})\times20, \text{static_prio &lt; 120}\<br> (140 - \text{static_prio})\times20, \text{static_prio } \ge \text{ 120}<br> \end{cases}<br> $$</p></blockquote><h4 id="进程调度的其他因素"><a href="#进程调度的其他因素" class="headerlink" title="进程调度的其他因素"></a>进程调度的其他因素</h4><blockquote><p>系统在调度进程的时候，还会考虑其他因素，进而来计算出一个叫进程动态优先级的东西，基于这个来实施调度。</p></blockquote><ul><li><h5 id="进程属性"><a href="#进程属性" class="headerlink" title="进程属性"></a>进程属性</h5><ul><li>交互式进程(I/O密集型，等待IO，对cpu的需求量小)</li><li>批处理进程(CPU密集型)</li><li>实时进程</li></ul></li><li><h5 id="分配策略"><a href="#分配策略" class="headerlink" title="分配策略"></a>分配策略</h5><ul><li><p>不仅要考虑静态优先级，也要考虑进程的属性，如果进程是属于交互式进程，那么可以适当的调高它的优先级，使得界面反应更加迅速，从而提高用户体验。</p></li><li><p>交互式进程可以从一个平均睡眠时间来进行判断，如果进程过去睡眠的时间越多，则越有可能属于交互式进程。则系统在调度的时候，会给该进程更多的奖励(bonus)，以便该进程有更多的时间能够执行。奖励(bonus)的范围为0 - 10。</p></li><li><p>睡眠和CPU耗时反应了进程IO密集和CPU密集两大瞬时特点，不同时期，一个进程可能即是CPU密集型也是IO密集型进程。对于表现为IO密集的进程，应该经常运行，但每次时间片不要太长。对于表现为CPU密集的进程，CPU不应该让其经常运行，但每次运行时间片要长。交互进程为例，假如之前其其大部分时间在于等待CPU，这时为了调高相应速度，就需要增加奖励分。另一方面，如果此进程总是耗尽每次分配给它的时间片，为了对其他进程公平，就要增加这个进程的惩罚分数。</p></li><li><p>系统会严格按照动态优先级高低的顺序安排进程执行。动态优先级高的进程进入运行状态，或者时间片消耗完毕后才会轮到动态优先级低的进程执行。</p></li><li><p>动态优先级的计算主要考虑两个因素</p><ul><li>静态优先级(static_prio)</li><li>平均睡眠时间(bonus)</li></ul></li><li><blockquote><p>计算公式如下<br>$$<br>\text{dynamic_prio} = max{100,\ min{static_prio- bonus+5,\ 139} }<br>$$</p></blockquote></li><li><p>Linux2.6在计算的时候有空间换时间的策略，从而保证最优进程能够在O(1)的时间内完成。</p></li><li><p>CFS 的virtutime机制。</p></li></ul></li></ul><h4 id="进程切换-Context-switch"><a href="#进程切换-Context-switch" class="headerlink" title="进程切换 (Context switch)"></a>进程切换 (Context switch)</h4><p>当cpu中正在执行的进程(process A)被移出(suspend),cpu中当前进程的相关信息写到需要移除的进程的进程描述符(task_strut)中,下一个进程(process B)被内核读取(该过程称为resume，恢复)到cpu中, 注意：进程的切换也是必须由内核来执行的。进程的切换就是通过<strong>用户空间和内核模式的不断切换</strong>来完成的。<strong>进程切换=CPU加载上下文+CPU执行+CPU保存上下文</strong></p><h4 id="调度触发的时机"><a href="#调度触发的时机" class="headerlink" title="调度触发的时机"></a>调度触发的时机</h4><ol><li><p>当前进程进入非可执行状态</p></li><li><p>抢占</p><ul><li>进程用完了时间片</li><li>出现优先级更高的进程，会被影响而唤醒。</li></ul><blockquote><p>内核在响应时钟中断的过程中，发现当前进程的时间片已经用完</p><p>内核在响应时钟中断的过程中，发现优先级更高的进程所等待的外部资源是可用的，于是唤醒它。</p><p>​</p></blockquote></li></ol><h3 id="其他相关"><a href="#其他相关" class="headerlink" title="其他相关"></a>其他相关</h3><h4 id="内核抢占"><a href="#内核抢占" class="headerlink" title="内核抢占"></a>内核抢占</h4><ul><li>理想情况下，只要满足了出现优先级更高的进程这个条件，当前进程就应该被立刻抢占。但是就像多线程程序需要使用锁来保护临界区资源一样，内核中也有很多这样的临界区，来保证一些程序不给抢占。或者是处于效率考虑。</li><li>Linux2.4不支持内核抢占，进程在内核态是不允许抢占的，只有返回用户态时会触发调整。</li><li>Linux2.6支持内核抢占，但是很多地方为了保护临界区资源而临时性的禁用抢占。</li></ul><h4 id="SMP调度下的负载均衡问题"><a href="#SMP调度下的负载均衡问题" class="headerlink" title="SMP调度下的负载均衡问题"></a>SMP调度下的负载均衡问题</h4><p><code>多处理器下，每个CPU都有对应的可执行队列，但是一个可执行状态的进程同一时刻只能存在于一个可执行队列中。</code></p><p>问题</p><ul><li>每个CPU可执行队列中进程数目不均衡的时候，要怎么调整，什么时候算作是不均衡，需要调整？</li><li>CPU之间的关系，两个CPU之间，是不是相互独立的，cache可以共享吗？或者，是不是由同一个物理CPU通过超线程技术虚拟出来的</li><li>反正就是乱七八糟的就是了。。。。。</li></ul><h4 id="优先级继承"><a href="#优先级继承" class="headerlink" title="优先级继承"></a>优先级继承</h4><p><code>假如有一个进程A，因为要进入临界区，但是临界区有了B，而在等待睡眠，直到B退出临界区后，进程A才会被唤醒。</code></p><p>可能存在这么一种情况，A的优先级很高，而B的优先级很低，B进入了临界区，但是却给其他优先级高于B低于A的进程C抢占，A就等不到运行，此时叫做<strong>优先级反转</strong>。此时会通过以下方法解决:在A开始等待的时候，将A的优先级赋给B，直到B退出临界区后恢复其原本的优先级。</p><p>这就是优先级继承。</p><h4 id="中断处理程序的优化"><a href="#中断处理程序的优化" class="headerlink" title="中断处理程序的优化"></a>中断处理程序的优化</h4><p><code>正常来说，中断处理程序处于一个不可调度的上下文中，CPU响应硬件中断自动跳转到内核设定的中断处理程序去执行，再到处理程序执行完。这整个过程中是不能被抢占的。</code></p><p>一个进程如果被抢占了，可以通过保存在它的进程控制块（task_struct）中的信息，在之后的某个时间恢复它的运行，而中断上下文是没有task_struct的，所以是不可能杯抢占的。</p><p>也就是说，中断程序的伪优先级比任何进程要高，但是呢在实际中，某些实时进程会拥有比中断进程更高的优先级。所以在一些系统中，会给中断处理程序赋予task_struct以及优先级。但是会影响一些性能，但是却能保证实时。</p><h4 id="调度程序的效率问题"><a href="#调度程序的效率问题" class="headerlink" title="调度程序的效率问题"></a>调度程序的效率问题</h4><p><code>优先级明确了哪个进程应该被调度执行，而调度程序还要关心效率问题，因为会被频繁的执行，所以效率很重要的。</code></p><p>所以，调度程序，如何来获得应该被执行的程序，就是一个问题了。</p><p>在Linux2.4，可执行状态的进程会被放在一个链表中，每次调度，扫描整个链表，以找出最优的那个进程来运行，复杂度为O(N)</p><p>在Linux2.6早期，可执行状态的进车功能会被挂载N（N=140）个链表中，每一个链表代表一个优先级，系统支持多少个优先级就有多少个链表。每次调度，调度程序只需要从第一个不为空的链表中取出链表头的进程即可。复杂度为O(1).</p><p>而在现在Linux2.6的版本中，可执行状态的进程会按照优先级顺序被挂载一个红黑树上，每次调度，找出树中优先级最高的那个进程。复杂度为O(LogN)</p><p><strong>只是为了公平</strong></p><p>第一种是基于空间换时间的策略，在一组数目不大的链表中来实现的，这样子优先级的取值范围很小（大了会浪费太多空间），区分度不大不能满足公平性的需求，而使用红黑树对优先级的取值没有限制，区分度可以更高。而且在同等情况下，140个优先级，O(LogN)的复杂度也不会太差。</p><h4 id="处理机的三级调度"><a href="#处理机的三级调度" class="headerlink" title="处理机的三级调度"></a>处理机的三级调度</h4><p><img src="http://c.biancheng.net/cpp/uploads/allimg/140629/1-140629144600329.jpg" alt="三级调度"></p><ul><li>作业调度(高级调度)</li><li>内存调度(中级调度)</li><li>进程调度(低级调度)</li></ul><p>作业调度从外存的后备队列中选择一批作业进入内存，为它们建立进程，这些进程被送入就绪队列，进程调度从就绪队列中选出一个进程，并把其状态改为运行状态，把CPU分配给它。中级调度是为了提高内存的利用率，系统将那些暂时不能运行的进程挂起来。当内存空间宽松时，通过中级调度选择具备运行条件的进程，将其唤醒。</p><ul><li>作业调度为进程活动做准备，进程调度使进程正常活动起来，中级调度将暂时不能运行的进程挂起，中级调度处于作业调度和进程调度之间。</li><li>作业调度次数少，中级调度次数略多，进程调度频率最高。</li><li>进程调度是最基本的，不可或缺。</li></ul><p>推荐一篇<a href="https://blog.csdn.net/chengonghao/article/details/50981214" target="_blank" rel="noopener">文章</a># Linux进程</p><p>[TOC]</p><blockquote><p>进程是执行中一段程序，即一旦程序被载入到内存中并准备执行，它就是一个进程。进程是表示资源分配的的基本概念，又是调度运行的基本单位，是系统中的并发执行的单位。<br>线程：单个进程中执行中每个任务就是一个线程。线程是进程中执行运算的最小单位。<br>换句话说，进程线程都是对CPU工作时间段的描述（通过task_struct)。</p></blockquote><h2 id="而在Linux系统运行中，程序对应的进程是怎么被创建，被管理，被切换，被调度的呢？-1"><a href="#而在Linux系统运行中，程序对应的进程是怎么被创建，被管理，被切换，被调度的呢？-1" class="headerlink" title="而在Linux系统运行中，程序对应的进程是怎么被创建，被管理，被切换，被调度的呢？"></a>而在Linux系统运行中，程序对应的进程是怎么被创建，被管理，被切换，被调度的呢？</h2><h3 id="进程的组成，创建，状态机-1"><a href="#进程的组成，创建，状态机-1" class="headerlink" title="进程的组成，创建，状态机"></a>进程的组成，创建，状态机</h3><h4 id="进程的组成，创建-1"><a href="#进程的组成，创建-1" class="headerlink" title="进程的组成，创建"></a>进程的组成，创建</h4><blockquote><p>所有进程都会有一个共同的父进程，PID为1的init(systemd)进程，它是内核引导后启动的第一个进程，主要用来执行一些开机初始化脚本和监视进程，读取配置文件/etc/inittab，永远不会停止。必要的时候可以作为参照。如果某个进程突然成为游离进程(其父进程终止了)，此时，这个进程会将init进程作为参照，作为它们的父进程，然后gg。<code>父进程死了它的子进程也会死。</code>可以通过pstree查看系统内正在运行的各个进程的之间的继承关系。<br>inittab 是一个不可执行的文本文件，每行的基本格式为:<em>id:runlevels:action:process</em></p><ul><li>id: 1-2个字符，配置行的唯一标识，不能重复。</li><li>runlevels: 配置行适用的运行级别，可以填入多个运行级别，如12345或者35。<ul><li>0: 关机</li><li>1: 单用户字符界面</li><li>2: 不具备网络文件系统(NFS)功能的多用户文字界面</li><li>3: 具备网络功能的多用户字符界面</li><li>4: 保留</li><li>5: 具有网络功能的图形用户界面</li><li>6: 重新启动系统</li></ul></li><li>action: 表示init的行为，行为表略。</li><li>process: 为init执行的进程，这些进程都保存在/etc/rcX.d/中，其中X代表运行级别，rc程序接受参数X，然后执行/etc/rcX.d/下面的程序。<ul><li>这些程序其实都是符号链接，以S打头的表示启动该程序，而以K打头的标识终止该程序，后面的数字标识执行顺序，越小越先执行，剩下的标识程序名。</li><li>系统启动或者切换到该运行级别时会执行以S打头的程序，系统切换到其他运行级别是会终止以K打头的程序。</li><li>可以通过chkconfig程序进行管理<br>init程序也是一个进程，和普通进程拥有一样的属性，比如修改了/etc/inittab，想要立即生效，可以通过运行kill -SIGHUP 1来实现，也可以通过init q来实现。</li></ul></li></ul></blockquote><blockquote><p>kill命令的工作原理是：向Linux系统的内核发送一个系统操作信号和某个程序的进程标识号，然后系统内核就可以对进程标识号指定的进程进行操作。</p></blockquote><p><code>在Linux内核中，进程通过一个双向链表来进行管理，每一个进程包含一个进程描述符(task_struct)</code></p><ul><li><h5 id="进程描述符-1"><a href="#进程描述符-1" class="headerlink" title="进程描述符"></a>进程描述符</h5><ul><li>​当把一个程序加载到内存当中，此时，这个时候就有了进程，关于进程，有一个相关的叫做进程控制块（PCB），这个是系统为了方便进行管理进程所设置的一个数据结构，通过PCB，就可以记录进程的特征以及一些信息。 内核当中使用进程描述符task_struct。 这个task_struct就是一个定义的一个结构体，通过这个结构体，可以对进程的所有的相关的信息进行维护，对进程进行管理。</li><li>推荐一篇<a href="https://blog.csdn.net/qq_26768741/article/details/54348586" target="_blank" rel="noopener">文章</a></li></ul></li><li><h5 id="进程的组成-1"><a href="#进程的组成-1" class="headerlink" title="进程的组成"></a>进程的组成</h5><ul><li>程序读取的上下文，表示程序读取执行的状态</li><li>程序当前执行的目录</li><li>程序服务的文件与目录</li><li>程序访问的权限</li><li>内存和其他分配给进程的系统资源</li></ul></li></ul><ul><li><h5 id="进程的创建-1"><a href="#进程的创建-1" class="headerlink" title="进程的创建"></a>进程的创建</h5><ul><li><p>进程总是通过fork系列的系统调用来创建的，最终都是调用do_fork函数，只是参数上的不同而已</p><ul><li><p>fork(do_fork(CLONE_SIGCHLD, …))</p><ul><li>fork创建一个进程时，子进程只是完全复制父进程的资源，复制出来的子进程有自己的task_struct结构和pid,但却复制父进程其它资源（用户空间、文件描述符集）。</li><li>采用cow(copy on write)写时复制来降低系统调用的开销。</li><li>一次返回两个值，对于父进程，是子程序的pid，而对于子程序，成功状态下是0。</li><li>在fork之后，子进程会获得父进程的数据段，堆栈段的副本，而代码段则是共享的。</li></ul></li><li><p>clone(do_fork(CLONE_VM|CLONE_FS|CLONE_FILES|CLONE_SIGCHLD, …))</p><ul><li>fork()是全部复制，vfork()是共享内存，而clone()是则可以将父进程资源有选择地复制给子进程，前两者都是不带参数的，后者有参数clone_flags。</li></ul></li><li><p>vfork(do_fork(CLONE_VFORK|CLONE_VM|CLONE_SIGCHLD, …))</p><ul><li><p>vfork系统调用不同于fork，用vfork创建的子进程与父进程共享地址空间，也就是说子进程完全运行在父进程的地址空间上，如果这时子进程修改了某个变量，这将影响到父进程。</p></li><li><p>vfork也是在父进程中返回子进程的进程号，在子进程中返回0。</p></li><li><p>用 vfork创建子进程后，父进程会被阻塞直到子进程调用exec(exec，将一个新的可执行文件载入到地址空间并执行之)或exit。</p></li><li><p>vfork的好处是在子进程被创建后往往仅仅是为了调用exec执行另一个程序，因为它就不会对父进程的地址空间有任何引用，所以对地址空间的复制是多余的 ，因此通过vfork共享内存可以减少不必要的开销。</p></li></ul></li><li><p>三者的区别</p><ul><li>拷贝内容</li><li>访问次序控制<ul><li>fork不对父子进程的执行次序进行任何限制，运行顺序由内核的调度算法决定。</li><li>vfork调用后，子进程先运行，父进程挂起，直到子进程调用了exec或者exit后，父子进程的执行次序才不再有限制。</li><li>clone中有标志CLONE_VFORK来决定子进程在运行是父进程是阻塞的还是运行的，如果没有设置，则同时进行，设置了，与fork一样。</li></ul></li></ul></li></ul></li></ul></li><li><blockquote><p>CLONE_VM标识：表示共享地址空间（变量等）</p><p>CLONE_FILES标志：表示共享文件描述符表</p><p>CLONE_VFORK标识：标识父进程会被阻塞，子进程会把父进程的地址空间锁住，直到子进程退出或执行exec时才释放该锁</p><p>SIGCHLD标识：共享信号</p></blockquote></li><li><p>内核也可以通过kernel_thread函数来创建内核进程</p></li></ul><h4 id="Linux-进程状态机-1"><a href="#Linux-进程状态机-1" class="headerlink" title="Linux 进程状态机"></a>Linux 进程状态机</h4><p><img src="https://images0.cnblogs.com/i/401155/201404/201153238078305.jpg" alt="进程状态转换关系图"></p><ul><li>虽然进程的状态有好多种，但是进程状态的变迁只有两个方向，从TASK_RUNNING到非TASK_RUNNING，或者相反。总之，进程状态的转换必然会经过TASK_RUNNING，不可能在两个非RUN状态直接转换。</li><li>进程从非TASK_RUNNING状态变为TASK_RUNNING状态，是由别的进程（也可能是中断处理程序）执行唤醒操作来实现的。执行唤醒的进程设置被唤醒进程的状态为TASK_RUNNING，然后将其task_struct结构加入到某个CPU的可执行队列中。于是被唤醒的进程将有机会被调度执行。</li><li>进程从TASK_RUNNING状态变为非TASK_RUNNING状态，有两种途径。<ul><li>响应信号而进入TASK_STOPED状态，或者TASK_DEAD状态</li><li>执行程序主动进入TASK_INTERRUPTIBLE状态（如nanosleep调用)，或者是TASK_DEAD状态（如exit系统调用)，另一方面，也有可能是由于执行系统调用需要的资源得不到满足，而进入TASK_INTERRUPTIBLE状态或TASK_UNINTERRUPTIBLE状态（如select系统调用）。</li></ul></li><li>可以通过ps命令来查看系统中存在的进程，以及它们的状态。</li><li>系统中绝大部分进程都处于TASK_INTERRUPTIBLE状态，因为CPU也就那么几个，所以绝大部分进程都处于睡眠状态。</li><li>TASK_UNINTERRUPTIBLE，不可中断的睡眠状态，指该进程不接受异步信号，如kill -9无法杀死该类进程，这种状态的意义在于，<strong>内核中的某些处理流程是不能被打断的，如果响应了异步信号，程序的执行流程中就会给插入了一段处理异步信号的流程（可能只存在于内核态，也可能会延伸到用户态）于是乎，原有的流程就给中断了。</strong> <em>而且，一般系统进程中存在于这个状态的进程是非常少，而且正常来说，都是非常短暂的，基本无法察觉得到的。</em>其实通过vfork调用后，父进程就是处于一种TASK_UNINTERRUPTIBLE的状态，知道子进程调用exec或者exit。</li><li>TASK_STOPPED 或者 TASK_TRACED，暂停状态或跟踪状态。<ul><li>向某个进程发送SIGSTOP信号或者SIGCONT信号可以进入TASK_STOPPED或者恢复到TASK_RUNNING。</li><li>TASK_TRACED状态一般只发生在该进程被调试暂停的时候，该进程停下来，等待跟踪它的进程对其进行操作，TASK_TRACED状态下的进程不响应SIGCONT信号，只能是调试它的进程来恢复它，或者调试进程退出时也会恢复。</li></ul></li><li>TASK_DEAD - EXIT_ZOMBIE，退出状态，进程成为僵尸进程。<ul><li>进程在退出的过程中，处于TASK_DEAD状态，在退出过程中，进程所占有的资源将会被回收，除了task_struct结构(以及少数资源)，也就是说，进程表只存在这个进程对应的task_struct这个空壳，所以叫做僵尸，由父进程负责收集，收尸。从这个尸体(task_struct)中可以得到很多有用的信息，如子进程的退出码，一些统计信息（虽然内核也可以吧这些信息保存在其他的地方，但是不这么做）。父进程可以通过wait系列的系统调用来等待子进程的退出，然后获取退出信息，然后wait系列的系统调用会清理尸体(task_struct)。</li><li>子进程在退出的时候，内核会给父进程发送一个信号(SIGCHLD)来通知父进程过来收尸。</li><li>进程可以通过调用exit来进入该状态。</li></ul></li><li>TASK_DEAD - EXIT_DEAD，退出状态，进程即将给销毁。<ul><li>进程也有可能不会经历TASK_DEAD - EXIT_ZOMBIE状态而直接销毁。如detach过的进程，SIGCHLD信号的handle为SIG_IGN，忽略了SIGCHLD信号。</li></ul></li></ul><h3 id="进程的调度-1"><a href="#进程的调度-1" class="headerlink" title="进程的调度"></a>进程的调度</h3><blockquote><p>无论是在<a href="https://baike.baidu.com/item/%E6%89%B9%E5%A4%84%E7%90%86%E7%B3%BB%E7%BB%9F" target="_blank" rel="noopener">批处理系统</a>还是<a href="https://baike.baidu.com/item/%E5%88%86%E6%97%B6%E7%B3%BB%E7%BB%9F" target="_blank" rel="noopener">分时系统</a>中，用户进程数一般都多于<a href="https://baike.baidu.com/item/%E5%A4%84%E7%90%86%E6%9C%BA" target="_blank" rel="noopener">处理机</a>数、这将导致它们互相争夺处理机。另外，系统进程也同样需要使用<a href="https://baike.baidu.com/item/%E5%A4%84%E7%90%86%E6%9C%BA" target="_blank" rel="noopener">处理机</a>。这就要求进程调度程序按一定的策略，动态地把<a href="https://baike.baidu.com/item/%E5%A4%84%E7%90%86%E6%9C%BA" target="_blank" rel="noopener">处理机</a>分配给处于就绪队列中的某一个<a href="https://baike.baidu.com/item/%E8%BF%9B%E7%A8%8B" target="_blank" rel="noopener">进程</a>，以使之执行。这就是进程调度。</p></blockquote><p>当cpu中正在执行的进程(process A)被移出(suspend),cpu中当前进程的相关信息写到需要移除的进程的进程描述符(task_strut)中,下一个进程(process B)被内核读取(该过程称为resume，恢复)到cpu中, 注意：进程的切换也是必须由内核来执行的。进程的切换就是通过<strong>用户空间和内核模式的不断切换</strong>来完成的。<strong>进程切换=CPU加载上下文+CPU执行+CPU保存上下文</strong></p><h4 id="Linux-进程调度的目标-1"><a href="#Linux-进程调度的目标-1" class="headerlink" title="Linux 进程调度的目标"></a>Linux 进程调度的目标</h4><ul><li>高效性: 高效性意味着在相同时间下要完成更多的任务。调度程序会被频繁的执行，所以调度程序要尽可能的高效。</li><li>加强交互性能: 在系统相当的负载下，也要保证系统的响应时间。</li><li>保证公平和避免饥渴</li><li>SMP调度: 调度程序必须支持多处理系统。</li><li>软实时调度: 系统必须有效的调用实时进程，但不保证一定满足其要求。</li></ul><h4 id="Linux-进程优先级-1"><a href="#Linux-进程优先级-1" class="headerlink" title="Linux 进程优先级"></a>Linux 进程优先级</h4><ol><li><h5 id="普通进程的优先级-1"><a href="#普通进程的优先级-1" class="headerlink" title="普通进程的优先级"></a>普通进程的优先级</h5><ul><li>使用SCHED_NORMAL调度策略</li></ul></li><li><h5 id="实时进程的优先级-1"><a href="#实时进程的优先级-1" class="headerlink" title="实时进程的优先级"></a>实时进程的优先级</h5><ul><li>使用SCHED_FIFO(一次机会做完) 或者 SCHED_RR(多次轮转) 调度策略</li></ul></li></ol><blockquote><p>任何时候，实时进程的优先级都高于普通进程，实时进程只会被更高级的实时进程抢占</p></blockquote><h4 id="Linux-进程调度-1"><a href="#Linux-进程调度-1" class="headerlink" title="Linux 进程调度"></a>Linux 进程调度</h4><ul><li><h5 id="实时进程调度-1"><a href="#实时进程调度-1" class="headerlink" title="实时进程调度"></a>实时进程调度</h5><ul><li><p>实时进程，只有静态优先级，因为内核不会根据休眠等因素对其静态优先级做调整，范围是在0 - MAX_RT_PRIO - 1 之间。而nice值，影响的优先级在MAX_RT_PRIO - MAX_RT_PRIO + 40之间的进程。</p></li><li><p>MAX_RT_PRIO: 默认配置为100.</p></li><li><p>不同于普通进程，实时进程高的进程总是先于优先级低的进程执行，直到实时优先级高的实时进程无法执行，实时进程总是被认为处于活动状态。</p></li><li><p>如果有数个进程相同的实时进程，那么系统会按照进程在队列上的顺序选择进程。</p></li><li><p>例如CPU运行实时进程A的实时优先级为a，而此时有一个实时优先级为b的实时进程B进入可运行状态，那么只要b &gt; a，系统将会中断A的执行，而优先执行B，直到B无法执行。</p></li><li><h6 id="调度策略-1"><a href="#调度策略-1" class="headerlink" title="调度策略"></a>调度策略</h6><ul><li>FIFO 的进程，意味着只有当前进程执行完毕才会轮到其他进程执行。</li><li>RR 的进程，内核会为进程分配时间片，一旦时间片消耗完毕，内核会将该进程置于进程队列的末尾，然后运行其他相同优先级别的进程，如果没有其他相同优先级的进程，则该进程会继续执行。</li></ul></li></ul></li></ul><blockquote><p>对于实时进程，高优先级别的进程执行到无法执行了，才会轮到低优先级别的进程执行。</p></blockquote><ul><li><h5 id="非实时进程调度-1"><a href="#非实时进程调度-1" class="headerlink" title="非实时进程调度"></a>非实时进程调度</h5><ul><li><p>Linux 对于普通进程，根据动态优先级进行调整，而动态优先级是由静态优先级(static_prio)调整而来的。 静态优先级是用户不可见的，隐藏在内核中，而内核会给用户一个可以影响静态优先级的接口，那就是nice值。</p></li><li><blockquote><p>static_prio = MAX_RT_PRIO + nice + 20</p></blockquote></li><li><p>nice 值与静态优先级的关系如上所示。nice值的范围是-20 - 19之间，所以静态优先级范围在100 - 139之间。</p></li><li><p>普通进程的动态优先级越低，优先越高，与实时进程相反，也就是说，nice的值越大，优先级越低。</p></li></ul></li></ul><blockquote><p> 进程时间片是完全依赖于static_prio 定制的，如下所示</p><p> $$<br> base\ time\ quantum(ms) =<br> \begin{cases}<br> (140 - \text{static_prio})\times20, \text{static_prio &lt; 120}\<br> (140 - \text{static_prio})\times20, \text{static_prio } \ge \text{ 120}<br> \end{cases}<br> $$</p></blockquote><h4 id="进程调度的其他因素-1"><a href="#进程调度的其他因素-1" class="headerlink" title="进程调度的其他因素"></a>进程调度的其他因素</h4><blockquote><p>系统在调度进程的时候，还会考虑其他因素，进而来计算出一个叫进程动态优先级的东西，基于这个来实施调度。</p></blockquote><ul><li><h5 id="进程属性-1"><a href="#进程属性-1" class="headerlink" title="进程属性"></a>进程属性</h5><ul><li>交互式进程(I/O密集型，等待IO，对cpu的需求量小)</li><li>批处理进程(CPU密集型)</li><li>实时进程</li></ul></li><li><h5 id="分配策略-1"><a href="#分配策略-1" class="headerlink" title="分配策略"></a>分配策略</h5><ul><li><p>不仅要考虑静态优先级，也要考虑进程的属性，如果进程是属于交互式进程，那么可以适当的调高它的优先级，使得界面反应更加迅速，从而提高用户体验。</p></li><li><p>交互式进程可以从一个平均睡眠时间来进行判断，如果进程过去睡眠的时间越多，则越有可能属于交互式进程。则系统在调度的时候，会给该进程更多的奖励(bonus)，以便该进程有更多的时间能够执行。奖励(bonus)的范围为0 - 10。</p></li><li><p>睡眠和CPU耗时反应了进程IO密集和CPU密集两大瞬时特点，不同时期，一个进程可能即是CPU密集型也是IO密集型进程。对于表现为IO密集的进程，应该经常运行，但每次时间片不要太长。对于表现为CPU密集的进程，CPU不应该让其经常运行，但每次运行时间片要长。交互进程为例，假如之前其其大部分时间在于等待CPU，这时为了调高相应速度，就需要增加奖励分。另一方面，如果此进程总是耗尽每次分配给它的时间片，为了对其他进程公平，就要增加这个进程的惩罚分数。</p></li><li><p>系统会严格按照动态优先级高低的顺序安排进程执行。动态优先级高的进程进入运行状态，或者时间片消耗完毕后才会轮到动态优先级低的进程执行。</p></li><li><p>动态优先级的计算主要考虑两个因素</p><ul><li>静态优先级(static_prio)</li><li>平均睡眠时间(bonus)</li></ul></li><li><blockquote><p>计算公式如下<br>$$<br>\text{dynamic_prio} = max{100,\ min{static_prio- bonus+5,\ 139} }<br>$$</p></blockquote></li><li><p>Linux2.6在计算的时候有空间换时间的策略，从而保证最优进程能够在O(1)的时间内完成。</p></li><li><p>CFS 的virtutime机制。</p></li></ul></li></ul><h4 id="进程切换-Context-switch-1"><a href="#进程切换-Context-switch-1" class="headerlink" title="进程切换 (Context switch)"></a>进程切换 (Context switch)</h4><p>当cpu中正在执行的进程(process A)被移出(suspend),cpu中当前进程的相关信息写到需要移除的进程的进程描述符(task_strut)中,下一个进程(process B)被内核读取(该过程称为resume，恢复)到cpu中, 注意：进程的切换也是必须由内核来执行的。进程的切换就是通过<strong>用户空间和内核模式的不断切换</strong>来完成的。<strong>进程切换=CPU加载上下文+CPU执行+CPU保存上下文</strong></p><h4 id="调度触发的时机-1"><a href="#调度触发的时机-1" class="headerlink" title="调度触发的时机"></a>调度触发的时机</h4><ol><li><p>当前进程进入非可执行状态</p></li><li><p>抢占</p><ul><li>进程用完了时间片</li><li>出现优先级更高的进程，会被影响而唤醒。</li></ul><blockquote><p>内核在响应时钟中断的过程中，发现当前进程的时间片已经用完</p><p>内核在响应时钟中断的过程中，发现优先级更高的进程所等待的外部资源是可用的，于是唤醒它。</p><p>​</p></blockquote></li></ol><h3 id="其他相关-1"><a href="#其他相关-1" class="headerlink" title="其他相关"></a>其他相关</h3><h4 id="内核抢占-1"><a href="#内核抢占-1" class="headerlink" title="内核抢占"></a>内核抢占</h4><ul><li>理想情况下，只要满足了出现优先级更高的进程这个条件，当前进程就应该被立刻抢占。但是就像多线程程序需要使用锁来保护临界区资源一样，内核中也有很多这样的临界区，来保证一些程序不给抢占。或者是处于效率考虑。</li><li>Linux2.4不支持内核抢占，进程在内核态是不允许抢占的，只有返回用户态时会触发调整。</li><li>Linux2.6支持内核抢占，但是很多地方为了保护临界区资源而临时性的禁用抢占。</li></ul><h4 id="SMP调度下的负载均衡问题-1"><a href="#SMP调度下的负载均衡问题-1" class="headerlink" title="SMP调度下的负载均衡问题"></a>SMP调度下的负载均衡问题</h4><p><code>多处理器下，每个CPU都有对应的可执行队列，但是一个可执行状态的进程同一时刻只能存在于一个可执行队列中。</code></p><p>问题</p><ul><li>每个CPU可执行队列中进程数目不均衡的时候，要怎么调整，什么时候算作是不均衡，需要调整？</li><li>CPU之间的关系，两个CPU之间，是不是相互独立的，cache可以共享吗？或者，是不是由同一个物理CPU通过超线程技术虚拟出来的</li><li>反正就是乱七八糟的就是了。。。。。</li></ul><h4 id="优先级继承-1"><a href="#优先级继承-1" class="headerlink" title="优先级继承"></a>优先级继承</h4><p><code>假如有一个进程A，因为要进入临界区，但是临界区有了B，而在等待睡眠，直到B退出临界区后，进程A才会被唤醒。</code></p><p>可能存在这么一种情况，A的优先级很高，而B的优先级很低，B进入了临界区，但是却给其他优先级高于B低于A的进程C抢占，A就等不到运行，此时叫做<strong>优先级反转</strong>。此时会通过以下方法解决:在A开始等待的时候，将A的优先级赋给B，直到B退出临界区后恢复其原本的优先级。</p><p>这就是优先级继承。</p><h4 id="中断处理程序的优化-1"><a href="#中断处理程序的优化-1" class="headerlink" title="中断处理程序的优化"></a>中断处理程序的优化</h4><p><code>正常来说，中断处理程序处于一个不可调度的上下文中，CPU响应硬件中断自动跳转到内核设定的中断处理程序去执行，再到处理程序执行完。这整个过程中是不能被抢占的。</code></p><p>一个进程如果被抢占了，可以通过保存在它的进程控制块（task_struct）中的信息，在之后的某个时间恢复它的运行，而中断上下文是没有task_struct的，所以是不可能杯抢占的。</p><p>也就是说，中断程序的伪优先级比任何进程要高，但是呢在实际中，某些实时进程会拥有比中断进程更高的优先级。所以在一些系统中，会给中断处理程序赋予task_struct以及优先级。但是会影响一些性能，但是却能保证实时。</p><h4 id="调度程序的效率问题-1"><a href="#调度程序的效率问题-1" class="headerlink" title="调度程序的效率问题"></a>调度程序的效率问题</h4><p><code>优先级明确了哪个进程应该被调度执行，而调度程序还要关心效率问题，因为会被频繁的执行，所以效率很重要的。</code></p><p>所以，调度程序，如何来获得应该被执行的程序，就是一个问题了。</p><p>在Linux2.4，可执行状态的进程会被放在一个链表中，每次调度，扫描整个链表，以找出最优的那个进程来运行，复杂度为O(N)</p><p>在Linux2.6早期，可执行状态的进车功能会被挂载N（N=140）个链表中，每一个链表代表一个优先级，系统支持多少个优先级就有多少个链表。每次调度，调度程序只需要从第一个不为空的链表中取出链表头的进程即可。复杂度为O(1).</p><p>而在现在Linux2.6的版本中，可执行状态的进程会按照优先级顺序被挂载一个红黑树上，每次调度，找出树中优先级最高的那个进程。复杂度为O(LogN)</p><p><strong>只是为了公平</strong></p><p>第一种是基于空间换时间的策略，在一组数目不大的链表中来实现的，这样子优先级的取值范围很小（大了会浪费太多空间），区分度不大不能满足公平性的需求，而使用红黑树对优先级的取值没有限制，区分度可以更高。而且在同等情况下，140个优先级，O(LogN)的复杂度也不会太差。</p><h4 id="处理机的三级调度-1"><a href="#处理机的三级调度-1" class="headerlink" title="处理机的三级调度"></a>处理机的三级调度</h4><p><img src="http://c.biancheng.net/cpp/uploads/allimg/140629/1-140629144600329.jpg" alt="三级调度"></p><ul><li>作业调度(高级调度)</li><li>内存调度(中级调度)</li><li>进程调度(低级调度)</li></ul><p>作业调度从外存的后备队列中选择一批作业进入内存，为它们建立进程，这些进程被送入就绪队列，进程调度从就绪队列中选出一个进程，并把其状态改为运行状态，把CPU分配给它。中级调度是为了提高内存的利用率，系统将那些暂时不能运行的进程挂起来。当内存空间宽松时，通过中级调度选择具备运行条件的进程，将其唤醒。</p><ul><li>作业调度为进程活动做准备，进程调度使进程正常活动起来，中级调度将暂时不能运行的进程挂起，中级调度处于作业调度和进程调度之间。</li><li>作业调度次数少，中级调度次数略多，进程调度频率最高。</li><li>进程调度是最基本的，不可或缺。</li></ul><p>推荐一篇<a href="https://blog.csdn.net/chengonghao/article/details/50981214" target="_blank" rel="noopener">文章</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Linux进程&quot;&gt;&lt;a href=&quot;#Linux进程&quot; class=&quot;headerlink&quot; title=&quot;Linux进程&quot;&gt;&lt;/a&gt;Linux进程&lt;/h1&gt;&lt;p&gt;[TOC]&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;进程是执行中一段程序，即一旦程序被载入到内存中并
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://dcLunatic.github.io/tags/Linux/"/>
    
      <category term="进程管理" scheme="http://dcLunatic.github.io/tags/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>virtualbox添加虚拟磁盘</title>
    <link href="http://dcLunatic.github.io/2018/09/21/virtualbox%E6%B7%BB%E5%8A%A0%E8%99%9A%E6%8B%9F%E7%A3%81%E7%9B%98/"/>
    <id>http://dcLunatic.github.io/2018/09/21/virtualbox添加虚拟磁盘/</id>
    <published>2018-09-21T06:01:02.000Z</published>
    <updated>2018-09-21T06:01:33.112Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Virutalbox如何添加现有的物理磁盘-分区给虚拟机使用"><a href="#Virutalbox如何添加现有的物理磁盘-分区给虚拟机使用" class="headerlink" title="Virutalbox如何添加现有的物理磁盘/分区给虚拟机使用"></a>Virutalbox如何添加现有的物理磁盘/分区给虚拟机使用</h1><ol><li>使用VBoxManage internalcommands listpartitions -rawdisk \.\PhysicalDrive0列出某个磁盘下的分区信息</li><li>通过分区信息之前的Number，选择想要的分区</li><li>再执行VBoxManage internalcommands createrawvmdk -filename  d:\partition.vmdk -rawdisk<br>\.\PhysicalDrive0 -partition 5即可</li><li>然后打开虚拟机设置-&gt;存储-&gt;添加现有虚拟磁盘文件即可，此时选择那个文件名比较短的。</li></ol><p>注：可能添加后虚拟机无法正常启动，检查相关的配置文件(~/.config/VirtualBox/VirtualBox.xml)信息或者重新新建的时候重新指定vmdk的路径。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Virutalbox如何添加现有的物理磁盘-分区给虚拟机使用&quot;&gt;&lt;a href=&quot;#Virutalbox如何添加现有的物理磁盘-分区给虚拟机使用&quot; class=&quot;headerlink&quot; title=&quot;Virutalbox如何添加现有的物理磁盘/分区给虚拟机使用&quot;&gt;
      
    
    </summary>
    
    
      <category term="virtualbox" scheme="http://dcLunatic.github.io/tags/virtualbox/"/>
    
  </entry>
  
  <entry>
    <title>vim中的编码</title>
    <link href="http://dcLunatic.github.io/2018/09/21/vim%E4%B8%AD%E7%9A%84%E7%BC%96%E7%A0%81/"/>
    <id>http://dcLunatic.github.io/2018/09/21/vim中的编码/</id>
    <published>2018-09-21T05:59:45.000Z</published>
    <updated>2018-09-21T06:00:35.912Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Vim中的编码的编码"><a href="#Vim中的编码的编码" class="headerlink" title="Vim中的编码的编码"></a>Vim中的编码的编码</h1><h2 id="四种编码"><a href="#四种编码" class="headerlink" title="四种编码"></a>四种编码</h2><h3 id="encoding-enc"><a href="#encoding-enc" class="headerlink" title="encoding(enc)"></a>encoding(enc)</h3><p>该选项是内存中编码，就是程序读取文件会转换为encoding所指向的编码存在内存中</p><h3 id="fileencoding-fenc"><a href="#fileencoding-fenc" class="headerlink" title="fileencoding(fenc)"></a>fileencoding(fenc)</h3><p>该选项是vim写入文件时采用的编码类型。</p><h3 id="fileencodings-fencs"><a href="#fileencodings-fencs" class="headerlink" title="fileencodings(fencs)"></a>fileencodings(fencs)</h3><p>该选项是vim在识别文件时采用的不同编码</p><h3 id="termencoding-tenc"><a href="#termencoding-tenc" class="headerlink" title="termencoding(tenc)"></a>termencoding(tenc)</h3><p>该选项代表输出到客户终端（Term）采用的编码类型。</p><h2 id="文件打开写入保存过程"><a href="#文件打开写入保存过程" class="headerlink" title="文件打开写入保存过程"></a>文件打开写入保存过程</h2><p>当你打开一个文件，首先从文件读入数据到内存，然后从fileencodings里依次使用各个编码来尝试转换为encoding。如果有一个成功，直接转换显示，否则就取encoding作为fileencoding。</p><p>当你保存一个文件，把内存中的数据从encoding转换为fileencoding，然后再写入文件。</p><h2 id="TIPS"><a href="#TIPS" class="headerlink" title="TIPS"></a>TIPS</h2><p>可以使用<code>:e ++enc=&lt;encoding&gt;</code>来强制加载某种编码</p><p>如果是中文编码，但是不知道是哪种，可以这样<code>e ++enc=chinese</code></p><p>如果一个文件的编码是gbk,想要保存成utf-8，可以这样操作</p><p><code>:e ++enc=gbk</code>，设置以下当前文件的编码</p><p><code>set fenc=utf-8</code>，设置文件编码为utf-8</p><p><code>w</code>，保存</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Vim中的编码的编码&quot;&gt;&lt;a href=&quot;#Vim中的编码的编码&quot; class=&quot;headerlink&quot; title=&quot;Vim中的编码的编码&quot;&gt;&lt;/a&gt;Vim中的编码的编码&lt;/h1&gt;&lt;h2 id=&quot;四种编码&quot;&gt;&lt;a href=&quot;#四种编码&quot; class=&quot;head
      
    
    </summary>
    
    
      <category term="vim" scheme="http://dcLunatic.github.io/tags/vim/"/>
    
      <category term="编码" scheme="http://dcLunatic.github.io/tags/%E7%BC%96%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>linux中的命令链接操作符</title>
    <link href="http://dcLunatic.github.io/2018/09/21/linux%E4%B8%AD%E7%9A%84%E5%91%BD%E4%BB%A4%E9%93%BE%E6%8E%A5%E6%93%8D%E4%BD%9C%E7%AC%A6/"/>
    <id>http://dcLunatic.github.io/2018/09/21/linux中的命令链接操作符/</id>
    <published>2018-09-21T05:58:00.000Z</published>
    <updated>2018-09-21T05:59:20.826Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux中的命令链接操作符"><a href="#Linux中的命令链接操作符" class="headerlink" title="Linux中的命令链接操作符"></a>Linux中的命令链接操作符</h1><p>在linux中，我们可以通过一些特殊的操作符，比如说管道“|”，来将几个不同的命令结合起来执行，这些操作符就叫做命令链接操作符。</p><h2 id="amp"><a href="#amp" class="headerlink" title="&amp;"></a>&amp;</h2><p><code>&amp;</code>的作用是让当前命令在后台执行，当我们在执行一些比较耗时的命令时，比如<code>apt-get update</code>，这样子就不会占用当前的终端界面了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@dcLunatic:~# apt-get update &amp;</span><br></pre></td></tr></table></figure><p>使用<code>jobs</code>命令可以查看当前的后台作业运行情况，<code>fg</code>可以将后台中的作业切换到前台运行，<code>bg</code>可以将暂停的作业切换成继续执行。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">root@dcLunatic:~# vim &amp;</span><br><span class="line">[1] 3046</span><br><span class="line">root@dcLunatic:~# jobs</span><br><span class="line">[1]+  Stopped                 vim</span><br><span class="line">root@dcLunatic:~# fg 1</span><br><span class="line">root@dcLunatic:~# bg 1</span><br></pre></td></tr></table></figure><blockquote><p>Ctrl + Z可以将当前正在前台执行的命令放到后台，并且暂停</p></blockquote><h2 id=""><a href="#" class="headerlink" title=";"></a>;</h2><p><code>;</code>分号操作符可以让你在一次执行多条命令，每条命令之间只需要通过;连接，命令从左到右依次执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@dcLunatic:~/net-learning# date "+%x %X";echo "    John: Hello world!"</span><br><span class="line">08/06/18 19:40:02</span><br><span class="line">    John: Hello world!</span><br></pre></td></tr></table></figure><h2 id="amp-amp"><a href="#amp-amp" class="headerlink" title="&amp;&amp;"></a>&amp;&amp;</h2><p>当多个命令用<code>&amp;&amp;</code>连接时，只有前面的命令成功执行时，才会之后面的命令。</p><p>比如说，从网站<a href="http://www.linuxde.net下载东西，首先先检查是否可以连接到该网站" target="_blank" rel="noopener">www.linuxde.net下载东西，首先先检查是否可以连接到该网站</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@dcLunatic:~# ping www.linuxde.net &amp;&amp; wget http://www.linuxde.net/testfile.zip</span><br></pre></td></tr></table></figure><blockquote><p>在类UNIX里面，0表示无错误，而所有非0返回值都是各种错误</p></blockquote><h2 id="-1"><a href="#-1" class="headerlink" title="||"></a>||</h2><p><code>||</code>操作符跟<code>&amp;&amp;</code>操作符相反，只有当前面的命令失败时，才会执行后面的命令</p><p>举个例子</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">test@dcLunactic:/root/$ ls rootFile.txt -l</span><br><span class="line">-rw-r----- 1 root root 201 Jul 31 19:15 rootFile.txt</span><br><span class="line">test@dcLunactic:/root/$: echo "Hello world!" &gt;&gt; rootFile.txt || echo "无法写入该文件"</span><br><span class="line">sh: 13: cannot create rootFile.txt: Permission denied</span><br><span class="line">无法写入文件</span><br></pre></td></tr></table></figure><h2 id="-2"><a href="#-2" class="headerlink" title="!"></a>!</h2><p><code>!</code>跟很多编程语言中的!一样，都是表示非的意思。</p><p>举个例子，删除所有非txt文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@dcLunatic:~/Downloads# ls</span><br><span class="line">1.zip  2.html  3.pdf  4.docx  5.txt  6.py  7.cpp  8.class  9.java</span><br><span class="line">root@dcLunatic:~/net-learning/test# rm -f !(*.txt)</span><br><span class="line">root@dcLunatic:~/net-learning/test# ls</span><br><span class="line">5.txt</span><br></pre></td></tr></table></figure><h2 id="amp-amp-–"><a href="#amp-amp-–" class="headerlink" title="&amp;&amp;–||"></a>&amp;&amp;–||</h2><p><code>&amp;&amp;--||</code>操作符是一对组合操作符，作用跟编程语言中的if–else一样，当前面的命令成功执行时，执行&amp;&amp;后的命令，否则执行||后的命令</p><p>还是上面的例子</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">test@dcLunactic:/root/$ ls rootFile.txt -l</span><br><span class="line">-rw-r----- 1 root root 201 Jul 31 19:15 rootFile.txt</span><br><span class="line">test@dcLunactic:/root/$: echo "Hello world!" &gt;&gt; rootFile.txt &amp;&amp; echo "写入成功"  || echo "无法写入该文件"</span><br><span class="line">sh: 13: cannot create rootFile.txt: Permission denied</span><br><span class="line">无法写入文件</span><br></pre></td></tr></table></figure><h2 id="-3"><a href="#-3" class="headerlink" title="|"></a>|</h2><p>管道操作符，当多个命令用|连接时，将前面命令的输出作为后面命令的输入。</p><p>举个例子，查看是否有vim进程</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@dcLunatic:~# ps -e | grep vim</span><br><span class="line"> 3053 pts/0    00:00:00 vim</span><br></pre></td></tr></table></figure><h2 id="-4"><a href="#-4" class="headerlink" title="{}"></a>{}</h2><p>合并操作符把，会把在{}中的命令当成是一个整体去执行</p><p>比如说，检查一下文件1.java是否存在，如果不存在则创建之并输出提示信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@dcLunatic:~# test -f 1.java || &#123;touch 1.java;echo "文件不存在，创建之"&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里也可以换一种写法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span> root@dcLunatic:~# [-f 1.java] || &#123;touch 1.java;echo "文件不存在，创建之"&#125;</span><br><span class="line"><span class="meta">&gt;</span></span><br></pre></td></tr></table></figure></blockquote><blockquote><h2 id="-5"><a href="#-5" class="headerlink" title="[]"></a>[]</h2><p>左中括号[和test是等同的。右中括号是关闭条件判断的。</p><p>比如判断文件是否存在<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span> root@dcLunatic:~/net-learning# [ -f 123.txt ]</span><br><span class="line"><span class="meta">&gt;</span> root@dcLunatic:~/net-learning# echo $?</span><br><span class="line"><span class="meta">&gt;</span> 1</span><br><span class="line"><span class="meta">&gt;</span></span><br></pre></td></tr></table></figure></p></blockquote><h2 id="-6"><a href="#-6" class="headerlink" title="()"></a>()</h2><p><code>()</code>可以改变优先级顺序什么的，跟数学中的()一样</p><p>比如上面的也可以这么写</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@dcLunatic:~# test -f 1.java || (touch 1.java;echo "文件不存在，创建之")</span><br></pre></td></tr></table></figure><p><code>(Command_x1 &amp;&amp;Command_x2) || (Command_x3 &amp;&amp; Command_x4)</code>这样子的话，如果Command_x1执行失败，Command_x2不会执行，但是Command_x3会继续执行， Command_x4会依赖于 Command_x3的退出状态。</p><h2 id="-7"><a href="#-7" class="headerlink" title="\"></a>\</h2><p>连接符<code>\</code>，当一句命令太长需要分行写时，使用 \ 可以换行。</p><p>比如重启网络服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart \</span><br><span class="line">networking.service</span><br><span class="line">network-manager.service</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Linux中的命令链接操作符&quot;&gt;&lt;a href=&quot;#Linux中的命令链接操作符&quot; class=&quot;headerlink&quot; title=&quot;Linux中的命令链接操作符&quot;&gt;&lt;/a&gt;Linux中的命令链接操作符&lt;/h1&gt;&lt;p&gt;在linux中，我们可以通过一些特殊的操作符
      
    
    </summary>
    
    
      <category term="linux" scheme="http://dcLunatic.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>kali安装steam</title>
    <link href="http://dcLunatic.github.io/2018/09/21/kali%E5%AE%89%E8%A3%85steam/"/>
    <id>http://dcLunatic.github.io/2018/09/21/kali安装steam/</id>
    <published>2018-09-21T05:56:18.000Z</published>
    <updated>2018-09-29T11:02:46.586Z</updated>
    
    <content type="html"><![CDATA[<h1 id="kali-或者其他如Debian系列-下安装steam"><a href="#kali-或者其他如Debian系列-下安装steam" class="headerlink" title="kali(或者其他如Debian系列)下安装steam"></a>kali(或者其他如Debian系列)下安装steam</h1><blockquote><p>这里建议开启电脑的独显，不然游戏效果不佳，详见</p></blockquote><p>Steam安装：</p><p>官网下载deb包</p><p><code>sudo dpkg -i filename.deb</code></p><p>如果报错：missing lib32 …..libGL.so.1 and libdrm.so.2</p><p>在安装好后：</p><p>Check your default Architecture by using:</p><p><code>sudo dpkg --print-architecture</code></p><p>You will get your default Architecture which would be amd64.<br>We need to add i386 Architecture.<br>Use this code:</p><p><code>sudo dpkg --add-architecture i386</code></p><p>Just to verify that it has been added successfully, use this code:</p><p><code>sudo dpkg --print-foreign-architectures</code></p><p>If it has been added, proceed to update in order to get the 32 bit packages.</p><p>Use Code:<br><code>sudo apt update</code></p><p>Now try installing steam from the updated repository.</p><p><code>sudo apt-get install steam</code></p><p>Since steam is not permitted to run as root by default.</p><p>It is advised to run steam as a non-root user.<br>Just create a non-root user and run steam from that, you should be okay.</p><p>If you are persistent, follow these steps:<br>1.Open /usr/bin/steam<br><code>nano /usr/bin/steam</code><br>2.Comment or Delete these lines:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if [ "$(id -u)" == "0" ]; then</span><br><span class="line">show_message --error $"Cannot run as root user"</span><br><span class="line">exit 1</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></p><p>3.Open steam.<br>It is working!!!</p><p>可以看这个网页<br><a href="https://steamcommunity.com/discussions/forum/1/2595630410174705687/" target="_blank" rel="noopener">https://steamcommunity.com/discussions/forum/1/2595630410174705687/</a></p><p>Steam卸载：</p><p><code>sudo apt-get remove steam</code></p><p>Purge Steam Perfectly with Configuration files with the following</p><p><code>sudo apt-get purge steam sudo dpkg --print-architecture</code></p><p>delete its directory located at home folder<br><code>rm -rf ~/.local/share/Steam &amp;&amp; rm -rf ~/.steam</code></p><h2 id="LIBGL-DRI3-DISABLE-1-steam"><a href="#LIBGL-DRI3-DISABLE-1-steam" class="headerlink" title="LIBGL_DRI3_DISABLE=1 steam"></a>LIBGL_DRI3_DISABLE=1 steam</h2><p>如果在下载游戏时下着下着突然就停了，或者直接无法下载，提示无法连接到服务器，可以考虑更换下载服务器</p><p>右上角，steam，设置，下载，更换即可</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;kali-或者其他如Debian系列-下安装steam&quot;&gt;&lt;a href=&quot;#kali-或者其他如Debian系列-下安装steam&quot; class=&quot;headerlink&quot; title=&quot;kali(或者其他如Debian系列)下安装steam&quot;&gt;&lt;/a&gt;kali(
      
    
    </summary>
    
    
      <category term="kali" scheme="http://dcLunatic.github.io/tags/kali/"/>
    
      <category term="steam" scheme="http://dcLunatic.github.io/tags/steam/"/>
    
  </entry>
  
  <entry>
    <title>Java中获得实例的方法</title>
    <link href="http://dcLunatic.github.io/2018/09/21/Java%E4%B8%AD%E8%8E%B7%E5%BE%97%E5%AE%9E%E4%BE%8B%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>http://dcLunatic.github.io/2018/09/21/Java中获得实例的方法/</id>
    <published>2018-09-21T05:52:12.000Z</published>
    <updated>2018-09-21T05:53:00.317Z</updated>
    
    <content type="html"><![CDATA[<h1 id="获取实例的方法"><a href="#获取实例的方法" class="headerlink" title="获取实例的方法"></a>获取实例的方法</h1><h2 id="通过new关键字"><a href="#通过new关键字" class="headerlink" title="通过new关键字"></a>通过new关键字</h2><p>通过new来获得一个类的实例，这是最最最常见的了。</p><h2 id="通过clone方法"><a href="#通过clone方法" class="headerlink" title="通过clone方法"></a>通过clone方法</h2><p>首先该类实现了Cloneable接口，实现了clone()方法，这时候，便可以通过调用某个已存在的对象的clone()方法来获得实例了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> <span class="title">throws</span> <span class="title">Exception</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String... args)</span></span>&#123;</span><br><span class="line">        Test t1 = <span class="keyword">new</span> Test();</span><br><span class="line">        Test t2 = t1.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于克隆的话，需要了解一下浅克隆跟深克隆。</p><h2 id="通过调用Class下的newInstance-方法-只能无参构造"><a href="#通过调用Class下的newInstance-方法-只能无参构造" class="headerlink" title="通过调用Class下的newInstance()方法(只能无参构造)"></a>通过调用Class下的newInstance()方法(只能无参构造)</h2><p>在Class类下，有一个方法newInstance()，该方法可以在我们获取到一个类的Class对象后，通过该Class对象新建一个实例，但是在新建实例的时候，无法传递参数，也就是说，只能用于无参构造。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String... args)</span></span>&#123;</span><br><span class="line">        Test t1 = Test.class.newInstance();</span><br><span class="line">        Test t2 = t1.getClass().newInstance();</span><br><span class="line">        Test t2 = (Test)Class.forName(<span class="string">"Test"</span>).newInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的话，主要就是如何获取一个类的Class对象了，首先，直接通过.class访问即可，其次，通过类的getClass()方法获取，再者，也可以类似于数据库开发中经常用到的Class.forName(String)来获取。</p><blockquote><p>在数据库开发中，我们会经常看到Class.forName()这个方法的调用，但是接下来就没有类似于上面的调用newInstance()方法了，但需要用到的实例却是存在了。</p><p>在这里，Class.forName()是用来动态加载类，在加载类的时候，自然就会加载了类里面的一些东西了，如果刚好这个类中有静态的初始化器的话，自然的，jvm就会执行。</p><p>在对应的源码中我们可以看到</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Driver</span> <span class="keyword">extends</span> <span class="title">NonRegisteringDriver</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">sql</span>.<span class="title">Driver</span> </span>&#123;</span><br><span class="line">&gt; <span class="keyword">static</span> &#123;</span><br><span class="line">&gt; <span class="keyword">try</span> &#123;</span><br><span class="line">&gt; java.sql.DriverManager.registerDriver(<span class="keyword">new</span> Driver());</span><br><span class="line">&gt; &#125; <span class="keyword">catch</span> (SQLException E) &#123;</span><br><span class="line">&gt; <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Can't register driver!"</span>);</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; <span class="function"><span class="keyword">public</span> <span class="title">Driver</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">&gt; <span class="comment">// Required for Class.forName().newInstance()</span></span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>自然的，也就有了。</p></blockquote><h2 id="通过Constructor类的newInstance-方法"><a href="#通过Constructor类的newInstance-方法" class="headerlink" title="通过Constructor类的newInstance()方法"></a>通过Constructor类的newInstance()方法</h2><p>和Class类的newInstance()方法很像，java.lang.reflect.Constructor类中也有一个newInstance()方法可以创建对象，通过反射来获得类的任何构造方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.*;</span><br><span class="line"><span class="keyword">public</span> Class Main&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String... args)</span></span>&#123;</span><br><span class="line">        Constructor&lt;Test&gt; c = Test.class.getConstructor();</span><br><span class="line">        Test t1 = c.newInstance();</span><br><span class="line">        <span class="comment">//如果Test类有这种构造方法的话</span></span><br><span class="line">        Test t2 = c.newInstance(<span class="string">"arg1"</span>, <span class="string">"arg2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="通过反序列化"><a href="#通过反序列化" class="headerlink" title="通过反序列化"></a>通过反序列化</h2><p>当我们将对象序列化成二进制字节码后，我们也可以将这个二进制字节码通过反序列化变成一个对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Hello world"</span>);</span><br><span class="line">        SerializeDemo();</span><br><span class="line">        DeserializeDemo();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SerializeDemo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Test test = <span class="keyword">new</span> Test(<span class="string">"John"</span>, <span class="number">15</span>);</span><br><span class="line">            ObjectOutputStream oo = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(<span class="string">"/root/Desktop/test.txt"</span>)));</span><br><span class="line">            oo.writeObject(test);</span><br><span class="line">            System.out.println(<span class="string">"序列化结束"</span>);</span><br><span class="line">            oo.close();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(FileNotFoundException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"无法读写文件"</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"IO异常"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DeserializeDemo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            ObjectInputStream oi = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(<span class="string">"/root/Desktop/test.txt"</span>)));</span><br><span class="line">            Test test = (Test)oi.readObject();</span><br><span class="line">            System.out.println(<span class="string">"反序列化成功"</span>);</span><br><span class="line">            System.out.println(test.toString());</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String sex;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">(String name, <span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Test&#123;"</span> +</span><br><span class="line">                <span class="string">"age="</span> + age +</span><br><span class="line">                <span class="string">", name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;获取实例的方法&quot;&gt;&lt;a href=&quot;#获取实例的方法&quot; class=&quot;headerlink&quot; title=&quot;获取实例的方法&quot;&gt;&lt;/a&gt;获取实例的方法&lt;/h1&gt;&lt;h2 id=&quot;通过new关键字&quot;&gt;&lt;a href=&quot;#通过new关键字&quot; class=&quot;headerli
      
    
    </summary>
    
    
      <category term="java" scheme="http://dcLunatic.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Java网络编程</title>
    <link href="http://dcLunatic.github.io/2018/09/21/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    <id>http://dcLunatic.github.io/2018/09/21/Java网络编程/</id>
    <published>2018-09-21T05:50:54.000Z</published>
    <updated>2018-09-21T05:51:37.798Z</updated>
    
    <content type="html"><![CDATA[<h1 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h1><h2 id="InetAddress"><a href="#InetAddress" class="headerlink" title="InetAddress"></a>InetAddress</h2><h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h3><p>java中使用InetAddress类来表示ip地址，其两个子类Inet4Address和Inet6Address分别表示ipv4地址和ipv6地址。</p><p><strong>没有明显的构造函数，通过静态方法获得实例</strong></p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ul><li><p><strong>public static InetAddress getByName(String host) throws UnknownHostException</strong></p><p>在给定的主机名的情况下确定主机的ip地址。当找不到host的ip地址或者scope_id为全局的ipv6地址指定的，则抛出异常。</p><p>主机名可以是机器名（如 “<code>java.sun.com</code>“），也可以是其 IP 地址的文本表示形式。如果提供字面值 IP 地址，则仅检查地址格式的有效性。 </p></li><li><p><strong>public static InetAddress[] getAllByName(String host) throws UnknownHostException</strong></p><p>在给定主机名的情况下，根据系统上配置的名称服务返回其ip地址所组成的数组。当找不到host的ip地址或者scope_id为全局的ipv6地址指定的，则抛出异常。</p><p>主机名可以是机器名（如 “<code>java.sun.com</code>“），也可以是其 IP 地址的文本表示形式。如果提供字面值 IP 地址，则仅检查地址格式的有效性。 </p></li><li><p><strong>public static InetAddress getByAddress(byte[] addr) throws UnknownHostException</strong></p><p>在给定原始ip地址的情况下，返回InetAddress对象。参照网络字节顺序，地址高位字节位于getAddress()[0]中。ipv4地址byte数组的长度必须为4个字节，ipv6的必须为16个字节。如果长度非法，则抛出异常。</p></li><li><p><strong>public static InetAddress getByAddress(String host, byte[] addr) throws UnknownHostException</strong></p><p>根据提供的主机名和IP地址创建InetAddress。不检查名称服务的地址有效性。当ip地址长度非法时，抛出异常。</p><p>主机名可以是机器名（如 “<code>java.sun.com</code>“），也可以是其 IP 地址的文本表示形式。</p></li><li><p><strong>public static InetAddress getLocalHost() throws UnknownHostException</strong></p><p>返回本地主机的ip地址。如果找不到host的任何ip地址的时候，抛出异常。</p></li></ul><p><strong>下面是一些常用的方法</strong></p><ul><li>public byte[] getAddress()                     //返回此对象的原始ip地址，结果按照网络字节顺序。</li><li>public String getHostAddress()            //以字符串形式返回ip地址。</li><li>public String getHostName()               //以字符串形式返回主机名。如果此 InetAddress 是用主机名创建的，则记忆并返回主机名；否则，将执行反向名称查找并基于系统配置的名称查找服务返回结果。</li><li>public String toString()                          //将此ip地址转换为<code>主机名/字面值ip地址</code>形式的字符串。如果主机名未解析，则主机名为空。</li><li>public boolean isReachable(int timeout) throws IOException    //测试是否可以达到该地址。超时值单位为毫秒。发生网络异常时，抛出IOException，timeout为负时抛出IllegalArgumentException。</li><li>public boolean isReachable(NetworkInterface netif, int ttl, int timeout)    //测试是否可以到达该地址。允许指定网络接口和数据包的最大跳数，超时值单位为毫秒。发生网络异常时，抛出IOException，ttl或timeout为负时抛出IllegalArgumentException。</li><li>public String getCanonicalHostName()    //获取此ip地址的完全限定域名。</li></ul><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InetAddressTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String... args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        InetAddress addr = InetAddress.getByName(<span class="string">"183.232.231.172"</span>);</span><br><span class="line">        System.out.println(addr);</span><br><span class="line">        addr = InetAddress.getByName(<span class="string">"www.baidu.com"</span>);</span><br><span class="line">        System.out.println(addr);</span><br><span class="line">        System.out.println(<span class="string">"完全限定域名: "</span> + addr.getCanonicalHostName());</span><br><span class="line">        <span class="keyword">byte</span>[] ipaddr = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span>];</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">183</span>,<span class="number">232</span>,<span class="number">231</span>,<span class="number">172</span>&#125;)</span><br><span class="line">            ipaddr[index++] = (<span class="keyword">byte</span>)(i&amp;<span class="number">0xff</span>);</span><br><span class="line">        addr = InetAddress.getByAddress(ipaddr);</span><br><span class="line">        System.out.println(addr);</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">"是否可达: "</span> + addr.isReachable(<span class="number">1000</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p>URL对象代表统一资源定位符，是指向互联网资源的指针，它使用协议名、主机名、端口和资源组成，即满足如下格式：<code>protocol://host:port/resourceName</code>，可以通过URL对象来获取该URL对应的资源等信息。</p><p>但URL 类自身并不根据 RFC2396 中定义的转义机制编码或解码任何 URL 部分。由调用方对任何需要在调用 URL 前进行转义的字段进行编码，并对从 URL 返回的任何经过转义的字段进行解码。比如对于这两个URL：<code>http://foo.com/hello world/</code>和<code>http://foo.com/hello%20world</code>将被视为互不相等。</p><p> 注意，URI 类在某些特定情况下对其组成字段执行转义。建议使用 URI 管理 URL 的编码和解码，并使用 toURI() 和 URI.toURL() 实现这两个类之间的转换。</p><p>也可以使用 URLEncoder 和 URLDecoder 类，但是只适用于 HTML 形式的编码，它与 RFC2396 中定义的编码机制不同。 </p><h3 id="常用构造方法"><a href="#常用构造方法" class="headerlink" title="常用构造方法"></a>常用构造方法</h3><ul><li><strong>public URL(String spec) throws MalformedURLException</strong>                             //根据String表示形式创建URL对象，当协议不存在或者未知时，抛出异常。</li><li><strong>URL(String protocol, String host, int port, String file) throws MalformedURLException </strong>   //根据protocol、host、port、file创建URL对象，当port为-1时，使用协议的默认端口。当协议不存在或者未知时，抛出异常。</li><li><strong>URL(String protocol, String host, String file) throws MalformedURLException</strong>    //根据protocol、host、file创建URL对象，这里使用的是协议的默认端口。当协议不存在或者未知时，抛出异常。</li><li><strong>URL(URL context, String url) throws MalformedURLException</strong>          //使用基地址和相对位置创建URL对象。当协议不存在或者未知时，抛出异常。</li></ul><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><ul><li>public String getAuthority()                                                //获得此URL的授权部分。</li><li>public Object getContent()                                                 //获得此URL的内容。</li><li>public Object getContent(Class[] classes)                       //获得此URL的内容，相当于openConnection().getContent(Class[])。</li><li>public int getDefaultPort()                                                 //返回此URL关联协议的默认端口号。</li><li>public String getFile()                                                          //返回此URL的文件名</li><li>public String getHost()                                                        //返回此URL的主机名</li><li>public String getPath()                                                        //返回此URL的路径部分</li><li>public int getPort()                                                               //返回此URL的端口号</li><li>public String getProtocol()                                                  //返回此URL的协议名称</li><li>public String getQuery()                                                      //返回此URL的查询部分</li><li>public String getRef()                                                           //返回此URL的锚点（也称引用）</li><li>public URLConnection openConnection()                        //返回一个URLConnection对象，表示URL所引用的远程对象的连接</li><li>public URLConnection openConnection(Proxy proxy)   //与 openConnection() 类似，所不同是连接通过指定的代理建立；不支持代理方式的协议处理程序将忽略该代理参数并建立正常的连接。</li><li>public InputStream openStream()                                      //打开到此URL的连接并返回一个用于从该连接接入的InputStream</li><li>public boolean sameFile(URL other)                                  //比较两个URL，不包括片段部分</li><li>public String toExternalForm()                                            //返回此URL的字符串形式，作用跟toString()一样</li><li>public URI toURI()                                                                  //返回与此URL等效的URI。</li></ul><h3 id="使用例子"><a href="#使用例子" class="headerlink" title="使用例子"></a>使用例子</h3><p>下载一张图片</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">URLTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String... args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        URL imgurl = <span class="keyword">new</span> URL(<span class="string">"http://img5.duitang.com/uploads/item/201511/06/20151106190951_YXSZN.jpeg"</span>);</span><br><span class="line">        System.out.println(<span class="string">"路径部分:"</span> + imgurl.getPath());</span><br><span class="line">        System.out.println(<span class="string">"文件名:"</span> + imgurl.getFile());</span><br><span class="line">        InputStream is = imgurl.openStream();</span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">"picture.jpg"</span>);</span><br><span class="line">        <span class="keyword">if</span>(!file.exists())</span><br><span class="line">            file.createNewFile();</span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(file);</span><br><span class="line">        <span class="keyword">int</span> ch;</span><br><span class="line">        <span class="keyword">while</span>((ch = is.read()) != -<span class="number">1</span>)</span><br><span class="line">            fos.write(ch);</span><br><span class="line">        fos.close();</span><br><span class="line">        is.close();</span><br><span class="line">        System.out.println(<span class="string">"Done."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外一个例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过命令行参数指定在斗图啦网站要搜索的图片的关键字，然后将搜索结果的前几张图片下载保存</span></span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyPictureTool</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DTL = <span class="string">"http://www.doutula.com"</span>;</span><br><span class="line">    <span class="comment">//给出目的地址，测试在指定时间内是否能到达地址所在的主机</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">testNetwork</span><span class="params">(String str, <span class="keyword">int</span> timeout)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            URL url = <span class="keyword">new</span> URL(str);</span><br><span class="line">            InetAddress addr = InetAddress.getByName(url.getHost());</span><br><span class="line">            <span class="keyword">if</span>(addr.isReachable(timeout))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取斗图啦的搜索结果</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">search</span><span class="params">(String key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            String searchUrl = DTL + <span class="string">"/search?keyword="</span> + URLEncoder.encode(key, <span class="string">"UTF-8"</span>);</span><br><span class="line">            <span class="comment">//System.out.println(searchUrl);</span></span><br><span class="line">            URL url = <span class="keyword">new</span> URL(searchUrl);</span><br><span class="line">            InputStream is = url.openStream();</span><br><span class="line">            BufferedReader bf = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(is));</span><br><span class="line">            StringBuilder content = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            String line;</span><br><span class="line">            <span class="keyword">while</span>((line = bf.readLine()) != <span class="keyword">null</span>)&#123;</span><br><span class="line">                content.append(line);</span><br><span class="line">                content.append(<span class="string">"\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            bf.close();</span><br><span class="line">            <span class="keyword">return</span> content.toString();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//写入内容到指定文件</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">writeToFile</span><span class="params">(String data, String filename, <span class="keyword">boolean</span> flag)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            File file = <span class="keyword">new</span> File(filename);</span><br><span class="line">            <span class="keyword">if</span>(!file.exists())</span><br><span class="line">                file.createNewFile();</span><br><span class="line">            FileWriter fw = <span class="keyword">new</span> FileWriter(file, flag);</span><br><span class="line">            fw.write(data);</span><br><span class="line">            fw.close();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将链接对应的URL资源下载保存到指定的文件中</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">downloadUrl</span><span class="params">(String strUrl, String filename)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            File file = <span class="keyword">new</span> File(filename);</span><br><span class="line">            <span class="keyword">if</span>(!file.exists())</span><br><span class="line">                file.createNewFile();</span><br><span class="line">            URL url = <span class="keyword">new</span> URL(strUrl);</span><br><span class="line">            InputStream is = url.openStream();</span><br><span class="line">            FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(file);</span><br><span class="line">            <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">int</span> len = -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>((len = is.read(buf)) != -<span class="number">1</span>)&#123;</span><br><span class="line">                fos.write(buf, <span class="number">0</span>, len);</span><br><span class="line">            &#125;</span><br><span class="line">            fos.close();</span><br><span class="line">            is.close();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        </span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//匹配搜索结果中的图片链接，并保存在list参数中，可指定返回的链接数，返回实际返回的链接数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getPictureUrl</span><span class="params">(String html, List&lt;String&gt; list, <span class="keyword">int</span> count)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Matcher matcher = Pattern.compile(<span class="string">"&lt;div class=\"random_picture\"&gt;[\\s\\S]*?(?&lt;!&lt;/script&gt;)\n&lt;/div&gt;"</span>).matcher(html);</span><br><span class="line">            <span class="keyword">if</span>(matcher.find())&#123;</span><br><span class="line">                String rs = matcher.group();</span><br><span class="line">                matcher = Pattern.compile(<span class="string">"&lt;img.*?data-backup=\"(.*?)\""</span>).matcher(rs);</span><br><span class="line">                <span class="keyword">int</span> i;</span><br><span class="line">                <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; count &amp;&amp; matcher.find(); i++)&#123;</span><br><span class="line">                    list.add(matcher.group(<span class="number">1</span>).replace(<span class="string">"thumb150"</span>, <span class="string">"large"</span>));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> i; </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取pictureUrl的图片类型,如"jpg" "gif"等</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">getPictureType</span><span class="params">(String pictureUrl)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pos = pictureUrl.lastIndexOf(<span class="string">'.'</span>);</span><br><span class="line">        <span class="keyword">if</span>(pos == -<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> pictureUrl.substring(pos+<span class="number">1</span>, pictureUrl.length()); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(args.length != <span class="number">2</span> &amp;&amp; args.length != <span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"从斗图啦网站搜索并下载指定数量的关键词相关图片"</span>);</span><br><span class="line">            System.out.println(<span class="string">"Usage: java MyPictureTool keyWord [downloadCount=6]"</span>);</span><br><span class="line">            System.exit(-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(args.length == <span class="number">1</span>)</span><br><span class="line">            count = <span class="number">6</span>;</span><br><span class="line">        <span class="keyword">if</span>(args.length == <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                count = Integer.parseInt(args[<span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">if</span>(count &lt; <span class="number">1</span>)&#123;</span><br><span class="line">                    System.out.println(<span class="string">"请输入正确的downloadCount参数"</span>);</span><br><span class="line">                    System.out.println(<span class="string">"从斗图啦网站搜索并下载指定数量的关键词相关图片"</span>);</span><br><span class="line">                    System.out.println(<span class="string">"Usage: java MyPictureTool keyWord [downloadCount=6]"</span>);</span><br><span class="line">                    System.exit(-<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">                System.out.println(<span class="string">"请输入正确的downloadCount参数"</span>);</span><br><span class="line">                System.out.println(<span class="string">"从斗图啦网站搜索并下载指定数量的关键词相关图片"</span>);</span><br><span class="line">                System.out.println(<span class="string">"Usage: java MyPictureTool keyWord [downloadCount=6]"</span>);</span><br><span class="line">                System.exit(-<span class="number">1</span>);                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"&gt;&gt; 搜索关键词为 "</span> + args[<span class="number">0</span>] + <span class="string">" 的图片，并下载搜索结果的前 "</span> + count + <span class="string">" 张\n"</span>);</span><br><span class="line">        String html = search(args[<span class="number">0</span>]);</span><br><span class="line">        List&lt;String&gt; pictureUrl = <span class="keyword">new</span> ArrayList&lt;String&gt;(count);</span><br><span class="line">        <span class="keyword">if</span>(getPictureUrl(html, pictureUrl, count) &lt; <span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"搜索结果异常"</span>);</span><br><span class="line">            System.exit(-<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//创建下载文件目录</span></span><br><span class="line">        File downloadDir = <span class="keyword">new</span> File(<span class="string">"."</span> + File.separator + args[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">if</span>(!downloadDir.exists())</span><br><span class="line">            downloadDir.mkdirs();</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> successDownload = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pictureUrl.size(); i++)&#123;</span><br><span class="line">            System.out.println(<span class="string">"图片链接: "</span> + pictureUrl.get(i));</span><br><span class="line">            String type = getPictureType(pictureUrl.get(i));</span><br><span class="line">            <span class="keyword">if</span>(type == <span class="keyword">null</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">"链接异常，跳过"</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            String pictureName = <span class="string">"."</span> + File.separator  + args[<span class="number">0</span>] + File.separator + (i+<span class="number">1</span>) + <span class="string">"."</span> + type;</span><br><span class="line">            System.out.println(<span class="string">"正在保存图片..."</span>);</span><br><span class="line">            <span class="keyword">if</span>(downloadUrl(pictureUrl.get(i), pictureName))&#123;</span><br><span class="line">                System.out.println(<span class="string">"保存成功，图片位置: "</span> + pictureName);</span><br><span class="line">                successDownload++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                System.out.println(<span class="string">"由于异常原因，保存失败"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"\n&gt;&gt; 下载完成，成功下载 "</span> + successDownload + <span class="string">" 张"</span>);</span><br><span class="line">        System.out.println(<span class="string">"Done."</span>);</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="URI-此部分来自api文档"><a href="#URI-此部分来自api文档" class="headerlink" title="URI(此部分来自api文档)"></a>URI(此部分来自api文档)</h2><h3 id="URI-语法和组成部分"><a href="#URI-语法和组成部分" class="headerlink" title="URI 语法和组成部分"></a>URI 语法和组成部分</h3><p>在最高级别上，字符串形式的 URI 引用（以下简写为”URI”）语法如下</p><p>[<em>scheme**</em>:<strong>]<em>scheme-specific-part</em>[</strong>#<em>**fragment</em>]</p><p>其中，方括号 […] 用于描述可选组成部分，字符 <strong>:</strong>和 <strong>#</strong>代表它们自身。</p><p><em>绝对</em> URI 指定了方案(scheme)；非绝对的 URI 称为<em>相对</em>URI。URI 还可以根据其是否为<em>不透明的</em> 或<em>分层的</em> 进行分类。</p><p><em>不透明</em> URI 为绝对 URI，其特定于方案的部分不是以斜线字符 (‘/‘) 开始。不透明 URI 无法进行进一步解析。下面是不透明 URI 的一些示例：</p><table><thead><tr><th>mailto:<a href="mailto:java-net@java.sun.com" target="_blank" rel="noopener">java-net@java.sun.com</a></th><th></th></tr></thead><tbody><tr><td>news:comp.lang.java</td><td></td></tr><tr><td>urn:isbn:096139210x</td></tr></tbody></table><p><em>分层</em> URI 或者为绝对 URI（其特定于方案的部分以斜线字符开始），或者为相对 URI，即不指定方案的 URI。下面是分层 URI 的一些示例：</p><p><a href="http://java.sun.com/j2se/1.3/" target="_blank" rel="noopener">http://java.sun.com/j2se/1.3/</a><br>docs/guide/collections/designfaq.html#28<br><a href="http://www.cnblogs.com/../demo/jfc/SwingSet2/src/SwingSet2.java" target="_blank" rel="noopener">http://www.cnblogs.com/../demo/jfc/SwingSet2/src/SwingSet2.java</a><br>file:///~/calendar </p><p>分层 URI 还要按照下面的语法进行进一步的解析</p><p>[<em>scheme**</em>:<strong>][</strong>//<strong><em>authority</em>][<em>path</em>][</strong>?<strong><em>query</em>][</strong>#<em>**fragment</em>]</p><p>其中，<strong>:</strong>、<strong>/</strong>、<strong>?</strong>和 <strong>#</strong>代表它们自身。分层 URI 的特定于方案的部分包含方案和片段部分之间的字符。</p><p>分层 URI 的授权组成部分（如果指定）为<em>基于服务器的</em> 或<em>基于注册表的</em>。基于服务器的授权按照如下众所周知的语法进行解析：</p><p>[<em>user-info**</em>@<strong>]<em>host</em>[</strong>:<em>**port</em>]</p><p>其中，字符 <strong>@</strong>和 <strong>:</strong>代表它们自身。几乎当前使用的所有 URI 方案都是基于服务器的。不能采用这种方式解析的授权组成部分被视为基于注册表的。</p><p>如果分层 URI 的路径组成部分以斜线字符 (‘/‘) 开始，则称此 URI 本身为绝对的；否则它为相对的。分层 URI 或者为绝对的，或者指定了授权的路径，它始终为绝对的。</p><p>如上所述，URI 实例具有以下九个组成部分：</p><table><thead><tr><th><strong>组成部分</strong></th><th><strong>类型</strong></th></tr></thead><tbody><tr><td>方案</td><td>String</td></tr><tr><td>特定于方案的部分</td><td>String</td></tr><tr><td>授权</td><td>String</td></tr><tr><td>用户信息</td><td>String</td></tr><tr><td>主机</td><td>String</td></tr><tr><td>端口</td><td>int</td></tr><tr><td>路径</td><td>String</td></tr><tr><td>查询</td><td>String</td></tr><tr><td>片段</td><td>String</td></tr></tbody></table><p>在给定实例中，任何特殊组成部分都或者为<em>未定义的</em>，或者为<em>已定义的</em>，并且有不同的值。未定义的字符串组成部分由 null 表示，未定义的整数组成部分由 -1 表示。已定义的字符串组成部分的值可以为空字符串；这与未定义的组成部分不等效。</p><p>实例中特定的组成部分是已定义的还是未定义的取决于所代表的 URI 类型。绝对 URI 具有方案组成部分。不透明的 URI 具有一个方案、一个特定于方案的部分，以及可能会有一个片段，但是没有其他组成部分。分层 URI 总是有一个路径（尽管可能为空）和一个特定于方案的部分（它至少包含一个路径），还可以包含任何其他组成部分。如果有授权组成部分且它又是基于服务器的，则主机组成部分将被定义，也有可能定义用户信息和端口组成部分。</p><h3 id="URI分类"><a href="#URI分类" class="headerlink" title="URI分类"></a>URI分类</h3><h4 id="绝对URI和相对URI"><a href="#绝对URI和相对URI" class="headerlink" title="绝对URI和相对URI"></a>绝对URI和相对URI</h4><p><strong>绝对URI：</strong>以scheme组件起始的完整格式，如<a href="http://fsjohnhuang.cnblogs.com。表示以对标识出现的环境无依赖的方式引用资源。" target="_blank" rel="noopener">http://fsjohnhuang.cnblogs.com。表示以对标识出现的环境无依赖的方式引用资源。</a><br><strong>相对URI：</strong>不以scheme组件起始的非完整格式，如fsjohnhuang.cnblogs.com。表示以对依赖标识出现的环境有依赖的方式引用资源。 </p><h4 id="不透明URI和分层URI"><a href="#不透明URI和分层URI" class="headerlink" title="不透明URI和分层URI"></a>不透明URI和分层URI</h4><p><strong>不透明URI：</strong>scheme-specific-part组件不是以正斜杠(/)起始的，如mailto:<a href="mailto:fsjohnhuang@xxx.com" target="_blank" rel="noopener">fsjohnhuang@xxx.com</a>。由于不透明URI无需进行分解操作，因此不会对scheme-specific-part组件进行有效性验证。 </p><p><strong>分层URI：</strong>scheme-specific-part组件是以正斜杠(/)起始的，如<a href="http://fsjohnhuang.com。" target="_blank" rel="noopener">http://fsjohnhuang.com。</a></p><h3 id="针对-URI-实例的运算"><a href="#针对-URI-实例的运算" class="headerlink" title="针对 URI 实例的运算"></a>针对 URI 实例的运算</h3><p>此类支持的主要运算有<em>规范化</em>、<em>解析</em> 和<em>相对化</em> 运算。</p><p><em>规范化</em> 是将分层 URI 的路径组成部分中的不必要的”.” 和 “..” 部分移除的过程。每个 “.” 部分都将被移除。”..” 部分也被移除，除非它前面有一个非 “..” 部分。规范化对不透明 URI 不产生任何效果。 </p><p><em>解析</em> 是根据另一个<em>基本</em> URI 解析某个 URI 的过程。得到的 URI 由两个 URI 组成部分构造，构造方式由 RFC 2396 指定，从基本 URI 取出原始 URI 中未指定的组成部分。对于分层 URI，原始的路径根据基本路径进行解析，然后进行规范化。例如，解析以下 URI </p><p>docs/guide/collections/designfaq.html#28 (1) </p><p>根据基本 URI <a href="http://java.sun.com/j2se/1.3/" target="_blank" rel="noopener">http://java.sun.com/j2se/1.3/</a> 解析，结果为 URI </p><p><a href="http://java.sun.com/j2se/1.3/docs/guide/collections/designfaq.html#28" target="_blank" rel="noopener">http://java.sun.com/j2se/1.3/docs/guide/collections/designfaq.html#28</a></p><p>解析相对 URI </p><p><a href="http://www.cnblogs.com/../demo/jfc/SwingSet2/src/SwingSet2.java" target="_blank" rel="noopener">http://www.cnblogs.com/../demo/jfc/SwingSet2/src/SwingSet2.java</a> (2) </p><p>根据此结果应生成</p><p><a href="http://java.sun.com/j2se/1.3/demo/jfc/SwingSet2/src/SwingSet2.java" target="_blank" rel="noopener">http://java.sun.com/j2se/1.3/demo/jfc/SwingSet2/src/SwingSet2.java</a></p><p>支持对绝对和相对 URI，以及分层 URI 的绝对和相对路径的解析。根据任何其他 URI 对 URI file:///~calendar 进行解析只能生成原始的 URI，因为它是绝对路径。根据相对基础 URI (1) 解析相对 URI (2) 将生成规范的但依然是相对的 URI </p><p>demo/jfc/SwingSet2/src/SwingSet2.java </p><p>最后，<em>相对化</em> 是解析的逆过程：对于任何两个规范的 URI <em>u</em> 和 <em>v</em>， </p><p><em>u</em>.relativize(<em>u</em>.resolve(<em>v</em>)).equals(<em>v</em>)和<br><em>u</em>.resolve(<em>u</em>.relativize(<em>v</em>)).equals(<em>v</em>)。</p><p>此运算在下面的场合非常有用：构造一个包含 URI 的文档，该URI 必须尽可能是根据文档的基本 URI 建立的相对 URI。例如，相对化 URI </p><p><a href="http://java.sun.com/j2se/1.3/docs/guide/index.html" target="_blank" rel="noopener">http://java.sun.com/j2se/1.3/docs/guide/index.html</a> </p><p>根据基本 URI </p><p><a href="http://java.sun.com/j2se/1.3" target="_blank" rel="noopener">http://java.sun.com/j2se/1.3</a> </p><p>生成了相对 URI docs/guide/index.html。</p><h3 id="字符分类"><a href="#字符分类" class="headerlink" title="字符分类"></a>字符分类</h3><p>RFC 2396 精确指出 URI 引用中的各个不同组成部分允许使用的字符。以下分类大部分取自该规范，这些约束的用法描述如下：</p><table><thead><tr><th><strong>alpha</strong></th><th>US-ASCII 字母字符，’A’ 到 ‘Z’ 以及 ‘a’ 到 ‘z’</th></tr></thead><tbody><tr><td><strong>digit</strong></td><td>US-ASCII 十进制数字符，’0’ 到 ‘9’</td></tr><tr><td><strong>alphanum</strong></td><td>所有 <em>alpha</em>和 <em>digit</em>字符</td></tr><tr><td><strong>unreserved</strong></td><td>所有 <em>alphanum</em>字符及字符串 “_-!.~’()*” 中包含的字符</td></tr><tr><td><strong>punct</strong></td><td>字符串 “,;:$&amp;+=” 中包含的字符</td></tr><tr><td><strong>reserved</strong></td><td>所有 <em>punct</em>字符及字符串 “?/[]@” 中包含的字符</td></tr><tr><td><strong>escaped</strong></td><td>转义八位组，即三部分组合：百分号 (‘%’) 后跟两个十六进制数（’0’-‘9’、’A’-‘F’ 和 ‘a’-‘f’）</td></tr><tr><td><strong>other</strong></td><td>未包含在 US-ASCII 字符集中的 Unicode 字符不是控制字符（根据 <a href="http://www.cnblogs.com/springside5/admin/" target="_blank" rel="noopener">Character.isISOControl</a> 方法），并且不是空格字符（根据 <a href="http://www.cnblogs.com/springside5/admin/" target="_blank" rel="noopener">Character.isSpaceChar</a> 方法）<em>（**与 RFC 2396 有些出入**，RFC 2396 限制为 US-ASCII）</em></td></tr></tbody></table><p>全部合法 URI 字符集包含 <em>unreserved</em>、<em>reserved</em>、<em>escaped</em>和 <em>other</em>字符。</p><h3 id="转义八位组、引用、编码和解码"><a href="#转义八位组、引用、编码和解码" class="headerlink" title="转义八位组、引用、编码和解码"></a>转义八位组、引用、编码和解码</h3><p>RFC 2396 允许用户信息、路径、查询和片段组成部分中包含转义八位组。转义在 URI 中实现两个目的：</p><ul><li>当要求 URI 不能包含任何 <em>other</em> 字符以严格遵守 RFC 2396 时，需要对非 US-ASCII 字符进行<em>编码</em>。</li><li>要<em>引用</em> 组成部分中的非法字符。用户信息、路径、查询和片段组成部分在判断哪些字符合法哪些字符非法上稍有不同。</li></ul><p>在此类中由三个相关的运算实现了这两个目的：</p><ul><li>字符的<em>编码</em> 方式是，用代表该字符在 UTF-8 字符集中的字符的转义八位组序列取代该字符。例如，欧元符号 (‘\u20AC’) 编码后为 “%E2%82%AC”。<em>（**与 RFC 2396 有些出入**，RFC 2396 未指定任何特殊字符集）</em>。</li><li>非法字符通过简单地对它进行编码来<em>引用</em>。例如，空格字符，用 “%20” 取代它来进行引用。UTF-8 包含 US-ASCII，因此对于 US-ASCII 字符，此转换具有的效果与 RFC 2396 的要求相同。 </li><li>对转义八位组序列进行<em>解码</em> 的方法是，用它所代表的 UTF-8 字符集中的字符的序列将它取代。UTF-8 包含 US-ASCII，因此解码具有对引用的任何 US-ASCII 字符取消引用的效果，以及对任何编码的非 US-ASCII 字符进行解码的效果。如果在对转义八位组进行解码时出现<a href="http://www.cnblogs.com/springside5/admin/" target="_blank" rel="noopener">解码错误</a>，则出错的八位组用 Unicode 替换字符 ‘\uFFFD’ 取代。</li></ul><p>这些运算在此类的构造方法和方法中公开，如下所示：</p><ul><li><a href="http://www.cnblogs.com/springside5/admin/" target="_blank" rel="noopener">单参数构造方法</a>要求对参数中的任何非法字符都必须引用，并保留出现的任何转义八位组和 <em>other</em>字符。</li><li><a href="http://www.cnblogs.com/springside5/admin/" target="_blank" rel="noopener">多参数构造方法</a>根据其中出现的组成部分的需要对非法字符进行引用。百分号字符 (‘%’) 始终通过这些构造方法引用。任何 <em>other</em>字符都将被保留。</li><li><a href="http://www.cnblogs.com/springside5/admin/" target="_blank" rel="noopener">getRawUserInfo</a>、<a href="http://www.cnblogs.com/springside5/admin/" target="_blank" rel="noopener">getRawPath</a>、<a href="http://www.cnblogs.com/springside5/admin/" target="_blank" rel="noopener">getRawQuery</a>、<a href="http://www.cnblogs.com/springside5/admin/" target="_blank" rel="noopener">getRawFragment</a>、<a href="http://www.cnblogs.com/springside5/admin/" target="_blank" rel="noopener">getRawAuthority</a> 和 <a href="http://www.cnblogs.com/springside5/admin/" target="_blank" rel="noopener">getRawSchemeSpecificPart</a> 方法以原始形式返回它们的相应组成部分的值，不解释任何转义八位组。由这些方法返回的字符串有可能包含转义八位组和 <em>other</em>字符，但不包含任何非法字符。</li><li><a href="http://www.cnblogs.com/springside5/admin/" target="_blank" rel="noopener">getUserInfo</a>、<a href="http://www.cnblogs.com/springside5/admin/" target="_blank" rel="noopener">getPath</a>、<a href="http://www.cnblogs.com/springside5/admin/" target="_blank" rel="noopener">getQuery</a>、<a href="http://www.cnblogs.com/springside5/admin/" target="_blank" rel="noopener">getFragment</a>、<a href="http://www.cnblogs.com/springside5/admin/" target="_blank" rel="noopener">getAuthority</a> 和 <a href="http://www.cnblogs.com/springside5/admin/" target="_blank" rel="noopener">getSchemeSpecificPart</a> 方法解码相应的组成部分中的任何转义八位组。由这些方法返回的字符串有可能包含 <em>other</em>字符和非法字符，但不包含任何转义八位组。</li><li><a href="http://www.cnblogs.com/springside5/admin/" target="_blank" rel="noopener">toString</a> 返回带所有必要引用的 URI 字符串，但它可能包含 <em>other</em> 字符。</li><li><a href="http://www.cnblogs.com/springside5/admin/" target="_blank" rel="noopener">toASCIIString</a> 方法返回不包含任何 <em>other</em>字符的、完全引用的和经过编码的 URI 字符串。 </li></ul><h3 id="标识"><a href="#标识" class="headerlink" title="标识"></a>标识</h3><p>对于任何 URI <em>u</em>，下面的标识有效</p><p>new URI(<em>u</em>.toString()).equals(<em>u</em>) . </p><p>对于不包含冗余语法的任何 URI <em>u</em>，比如在一个空授权前面有两根斜线（如 file:///tmp/）和主机名后面跟一个冒号但没有端口（如<a href="http://java.sun.com:），以及除必须引用的字符之外不对字符编码的情况，下面的标识也有效：" target="_blank" rel="noopener">http://java.sun.com:），以及除必须引用的字符之外不对字符编码的情况，下面的标识也有效：</a></p><p>new URI(<em>u</em>.getScheme()、<br><em>u</em>.getSchemeSpecificPart()、<br><em>u</em>.getFragment())<br>.equals(<em>u</em>) </p><p>在所有情况下，以下标识有效</p><p>new URI(<em>u</em>.getScheme()、<br><em>u</em>.getUserInfo()、 <em>u</em>.getAuthority()、<br><em>u</em>.getPath()、 <em>u</em>.getQuery()、<br><em>u</em>.getFragment())<br>.equals(<em>u</em>) </p><p>如果 <em>u</em>为分层的，则以下标识有效</p><p>new URI(<em>u</em>.getScheme()、<br><em>u</em>.getUserInfo()、 <em>u</em>.getHost()、 <em>u</em>.getPort()、<br><em>u</em>.getPath()、 <em>u</em>.getQuery()、<br><em>u</em>.getFragment())<br>.equals(<em>u</em>) </p><p>如果 <em>u</em>为分层的并且没有授权或没有基于服务器的授权。</p><h3 id="URI、URL和-URN"><a href="#URI、URL和-URN" class="headerlink" title="URI、URL和 URN"></a>URI、URL和 URN</h3><p>URI 是统一资源<em>标识符</em>，而 URL 是统一资源<em>定位符</em>。因此，笼统地说，每个 URL 都是 URI，但不一定每个 URI 都是URL。这是因为 URI 还包括一个子类，即统一资源<em>名称</em> (URN)，它命名资源但不指定如何定位资源。上面的 mailto、news 和 isbn URI 都是URN 的示例。</p><p>URI 和 URL 概念上的不同反映在此类和 <a href="http://www.cnblogs.com/springside5/admin/" target="_blank" rel="noopener">URL</a> 类的不同中。</p><p>此类的实例代表由 RFC 2396 定义的语法意义上的一个 URI 引用。URI 可以是绝对的，也可以是相对的。对 URI 字符串按照一般语法进行解析，不考虑它所指定的方案（如果有）不对主机（如果有）执行查找，也不构造依赖于方案的流处理程序。相等性、哈希计算以及比较都严格地根据实例的字符内容进行定义。换句话说，一个 URI 实例和一个支持语法意义上的、依赖于方案的比较、规范化、解析和相对化计算的结构化字符串差不多。</p><p>作为对照，<a href="http://www.cnblogs.com/springside5/admin/" target="_blank" rel="noopener">URL</a> 类的实例代表了 URL 的语法组成部分以及访问它描述的资源所需的信息。URL 必须是绝对的，即它必须始终指定一个方案。URL 字符串按照其方案进行解析。通常会为 URL 建立一个流处理程序，实际上无法为未提供处理程序的方案创建一个 URL 实例。相等性和哈希计算依赖于方案和主机的 Internet 地址（如果有）；没有定义比较。换句话说，URL 是一个结构化字符串，它支持解析的语法运算以及查找主机和打开到指定资源的连接之类的网络 I/O 操作。</p><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><ul><li><p><strong>public URI(String str) throws URISynataxException</strong>             //通过给定的字符串构造一个URI</p><p>如果给定字符串违背 RFC 2396，抛出异常。</p></li><li><p><strong>public URI(String scheme, String ssp, String fragment) throws URISynataxException</strong>    //根据给定的组成部分构造一个URI</p><p>如果给定字符串违背 RFC 2396，抛出异常。</p></li><li><p><strong>public URI(String scheme, String userInfo, String host, int port, String path, String query, String fragment) throws URISynataxException</strong>    //通过给定组成部分构造一个分层URI</p><p>如果方案和路径都已给出但路径为相对的，如果从给定组成部分构造的 URI 字符串违背 RFC 2396，或者如果字符串的授权组成部分存在但无法解析为基于服务器的授权，抛出异常</p></li><li><p><strong>public URI(String scheme, String host, String path, String fragment) throws URISynataxException</strong>    //给据给定组成部分构造一个分层URI</p><p>如果给定字符串违背 RFC 2396，抛出异常。</p></li><li><p><strong>public URI(String scheme, String authority, String path, String query, String fragment) throws URISynataxException</strong>    //根据给定组成部分构造一个分层URI</p><p>如果方案和路径都已给出但路径为相对的，如果从给定组成部分构造的 URI 字符串违背 RFC 2396，或者如果字符串的授权组成部分存在但无法解析为基于服务器的授权，抛出异常</p></li></ul><h3 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h3><ul><li><p>public int compareTo(URI uri)             //将此URI和uri进行比较</p></li><li><p><strong>public static URI create(String str)</strong>     //通过给定的字符串构建一个URI</p></li><li><p>public String getAutority()</p></li><li><p>public Sring getFragment()</p></li><li><p>public String getHost()</p></li><li><p>public String getPath()</p></li><li><p>public String getPort()</p></li><li><p>public String getQuery()</p></li><li><p>public String getUserInfo()</p></li><li><p>public String getScheme()</p><p>返回此URI的组成部分</p></li><li><p>public boolean isAbsolute()           //此URI是否为绝对的</p></li><li><p>public boolean isOpaque()            //此URI是否为<strong>不透明的</strong></p></li><li><p>public URI normalize()                    //规范化此URI的路径</p></li><li><p>public URI relativize(URI uri)          //根据此URI将给定URI规范化</p></li><li><p>public URI resolve(String str)          //解析给定的字符串，然后在此URI的基础上构造一个新的URI</p></li><li><p>public URI resolve(URI uri)              //根据此URL解析给定的uri</p></li><li><p>public String toASCIIString()            //以US-ASCII字符串形式返回此URI的内容</p></li><li><p>public URL toURL()                           //根据此URI构造一个URL，如果该URI不是绝对的</p></li></ul><h3 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h3><ol><li>输出URI的组成部分信息</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">URITest1</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(string[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(args.length != <span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"Usage: java URITest1 uri"</span>);</span><br><span class="line">            System.exit(-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        URI uri = <span class="keyword">new</span> URI(args[<span class="number">0</span>]);</span><br><span class="line">        System.out.println (<span class="string">"Authority = "</span> +uri.getAuthority ());</span><br><span class="line">        System.out.println (<span class="string">"Fragment = "</span> +uri.getFragment ());</span><br><span class="line">        System.out.println (<span class="string">"Host = "</span> +uri.getHost ());</span><br><span class="line">        System.out.println (<span class="string">"Path = "</span> +uri.getPath ());</span><br><span class="line">        System.out.println (<span class="string">"Port = "</span> +uri.getPort ());</span><br><span class="line">        System.out.println (<span class="string">"Query = "</span> +uri.getQuery ());</span><br><span class="line">        System.out.println (<span class="string">"Scheme = "</span> +uri.getScheme ());</span><br><span class="line">        System.out.println (<span class="string">"Scheme-specific part = "</span> + uri.getSchemeSpecificPart ());</span><br><span class="line">        System.out.println (<span class="string">"User Info = "</span> +uri.getUserInfo ());</span><br><span class="line">        System.out.println (<span class="string">"URI is absolute: "</span> +uri.isAbsolute ());</span><br><span class="line">        System.out.println (<span class="string">"URI is opaque: "</span> +uri.isOpaque ());</span><br><span class="line">        System.out.println (<span class="string">"Normalized URI = "</span> + uri.normalize());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">root@dcLunatic:~/Desktop/JavaTest/net# java URITest1 http://www.baidu.com/index.php#banner</span><br><span class="line">Authority = www.baidu.com</span><br><span class="line">Fragment = banner</span><br><span class="line">Host = www.baidu.com</span><br><span class="line">Path = /index.php</span><br><span class="line">Port = -1</span><br><span class="line">Query = null</span><br><span class="line">Scheme = http</span><br><span class="line">Scheme-specific part = //www.baidu.com/index.php</span><br><span class="line">User Info = null</span><br><span class="line">URI is absolute: true</span><br><span class="line">URI is opaque: false</span><br><span class="line">Normalized URI = http://www.baidu.com/index.php#banner</span><br></pre></td></tr></table></figure><ol start="2"><li>规范化解析</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">URITest2</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(string[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(args.length != <span class="number">2</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"Usage: java URITest2 uriBase uriRelative"</span>);</span><br><span class="line">            System.exit(-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        URI uriBase = <span class="keyword">new</span> URI (args [<span class="number">0</span>]);</span><br><span class="line">        System.out.println (<span class="string">"Base URI = "</span> +uriBase);</span><br><span class="line"></span><br><span class="line">        URI uriRelative = <span class="keyword">new</span> URI (args [<span class="number">1</span>]);</span><br><span class="line">        System.out.println (<span class="string">"Relative URI = "</span> +uriRelative);</span><br><span class="line"></span><br><span class="line">        URI uriResolved = uriBase.resolve (uriRelative);</span><br><span class="line">        System.out.println (<span class="string">"Resolved URI = "</span> +uriResolved);</span><br><span class="line"></span><br><span class="line">        URI uriRelativized = uriBase.relativize (uriResolved);</span><br><span class="line">        System.out.println (<span class="string">"Relativized URI = "</span> +uriRelativized);         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@dcLunatic:~/Desktop/JavaTest/net# java URITest2 http://www.baidu.com/index.php index.php/../login.php</span><br><span class="line">Base URI = http://www.baidu.com/index.php</span><br><span class="line">Relative URI = index.php/../login.php</span><br><span class="line">Resolved URI = http://www.baidu.com/login.php</span><br><span class="line">Relativized URI = http://www.baidu.com/login.php</span><br></pre></td></tr></table></figure><h2 id="URLDecoder"><a href="#URLDecoder" class="headerlink" title="URLDecoder"></a>URLDecoder</h2><h3 id="简述-1"><a href="#简述-1" class="headerlink" title="简述"></a>简述</h3><p>HTML 格式解码的实用工具类。该类包含了将 String 从 <code>application/x-www-form-urlencoded</code> MIME 格式解码的静态方法。 </p><p>该转换过程正好与 URLEncoder 类使用的过程相反。假定已编码的字符串中的所有字符为下列之一：”a” 到 “z”、”A” 到 “Z”、”0” 到 “9” 和 “-“、”_”、”.” 以及 “*”。允许有 “%” 字符，但是将它解释为特殊转义序列的开始。 </p><p> 转换中使用以下规则：</p><pre><code>字母数字字符 &quot;a&quot; 到 &quot;z&quot;、&quot;A&quot; 到 &quot;Z&quot; 和 &quot;0&quot; 到 &quot;9&quot; 保持不变。特殊字符 &quot;.&quot;、&quot;-&quot;、&quot;*&quot; 和 &quot;_&quot; 保持不变。加号 &quot;+&quot; 转换为空格字符 &quot; &quot;。将把 &quot;%xy&quot; 格式序列视为一个字节，其中 xy 为 8 位的两位十六进制表示形式。然后，所有连续包含一个或多个这些字节序列的子字符串，将被其编码可生成这些连续字节的字符所代替。可以指定对这些字符进行解码的编码机制，或者如果未指定的话，则使用平台的默认编码机制。</code></pre><p>该解码器处理非法字符串有两种可能的方法。一种方法是不管该非法字符，另一种方法是抛出 IllegalArgumentException 异常。解码器具体采用哪种方法取决于实现。 </p><h3 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h3><ul><li>public URLDecoder()                           //创建一个URLDecoder</li></ul><h3 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h3><ul><li><p>public static String decode(String s)             //已过时，将字符串s解码，但是结果会因为平台的默认编码不同而产生不同的结果</p></li><li><p>public static String decode(String s, String enc) throws UnsupportedEncodingException     //使用指定的编码机制对<code>application/x-www-form-urlencoded</code> 字符串进行解码。一般都是使用UTF-8，如果使用其他编码，可能会造成不兼容性。</p><p>当指定的字符编码不被支持时，抛出异常。</p></li></ul><h2 id="URLEncoder"><a href="#URLEncoder" class="headerlink" title="URLEncoder"></a>URLEncoder</h2><h3 id="简述-2"><a href="#简述-2" class="headerlink" title="简述"></a>简述</h3><p>该类作用与URLDecoder相反。不解释</p><h3 id="构造方法-2"><a href="#构造方法-2" class="headerlink" title="构造方法"></a>构造方法</h3><ul><li>public URLEncoder()                       //创建一个URLEncoder</li></ul><h3 id="方法-2"><a href="#方法-2" class="headerlink" title="方法"></a>方法</h3><ul><li>public static String encode(String s)          //已过时，将字符串s编码，但是结果会因为平台的默认编码不同而产生不同的结果</li><li>public static String encode(String s, String enc) throws UnsupportedEncodingException    //使用指定的编码机制将字符串编码成<code>application/x-www-form-urlencoded</code> 格式。一般应使用 UTF-8。如果不使用该编码，可能造成不兼容性。</li></ul><h2 id="URLConnection"><a href="#URLConnection" class="headerlink" title="URLConnection"></a>URLConnection</h2><h3 id="简述-3"><a href="#简述-3" class="headerlink" title="简述"></a>简述</h3><p>首先，这是一个抽象类，是所有URL连接类的超类，它代表应用程序和URL之间的通信连接。此类实例可用于读取和写入此URL引用的资源。</p><p>通常，创建一个到URL的连接需要以下的步骤：</p><ol><li>通过在URL上调用openConnnection方法创建连接对象</li><li>处理设置参数和一般请求属性</li><li>使用connect方法建立到远程对象的连接</li><li>远程对象变为可用。远程对象的头字段和内容变为可访问。</li></ol><p>一般情况下，所有的预连接参数和一般请求属性都可忽略，这些一般都默认为敏感值，比较常用的两个方法getInputStream和getContent。</p><h3 id="字段"><a href="#字段" class="headerlink" title="字段"></a>字段</h3><ul><li>protected boolean allowUserInteraction                     //如果为 true，则在允许用户交互（例如弹出一个验证对话框）的上下文中对此 URL 进行检查。</li><li>protected boolean connnected                                    //如果为 false，则此连接对象尚未创建到指定 URL 的通信链接。</li><li>protected boolean doInput                                           //此变量由setDoInput方法设置</li><li>protected boolean doOutput                                        //此变量由setDoOutput方法设置</li><li>protected long ifModifiedSince                                    //有些协议支持跳过对象获取，除非该对象在某个特定时间点之后又进行了修改。</li><li>protected URL url                                                           //URL 表示此连接要在互联网上打开的远程对象。</li><li>protected boolean useCaches                                     //如果为true，则只要有条件就允许协议使用缓存。</li></ul><h3 id="构造方法-3"><a href="#构造方法-3" class="headerlink" title="构造方法"></a>构造方法</h3><ul><li><strong>protected</strong> URLConnnection(URL url)                   //创建一个到指定URL的URL连接</li></ul><h3 id="常用方法-2"><a href="#常用方法-2" class="headerlink" title="常用方法"></a>常用方法</h3><ol><li><strong>与字段相关的方法</strong></li></ol><ul><li><p>public static boolean getDefaultAllowUserInteraction()                 //返回URLConnection对象默认的allowUserInteraction字段的值</p></li><li><p>public static void setDefaultAllowUserInteraction(boolean defaultallowuserinteraction)</p><pre><code>//将未来的所有 URLConnection 对象的 allowUserInteraction 字段的默认值设置为指定的值</code></pre></li><li><p>public boolean getAllowUserInteraction()                                       //返回此对象的allowUserInteraction字段的值</p></li><li><p>public void setAllowUserInteraction(boolean allowuserinteraction)</p><p>   ​                                                                                                                //设置此 URLConnection 的 allowUserInteraction 字段的值</p></li><li><p>public boolean getDefaultUseCaches()                                           //返回此对象默认的useCaches字段的值</p></li><li><p>public void setDefaultUseCaches(boolean defaultusecaches)//将 useCaches 字段的默认值设置为指定的值</p></li><li><p>public boolean getUseCaches()                                                        //返回此对象的useCaches字段的值</p></li><li><p>public void setUseCaches(boolean usecaches)                             //将此 URLConnection 的 useCaches 字段的值设置为指定的值</p></li><li><p>public boolean getDoInput()                                                            //返回此对象的doInput字段的值</p></li><li><p>public void setDoInput(boolean doinput)                                     //将此 URLConnection 的 doInput 字段的值设置为指定的值</p></li><li><p>public boolean getDoOutput()                                                        //返回此对象的doOutput字段的值</p></li><li><p>public void setDoOutput(boolean dooutput)                              //将此 URLConnection 的 doOutput 字段的值设置为指定的值</p></li><li><p>public long getIfModifiedSince()                                                    //返回此对象的ifModifiedSince字段的值</p></li><li><p>public void setIfModifiedSince(long ifmodifiedsince)                //将此对象的 ifModifiedSince 字段的值设置为指定的值</p></li><li><p>public URL getURL()                                                                        //返回此对象的url字段的值</p></li></ul><ol start="2"><li><strong>与响应头字段相关的方法</strong></li></ol><ul><li>public String getContentEncoding()                                                  //返回content-encoding头字段的值</li><li>public int getContentLength()                                                            //返回content-length头字段的值</li><li>public String getContentType()                                                         //返回content-type头字段的值</li><li>public long getExpiration()                                                                //返回expires头字段的值</li><li>public long getDate()                                                                           //返回date头字段的值</li><li>public String getHeaderField(int n)                                                  //返回第n个头字段的值</li><li>public String getHeaderField(String name)                                    //返回指定的头字段的值</li><li>public String getHeaderFieldKey(String key)                                  //返回第n个头字段的键</li><li>public Map&lt;String, List<string>&gt; getHeaderFields()                     //返回头字段的map(不可修改)</string></li><li>public long getLastModified()                                                           //返回last-modified头字段的值</li></ul><ol start="3"><li><strong>与请求属性相关的方法</strong></li></ol><ul><li>public void addRequestProperty(String key, String value)             //添加由键值对指定的一般请求属性</li><li>public String getRequestProperty(String key)                                 //返回此连接指定的一般请求属性值</li><li>public void setRequestProperty(String key, String value)            //设置一般请求属性</li><li>public Map&lt;String, List<string>&gt; getRequestProperties()           //返回此连接的一般请求属性的map(不可修改)</string></li></ul><ol start="4"><li><strong>与连接设置有关的方法</strong></li></ol><ul><li>public abstract void connect()                                                            //打开到此URL引用的资源的通信链接，如果尚未连接的话</li><li>public int getConnectTimerout()                                                       //返回此连接超时设置</li><li>public void setConnectTimeout(int timeout)                                  //将一个指定的超时值（以毫秒为单位），该值将在打开到此 URLConnection 引用的资源的通信链接时使用</li><li>public int getReadTimeout()                                                              //返回读入超时设置</li><li>public void setReadTimeout(int timeout)                                       //将读超时设置为指定的超时值，以毫秒为单位</li></ul><ol start="5"><li><strong>在连接后读写内容相关的方法</strong></li></ol><ul><li>public Object getContent()                                                                 //获取此URL连接的内容</li><li>public Object getContent(Class[] classes)                                        //获取此URL连接的内容</li><li>public InputStream getInputStream()                                             //返回从此打开的连接读取的输入流</li><li>public OutputStream getOutputStream()                                       //返回到此连接的输出流</li></ul><ol start="6"><li><strong>其他方法</strong></li></ol><ul><li>public static String guessContentTypeFromName(String fname)//根据url的指定的file部分尝试确定对象的内容类型</li><li>public static String guessContentTypeFromStream(InputStream is)//根据输入流的开始字符尝试确定输入流的类型</li><li>public String toString()                                                                     //返回此 URL 连接的 String 表示形式</li></ul><h3 id="例子-2"><a href="#例子-2" class="headerlink" title="例子"></a>例子</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;网络编程&quot;&gt;&lt;a href=&quot;#网络编程&quot; class=&quot;headerlink&quot; title=&quot;网络编程&quot;&gt;&lt;/a&gt;网络编程&lt;/h1&gt;&lt;h2 id=&quot;InetAddress&quot;&gt;&lt;a href=&quot;#InetAddress&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
    
      <category term="Java" scheme="http://dcLunatic.github.io/tags/Java/"/>
    
      <category term="网络编程" scheme="http://dcLunatic.github.io/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java序列化</title>
    <link href="http://dcLunatic.github.io/2018/09/21/Java%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <id>http://dcLunatic.github.io/2018/09/21/Java序列化/</id>
    <published>2018-09-21T05:49:31.000Z</published>
    <updated>2018-09-21T05:50:23.195Z</updated>
    
    <content type="html"><![CDATA[<h1 id="序列化和反序列化"><a href="#序列化和反序列化" class="headerlink" title="序列化和反序列化"></a>序列化和反序列化</h1><p>[TOC]</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>把对象转换为字节序列的过程称为对象的序列化。<br>把字节序列恢复为对象的过程称为对象的反序列化</p><h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><p>对象的序列化主要有两种用途：<br>1） 把对象的字节序列永久地保存到硬盘上，通常存放在一个文件中；<br>2） 在网络上传送对象的字节序列。</p><h2 id="Java中使用方法"><a href="#Java中使用方法" class="headerlink" title="Java中使用方法"></a>Java中使用方法</h2><p><code>java.io.ObjectOutputStream</code>代表对象输出流，它的<code>writeObject(Object obj)</code>方法可以对参数指定的obj对象进行序列化，把得到的字节序列写到一个目标输出流中。</p><p><code>java.io.ObjectInputStream</code>代表对象输入流，它的<code>readObject()</code>方法从一个源输入流中读取字节序列，再把它们反序列化为一个对象，并将其返回。</p><p>只有实现了<code>Serializable</code>接口可以被序列化，但序列化只能采用默认的序列化。而实现了<code>Externalizable</code>接口的类也可以实现序列化，因为它继承自<code>Serializable</code>接口，且可以完全由自身来控制序列化的行为。</p><p><strong>一个简单的例子</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Hello world"</span>);</span><br><span class="line">        SerializeDemo();</span><br><span class="line">        DeserializeDemo();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SerializeDemo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Test test = <span class="keyword">new</span> Test(<span class="string">"John"</span>, <span class="number">15</span>);</span><br><span class="line">            ObjectOutputStream oo = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(<span class="string">"/root/Desktop/test.txt"</span>)));</span><br><span class="line">            oo.writeObject(test);</span><br><span class="line">            System.out.println(<span class="string">"序列化结束"</span>);</span><br><span class="line">            oo.close();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(FileNotFoundException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"无法读写文件"</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"IO异常"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DeserializeDemo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            ObjectInputStream oi = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(<span class="string">"/root/Desktop/test.txt"</span>)));</span><br><span class="line">            Test test = (Test)oi.readObject();</span><br><span class="line">            System.out.println(<span class="string">"反序列化成功"</span>);</span><br><span class="line">            System.out.println(test.toString());</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String sex;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">(String name, <span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Test&#123;"</span> +</span><br><span class="line">                <span class="string">"age="</span> + age +</span><br><span class="line">                <span class="string">", name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="serialVersionUID的作用"><a href="#serialVersionUID的作用" class="headerlink" title="serialVersionUID的作用"></a>serialVersionUID的作用</h2><p>serialVersionUID字面意思是序列化的版本号，凡是实现了Serializable接口的类都有一个表示序列化版本标识符的静态变量。</p><blockquote><p>如果没有serialVersionUID，也是可以编译通过的，对正常的序列化反序列化是没有影响的，至于有影响的情况，看下面解释。</p></blockquote><p><strong>serialVersionUID有两种生成方式</strong></p><ul><li>采用默认的serivalVersionUID也就是默认的1L，<code>private static final long serialVersionUID = 1L;</code></li><li>通过类名、接口名、方法和属性等来生成，如<code>private static final long serialVersionUID = 4603642343377807741L;</code></li></ul><p><strong>serialVersionUID的作用</strong></p><p><strong>问题</strong>：假如有这么一个类，序列化程二进制数据保存在磁盘中，但是该类的结构发生了变化，如添加了一个属性，此时可以再将磁盘中的二进制数据反序列成这个类吗？</p><p><strong>答</strong>：</p><p>先去除<code>servialVersionUID</code>属性，然后序列化保存<br>在<code>Test</code>类中添加属性<code>sex</code>，然后直接反序列化<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.dcLunatic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Hello world"</span>);</span><br><span class="line">        <span class="comment">//SerializeDemo();</span></span><br><span class="line">        DeserializeDemo();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SerializeDemo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Test test = <span class="keyword">new</span> Test(<span class="string">"John"</span>, <span class="number">15</span>);</span><br><span class="line">            ObjectOutputStream oo = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(<span class="string">"/root/Desktop/test.txt"</span>)));</span><br><span class="line">            oo.writeObject(test);</span><br><span class="line">            System.out.println(<span class="string">"序列化结束"</span>);</span><br><span class="line">            oo.close();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(FileNotFoundException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"无法读写文件"</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"IO异常"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DeserializeDemo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            ObjectInputStream oi = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(<span class="string">"/root/Desktop/test.txt"</span>)));</span><br><span class="line">            Test test = (Test)oi.readObject();</span><br><span class="line">            System.out.println(<span class="string">"反序列化成功"</span>);</span><br><span class="line">            System.out.println(test.toString());</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">    <span class="comment">//private static final long serialVersionUID = 1L;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String sex;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">(String name, <span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Test&#123;"</span> +</span><br><span class="line">                <span class="string">"age="</span> + age +</span><br><span class="line">                <span class="string">", name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>此时，运行后程序就会抛出异常</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Hello world</span><br><span class="line">java.io.InvalidClassException: com.dcLunatic.Test; local class incompatible: stream classdesc serialVersionUID = -3765794941312665207, local class serialVersionUID = -2796904131256425943</span><br><span class="line">at java.io.ObjectStreamClass.initNonProxy(ObjectStreamClass.java:687)</span><br><span class="line">at java.io.ObjectInputStream.readNonProxyDesc(ObjectInputStream.java:1883)</span><br><span class="line">at java.io.ObjectInputStream.readClassDesc(ObjectInputStream.java:1749)</span><br><span class="line">at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:2040)</span><br><span class="line">at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1571)</span><br><span class="line">at java.io.ObjectInputStream.readObject(ObjectInputStream.java:431)</span><br><span class="line">at com.dcLunatic.Main.DeserializeDemo(Main.java:30)</span><br><span class="line">at com.dcLunatic.Main.main(Main.java:11)</span><br></pre></td></tr></table></figure><p>因为在<code>Test</code>类中缺少了serialVersionUID，而在编译时，该值会由编译器自动生成，因为前后两次的serialVersionUID不一致，所以导致反序列化失败（序列化版本不一致），此时，如果显式的指定serialVersionUID的值，就不会出现这个问题，反序列化时对后来新增的属性sex就不会有任何赋值修改。</p><p>就算类不会发生改动，但在不同的编译器中，自动生成的serialVersionUID的值可能也会存在差异的。</p><blockquote><p>serialVersionUID的作用还是很大的，比如在那个face</p></blockquote><h2 id="transient关键字"><a href="#transient关键字" class="headerlink" title="transient关键字"></a>transient关键字</h2><p>在序列化的过程中，如果有一个特定的属性字段比较敏感，不想被序列化，可以考虑使用transient关键字关闭序列化处理。</p><blockquote><p>这里有一个更加常用的方法，父类不实现Serializable接口，但是子类实现，将不想要序列化的放在父类中，子类中放想要序列化的内容即可。</p><ol><li>如果子类实现Serializable接口而父类未实现时，父类不会被序列化。</li><li>如果父类实现序列化，子类自动实现序列化，不需要显式实现Serializable接口。<br><strong>原因</strong>：跟子类父类的内存分配有关，点<a href="http://blog.csdn.net/smithdoudou88/article/details/12756187" target="_blank" rel="noopener">这里</a>或者是<a href="http://blog.csdn.net/u011386422/article/details/42582605" target="_blank" rel="noopener">这里</a>阅读相关博文。</li></ol></blockquote><h2 id="自定义writeObject方法和readObject方法"><a href="#自定义writeObject方法和readObject方法" class="headerlink" title="自定义writeObject方法和readObject方法"></a>自定义writeObject方法和readObject方法</h2><p>实现Serializable接口的类序列化的话，是使用默认的序列化方式。但我们可以使用<code>writeObject</code>和<code>readObject</code>方法来实现对序列化的更多控制。</p><p>在序列化过程中，虚拟机会试图调用对象类里的writeObject 和 readObject 方法，进行用户自定义的序列化和反序列化，如果没有这样的方法，则默认调用是 ObjectOutputStream 的 <code>defaultWriteObject</code> 方法以及调用ObjectInputStream 的 <code>defaultReadObject</code>方法。用户自定义的 writeObject 和 readObject 方法可以允许用户控制序列化的过程，比如可以在序列化的过程中动态改变序列化的数值。基于这个原理，可以在实际应用中得到使用，用于敏感字段的加密工作等等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">    <span class="keyword">private</span> String password = <span class="string">"pass"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> password;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPassword</span><span class="params">(String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(ObjectOutputStream out)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            PutField putFields = out.putFields();</span><br><span class="line">            System.out.println(<span class="string">"原密码:"</span> + password);</span><br><span class="line">            password = <span class="string">"encryption"</span>;<span class="comment">//模拟加密</span></span><br><span class="line">            putFields.put(<span class="string">"password"</span>, password);</span><br><span class="line">            System.out.println(<span class="string">"加密后的密码"</span> + password);</span><br><span class="line">            out.writeFields();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(ObjectInputStream in)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            GetField readFields = in.readFields();</span><br><span class="line">            Object object = readFields.get(<span class="string">"password"</span>, <span class="string">""</span>);</span><br><span class="line">            System.out.println(<span class="string">"要解密的字符串:"</span> + object.toString());</span><br><span class="line">            password = <span class="string">"pass"</span>;<span class="comment">//模拟解密,需要获得本地的密钥</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(</span><br><span class="line">                    <span class="keyword">new</span> FileOutputStream(<span class="string">"result.obj"</span>));</span><br><span class="line">            out.writeObject(<span class="keyword">new</span> Test());</span><br><span class="line">            out.close();</span><br><span class="line"></span><br><span class="line">            ObjectInputStream oin = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(</span><br><span class="line">                    <span class="string">"result.obj"</span>));</span><br><span class="line">            Test t = (Test) oin.readObject();</span><br><span class="line">            System.out.println(<span class="string">"解密后的字符串:"</span> + t.getPassword());</span><br><span class="line">            oin.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>defaultWriteObject方法和defaultReadObject方法不会检查serialVersionUID的值是否一致</p></blockquote><h2 id="Externalizable"><a href="#Externalizable" class="headerlink" title="Externalizable"></a>Externalizable</h2><p>Java默认的序列化机制非常简单，而且序列化后的对象不需要再次调用构造器重新生成，但是在实际中，我们可以会希望对象的某一部分不需要被序列化，或者说一个对象被还原之后，其内部的某些子对象需要重新创建，从而不必将该子对象序列化。在这些情况下，我们可以考虑实现Externalizable接口从而代替Serializable接口来对序列化过程进行控制。</p><p>Externalizable接口extends Serializable接口，而且在其基础上增加了两个方法：writeExternal()和readExternal()。这两个方法会在序列化和反序列化还原的过程中被自动调用，以便执行一些特殊的操作。</p><p>一个例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.dcLunatic;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExternDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello world"</span>);</span><br><span class="line">        SerializeDemo();</span><br><span class="line">        DeserializeDemo();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SerializeDemo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Test1 test = <span class="keyword">new</span> Test1(<span class="string">"John"</span>, <span class="number">15</span>);</span><br><span class="line">            ObjectOutputStream oo = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(<span class="string">"/root/Desktop/test.txt"</span>)));</span><br><span class="line">            test.writeExternal(oo);</span><br><span class="line">            System.out.println(<span class="string">"序列化结束"</span>);</span><br><span class="line">            oo.close();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(FileNotFoundException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"无法读写文件"</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"IO异常"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DeserializeDemo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            ObjectInputStream oi = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(<span class="string">"/root/Desktop/test.txt"</span>)));</span><br><span class="line">            Test1 test = <span class="keyword">new</span> Test1();</span><br><span class="line">            test.readExternal(oi);</span><br><span class="line">            System.out.println(<span class="string">"反序列化成功"</span>);</span><br><span class="line">            System.out.println(test.toString());</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test1</span> <span class="keyword">implements</span> <span class="title">Externalizable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test1</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test1</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Test1&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeExternal</span><span class="params">(ObjectOutput objectOutput)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"调用writeExternal方法"</span>);</span><br><span class="line">        objectOutput.writeObject(name);</span><br><span class="line">        objectOutput.writeInt(age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readExternal</span><span class="params">(ObjectInput objectInput)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"调用readExternal方法"</span>);</span><br><span class="line">        name = (String)objectInput.readObject();</span><br><span class="line">        age = objectInput.readInt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul><li>序列化时，只对对象的状态进行保存，而不管对象的方法；</li><li>记住，状态状态状态！</li><li>当一个父类实现序列化，子类自动实现序列化，不需要显式实现Serializable接口；</li><li>当一个对象的实例变量引用其他对象，序列化该对象时也把引用对象进行序列化；</li><li>并非所有的对象都可以序列化，,至于为什么不可以，有很多原因了,比如：<ul><li>安全方面的原因，比如一个对象拥有private，public等field，对于一个要传输的对象，比如写到文件，或者进行rmi传输  等等，在序列化进行传输的过程中，这个对象的private等域是不受保护的。</li><li>资源分配方面的原因，比如socket，thread类，如果可以序列化，进行传输或者保存，也无法对他们进行重新的资源分  配，而且，也是没有必要这样实现</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;序列化和反序列化&quot;&gt;&lt;a href=&quot;#序列化和反序列化&quot; class=&quot;headerlink&quot; title=&quot;序列化和反序列化&quot;&gt;&lt;/a&gt;序列化和反序列化&lt;/h1&gt;&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;hea
      
    
    </summary>
    
    
      <category term="java" scheme="http://dcLunatic.github.io/tags/java/"/>
    
      <category term="序列化" scheme="http://dcLunatic.github.io/tags/%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Java 线程通信——转</title>
    <link href="http://dcLunatic.github.io/2018/09/21/Java-%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1/"/>
    <id>http://dcLunatic.github.io/2018/09/21/Java-线程通信/</id>
    <published>2018-09-21T05:42:03.000Z</published>
    <updated>2018-09-21T05:43:27.769Z</updated>
    
    <content type="html"><![CDATA[<h1 id="转-java线程通信的三种方式"><a href="#转-java线程通信的三种方式" class="headerlink" title="(转)java线程通信的三种方式"></a>(转)java线程通信的三种方式</h1><p><strong>1、传统的线程通信。</strong></p><p>​    在synchronized修饰的同步方法或者修饰的同步代码块中使用Object类提供的wait(),notify()和notifyAll()3个方法进行线程通信。</p><p>​    关于这3个方法的解释：</p><ol><li>​    wait():导致当前线程等待，直到其他线程调用该同步监视器的notify()方法或notifyAll()方法来唤醒该线程。</li><li>​    notify():唤醒在此同步监视器上等待的单个线程。</li><li>​    notifyAll():唤醒在此同步监视器上等待的所有线程。</li></ol><p><strong>2、使用Condition控制线程通信。</strong></p><p>​    当程序使用Lock对象来保证同步，系统不存在隐式的同步监视器，只能用Condition类来控制线程通信。</p><ol><li>​     await():类似于隐式同步监视器上的wait()方法，导致当前线程等待，直到其他线程调用该Condition的signal()方法或signalAll()方法来唤醒该线程。</li><li>​    signal():唤醒在此Lock对象上等待的单个线程。如果所有的线程都在该Lock对象上等待，则会选择唤醒其中一个线程。选择是任意性的。</li><li>​    signalAll():唤醒在此Lock对象上等待的所有线程，只有当前线程放弃对该Lock对象的锁定后，才可以执行被唤醒的线程。</li></ol><p><strong>3、使用阻塞队列（BlockingQueue）控制线程通信（也实现了生产者消费者模式）</strong></p><p>​    BlockingQueue提供如下两个支持阻塞的方法：</p><ol><li>​    put(E e):尝试把E元素放入BlockingQueue中，如果该队列的元素已满，则阻塞该线程。</li><li>​    take():尝试从BlockingQueue的头部取出元素，如果该队列的元素已空，则阻塞该线程。</li></ol><p>​    示例代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br></pre></td><td class="code"><pre><span class="line">package edu.Utils;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import java.util.concurrent.BlockingQueue;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> * Created by hpp on 2017/7/4.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Producer extends Thread&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private BlockingQueue&lt;String&gt; bq;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public Producer(BlockingQueue&lt;String&gt; bq)&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        this.bq = bq;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public void run()&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        String[] strArr = new String[]&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                &quot;java&quot;,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                &quot;Struts&quot;,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                &quot;Spring&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        for(int i = 0;i&lt;99999;i++)&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            System.out.println(getName() + &quot;生产者准备生产集合元素！&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            try&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                Thread.sleep(1000);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                bq.put(strArr[i%3]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &#125;catch (Exception e)&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                e.printStackTrace();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            System.out.println(getName() + &quot;生成完成：&quot; + bq);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Consumer extends Thread&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private BlockingQueue&lt;String&gt; bq;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public Consumer(BlockingQueue&lt;String&gt; bq)&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        this.bq = bq;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public void run()&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        while(true)&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            System.out.println(getName() + &quot;消费者准备消费集合元素！&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            try&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                Thread.sleep(1000);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                bq.take();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &#125;catch (Exception e)&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                e.printStackTrace();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            System.out.println(getName() + &quot;消费完成：&quot; + bq);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class BlockingQueueTest &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        //创建一个容量为1的BlockingQueue</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        BlockingQueue&lt;String&gt; bq = new ArrayBlockingQueue&lt;String&gt;(1);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        //启动3个生产者线程</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        new Producer(bq).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        new Producer(bq).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        new Producer(bq).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        //启动1个消费者线程</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        new Consumer(bq).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">Thread-0生产者准备生产集合元素！</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Thread-1生产者准备生产集合元素！</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Thread-2生产者准备生产集合元素！</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Thread-3消费者准备消费集合元素！</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Thread-0生成完成：[java]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Thread-0生产者准备生产集合元素！</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Thread-1生成完成：[java]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Thread-1生产者准备生产集合元素！</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Thread-3消费完成：[java]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Thread-3消费者准备消费集合元素！</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Thread-2生成完成：[java]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Thread-2生产者准备生产集合元素！</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Thread-3消费完成：[java]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Thread-3消费者准备消费集合元素！</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Thread-0生成完成：[Struts]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Thread-0生产者准备生产集合元素！</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Thread-3消费完成：[Struts]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Thread-3消费者准备消费集合元素！</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;转-java线程通信的三种方式&quot;&gt;&lt;a href=&quot;#转-java线程通信的三种方式&quot; class=&quot;headerlink&quot; title=&quot;(转)java线程通信的三种方式&quot;&gt;&lt;/a&gt;(转)java线程通信的三种方式&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;1、传统的线程通
      
    
    </summary>
    
    
      <category term="java" scheme="http://dcLunatic.github.io/tags/java/"/>
    
      <category term="线程通信" scheme="http://dcLunatic.github.io/tags/%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title>volatile关键字</title>
    <link href="http://dcLunatic.github.io/2018/09/21/volatile%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>http://dcLunatic.github.io/2018/09/21/volatile关键字/</id>
    <published>2018-09-21T05:41:17.000Z</published>
    <updated>2018-09-21T05:41:42.123Z</updated>
    
    <content type="html"><![CDATA[<h1 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h1><h2 id="内存模型的相关概念"><a href="#内存模型的相关概念" class="headerlink" title="内存模型的相关概念"></a>内存模型的相关概念</h2><p><img src="mthread4.png" alt="4"></p><p>如上图所示，在java中，每个线程都拥有自己的本地空间，在需要对共享变量操作时，会将共享变量复制一份到自己的本地空间，操作完成后，在某个时间刷回主内存。线程与线程所拥有的空间是相互独立的，一般情况下是不可见的，这个时候，就会出现一个问题，<strong>内存可见性问题</strong>。</p><h2 id="内存可见性问题"><a href="#内存可见性问题" class="headerlink" title="内存可见性问题"></a>内存可见性问题</h2><p>先举个例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isRunning = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isRunning</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isRunning;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRunning</span><span class="params">(<span class="keyword">boolean</span> isRunning)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.isRunning = isRunning;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"进入到run方法中了"</span>);</span><br><span class="line">        <span class="keyword">while</span> (isRunning == <span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">//System.out.println("Running");</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"线程执行完成了"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Run</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            RunThread thread = <span class="keyword">new</span> RunThread();</span><br><span class="line">            thread.start();</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            thread.setRunning(<span class="keyword">false</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本来在<code>thread.setRunning(false);</code>后，线程就应该停止的了。但是在我们运行后，线程一直都在循环当中，无法结束。</p><blockquote><p>这里的话，64位的jdk无须做任何修改（默认就是server方式启动），32位的需要加上-server参数。</p></blockquote><p>仔细的分析一下，有两个线程，一个main线程，一个RunThread线程。他们都会试图操纵isRunning变量。而按照上面所说的，main线程会将isRunning变量读取到本地线程内存空间，修改后，刷会主内存。而RunThread线程则从主内存中获取isRunning变量到本地线程内存空间，通过读取isRunning的值，作为while循环的判断条件。本来到这里是没什么问题的。但是，当JVM是以-server模式与性的时候，线程会一直在私有堆栈中读取变量的值，也就是说，RunThread线程读取的一直都是没有改变过的那个isRunning的值，始终无法读取到main线程改变的isRunning的值。所以这里就出现了死循环了。</p><blockquote><p>如果在while循环中加上一句sout，会发现执行若干次后，程序结束了循环。</p></blockquote><blockquote><p>这种情况，称为“活性失败”</p></blockquote><p>这里只需要将isRunnig用volatile关键字修饰，使得isRunning在各个线程之间是可见的，会强制线程从主内存中取被volatile修饰的isRunning变量。</p><h2 id="原子性问题"><a href="#原子性问题" class="headerlink" title="原子性问题"></a>原子性问题</h2><p>所谓原子性，就是某系列的操作要么全部执行，要么全不执行。</p><p>比如说<code>i = i + 1;</code>，粗略的可分成三个步骤：</p><ul><li>从内存中取出i的值</li><li>将i的值加1</li><li>将相加后的值放到i中，写回内存</li></ul><p>上面用volatile关键字解决了可见性问题，但是volatile是非原子性的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"count="</span> + count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        addCount();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Run</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyThread[] mythreadArray = <span class="keyword">new</span> MyThread[<span class="number">100</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            mythreadArray[i] = <span class="keyword">new</span> MyThread();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            mythreadArray[i].start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正常的来说，最后count的值应该是10000，但实际上，往往会比这个值要小一些。</p><p>比如，假设 i 自增到 5，线程A从主内存中读取i，值为5，将它存储到自己的线程空间中，执行加1操作，值为6。此时，CPU切换到线程B执行，从主从内存中读取变量i的值。由于线程A还没有来得及将加1后的结果写回到主内存，线程B就已经从主内存中读取了i，因此，线程B读到的变量<br> i 值还是5。有点类似于数据库的脏读了。</p><blockquote><p>这种情况称为“安全性失败”</p></blockquote><h2 id="有序性问题"><a href="#有序性问题" class="headerlink" title="有序性问题"></a>有序性问题</h2><p>一般来说，JVM为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">i = <span class="number">10</span>;</span><br><span class="line">flag = !flag;</span><br></pre></td></tr></table></figure><p>在上面，第三句与第四句谁先执行都对程序结果是没有影响的，因为在他们中间也没有其他的语句了，你先我先，都一样的。</p><p>JVM在对指令进行重排序的时候，是根据指令之间的数据依赖性来判断是否要重排序的，从而来保证结果没有任何影响。</p><p>但是，这仅仅是在单个线程内，如果是在多个线程呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一些声明</span></span><br><span class="line"><span class="keyword">boolean</span> inited = <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">//线程1:</span></span><br><span class="line">context = loadContext();   <span class="comment">//语句1</span></span><br><span class="line">inited = <span class="keyword">true</span>;             <span class="comment">//语句2</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//线程2:</span></span><br><span class="line"><span class="keyword">while</span>(!inited )&#123;</span><br><span class="line">  sleep()</span><br><span class="line">&#125;</span><br><span class="line">doSomethingwithconfig(context);</span><br></pre></td></tr></table></figure><p>上面代码中，由于语句1和语句2没有数据依赖性，因此可能会被重排序。假如发生了重排序，在线程1执行过程中先执行语句2，而此是线程2会以为初始化工作已经完成，那么就会跳出while循环，去执行doSomethingwithconfig(context)方法，而此时context并没有被初始化，就会导致程序出错。</p><p>那么如果我们在声明inited变量的时候，用volatile关键字修饰，那么就不会存在这个问题，JVM保证volatile修饰的变量不会发生指令重排序，也就是说，volatile修饰的变量会禁止指令重排序。</p><h2 id="Java中的有序性："><a href="#Java中的有序性：" class="headerlink" title="Java中的有序性："></a>Java中的有序性：</h2><p>在Java内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。</p><p>在Java里面，可以通过volatile关键字来保证一定的“有序性”。另外可以通过synchronized和Lock来保证有序性，很显然，synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。</p><p>另外，Java内存模型具备一些先天的“有序性”，即不需要通过任何手段就能够得到保证的有序性，这个通常也称为 happens-before 原则。如果两个操作的执行次序无法从happens-before原则推导出来，那么它们就不能保证它们的有序性，虚拟机可以随意地对它们进行重排序。</p><h5 id="下面就来具体介绍下happens-before原则（先行发生原则）："><a href="#下面就来具体介绍下happens-before原则（先行发生原则）：" class="headerlink" title="下面就来具体介绍下happens-before原则（先行发生原则）："></a>下面就来具体介绍下happens-before原则（先行发生原则）：</h5><p>①程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作</p><p>②锁定规则：一个unLock操作先行发生于后面对同一个锁的lock操作</p><p>③volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作</p><p>④传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C</p><p>⑤线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作</p><p>⑥线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生</p><p>⑦线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行</p><p>⑧对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始</p><p>这8条规则中，前4条规则是比较重要的，后4条规则都是显而易见的。</p><p>下面我们来解释一下前4条规则：</p><p>对于程序次序规则来说，就是一段程序代码的执行在单个线程中看起来是有序的。注意，虽然这条规则中提到“书写在前面的操作先行发生于书写在后面的操作”，这个应该是程序看起来执行的顺序是按照代码顺序执行的，但是虚拟机可能会对程序代码进行指令重排序。虽然进行重排序，但是最终执行的结果是与程序顺序执行的结果一致的，它只会对不存在数据依赖性的指令进行重排序。因此，在单个线程中，程序执行看起来是有序执行的，这一点要注意理解。事实上，这个规则是用来保证程序在单线程中执行结果的正确性，但无法保证程序在多线程中执行的正确性。</p><p>第二条规则也比较容易理解，也就是说无论在单线程中还是多线程中，同一个锁如果处于被锁定的状态，那么必须先对锁进行了释放操作，后面才能继续进行lock操作。</p><p>第三条规则是一条比较重要的规则。直观地解释就是，如果一个线程先去写一个变量，然后一个线程去进行读取，那么写入操作肯定会先行发生于读操作。</p><p>第四条规则实际上就是体现happens-before原则具备传递性。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li><p>volatile主要用于线程对共享变量的使用的安全问题，使线程每次在获得共享变量的值时，都是从主内存中去获取，而不是从线程的私有内存中读取，从而来保证数据的可见性。</p></li><li><p>volatile只能修饰变量，不能修饰代码块，方法等（可以考虑使用synchronized关键字）</p></li><li><p>仅仅使用volatile的话，是无法保证线程的安全性的，而synchronized可以）</p><blockquote><p>synchronized不仅保证可见性，而且还保证原子性，因为，只有获得了锁的线程才能进入临界区，从而保证临界区中的所有语句都全部执行。多个线程争抢synchronized锁对象时，会出现阻塞。</p></blockquote></li><li><p>对于多线程中的并发安全问题，volatile关键字是这样子的：</p><ul><li>保证内存可见性</li><li>不保证原子性</li><li>禁止指令的重排序</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;volatile关键字&quot;&gt;&lt;a href=&quot;#volatile关键字&quot; class=&quot;headerlink&quot; title=&quot;volatile关键字&quot;&gt;&lt;/a&gt;volatile关键字&lt;/h1&gt;&lt;h2 id=&quot;内存模型的相关概念&quot;&gt;&lt;a href=&quot;#内存模型的相关概
      
    
    </summary>
    
    
      <category term="java" scheme="http://dcLunatic.github.io/tags/java/"/>
    
      <category term="volatile" scheme="http://dcLunatic.github.io/tags/volatile/"/>
    
  </entry>
  
  <entry>
    <title>synchronized关键字</title>
    <link href="http://dcLunatic.github.io/2018/09/21/synchronized%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>http://dcLunatic.github.io/2018/09/21/synchronized关键字/</id>
    <published>2018-09-21T05:40:32.000Z</published>
    <updated>2018-09-21T05:40:58.013Z</updated>
    
    <content type="html"><![CDATA[<h1 id="synchronized关键字"><a href="#synchronized关键字" class="headerlink" title="synchronized关键字"></a>synchronized关键字</h1><p>写一个测试类，里面包含了同步方法，同步代码块，还有一个不加同步的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncDemo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">doSth1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello world!"</span>);</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSth2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(SyncDemo.class)&#123;</span><br><span class="line">            System.out.println(<span class="string">"Hello world!"</span>);      </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSth3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello world!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>javac编译后，使用javap查看编译后的字节码文件。</p><p>主要看这三个方法，其他的省略，如下所示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">  public synchronized void doSth1();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: (0x0021) ACC_PUBLIC, ACC_SYNCHRONIZED</span><br><span class="line">    Code:</span><br><span class="line">      stack=2, locals=1, args_size=1</span><br><span class="line">         0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">         3: ldc           #3                  // String Hello world!</span><br><span class="line">         5: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">         8: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 3: 0</span><br><span class="line">        line 5: 8</span><br><span class="line"></span><br><span class="line">  public void doSth2();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: (0x0001) ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=2, locals=3, args_size=1</span><br><span class="line">         0: ldc           #5                  // class SyncDemo</span><br><span class="line">         2: dup</span><br><span class="line">         3: astore_1</span><br><span class="line">         4: monitorenter</span><br><span class="line">         5: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">         8: ldc           #3                  // String Hello world!</span><br><span class="line">        10: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">        13: aload_1</span><br><span class="line">        14: monitorexit</span><br><span class="line">        15: goto          23</span><br><span class="line">        18: astore_2</span><br><span class="line">        19: aload_1</span><br><span class="line">        20: monitorexit</span><br><span class="line">        21: aload_2</span><br><span class="line">        22: athrow</span><br><span class="line">        23: return</span><br><span class="line">      Exception table:</span><br><span class="line">         from    to  target type</span><br><span class="line">             5    15    18   any</span><br><span class="line">            18    21    18   any</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 7: 0</span><br><span class="line">        line 8: 5</span><br><span class="line">        line 9: 13</span><br><span class="line">        line 10: 23</span><br><span class="line">      StackMapTable: number_of_entries = 2</span><br><span class="line">        frame_type = 255 /* full_frame */</span><br><span class="line">          offset_delta = 18</span><br><span class="line">          locals = [ class SyncDemo, class java/lang/Object ]</span><br><span class="line">          stack = [ class java/lang/Throwable ]</span><br><span class="line">        frame_type = 250 /* chop */</span><br><span class="line">          offset_delta = 4</span><br><span class="line"></span><br><span class="line">  public void doSth3();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: (0x0001) ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=2, locals=1, args_size=1</span><br><span class="line">         0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">         3: ldc           #3                  // String Hello world!</span><br><span class="line">         5: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">         8: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 12: 0</span><br><span class="line">        line 13: 8</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先看下doSth1()跟doSth()3的区别，仅仅只是在方法那里加了一个ACC_SYNCHRONIZED标志。</p><p><strong>也就是说，对于同步方法，jvm采用ACC_SYNCHRONIZED关键字来实现同步。</strong></p><blockquote><p> JVM的解释翻译后，大概是这样子的：</p><p>方法级的同步是隐式的，在同步方法的常量池中会多了一个ACC_SYNCHRONIZED标志，当某个线程要访问这个方法时，会先检查是否存在该同步标志，如果存在，需要先获得监视器锁，然后执行，再然后释放监视器锁。如果获得不到锁，就需要等待，获取了监视器锁才可以执行下去。</p><p>值得注意的是，如果在同步方法中存在异常，在方法中又没有捕获处理，那么，在抛出该异常的时候，会先释放所占用的监视器锁。</p></blockquote><p>而doSth2()就有很大的差异了。</p><p>首先没有额外的标记（ACC_SYNCHRONIZED）</p><p>其次，System.out.println(“Hello world!”);的关键代码被包围起来了，最主要的两句就是monitorenter，还有monitorexit。监视器进入，监视器退出。</p><blockquote><p> 每个对象都维护着一个计数器用于记录当前被锁的次数。当执行monitorenter后，该计数器会自增1，对应的线程获得锁，而执行monitorexit后，该计数器会自减1，对应的线程也会释放锁。在计数器字段为0的时候，都可以被任何线程获得锁，而当计数器字段不为0的时候，只有已经获得了锁的线程可以再次获得锁（重入锁）。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;synchronized关键字&quot;&gt;&lt;a href=&quot;#synchronized关键字&quot; class=&quot;headerlink&quot; title=&quot;synchronized关键字&quot;&gt;&lt;/a&gt;synchronized关键字&lt;/h1&gt;&lt;p&gt;写一个测试类，里面包含了同步方法，同
      
    
    </summary>
    
    
      <category term="java" scheme="http://dcLunatic.github.io/tags/java/"/>
    
      <category term="同步锁" scheme="http://dcLunatic.github.io/tags/%E5%90%8C%E6%AD%A5%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>java Lock包实现锁</title>
    <link href="http://dcLunatic.github.io/2018/09/21/java-Lock%E5%8C%85%E5%AE%9E%E7%8E%B0%E9%94%81/"/>
    <id>http://dcLunatic.github.io/2018/09/21/java-Lock包实现锁/</id>
    <published>2018-09-21T05:39:18.000Z</published>
    <updated>2018-09-21T05:40:06.240Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java并发中lock的使用"><a href="#Java并发中lock的使用" class="headerlink" title="Java并发中lock的使用"></a>Java并发中lock的使用</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在java并发编程中，我们常常要考虑多个线程之间的同步问题，而这时候，synchronized关键字是一个不错的选择，使用synchronized可以实现对临界资源的同步互斥访问，但是synchronized粒度比较大，在使用它时，可能会造成一些性能上的问题，如响应中断等局限性问题。</p><p>相比之下，java中的Lock提供了比synchronized更为通用的、更为广泛的锁操作，它能更好的处理线程的同步问题。</p><h2 id="synchronized的缺点"><a href="#synchronized的缺点" class="headerlink" title="synchronized的缺点"></a>synchronized的缺点</h2><blockquote><p>synchronized是java中的关键字，是java的内置特性之一，基于JVM层面实现。</p></blockquote><p>当一个代码块被synchronized关键字修饰，然后当一个线程首先获取到了对应的锁之后，并执行该代码块时，其他线程只能一直等待知道占有线程的资源释放锁为止。<strong>也就是说，当占有锁的线程执行完这个代码块时，线程会释放对锁的占用；或者占有锁的线程发生异常，然后JVM自动释放对锁的占用。</strong></p><p>仔细分析一下这个过程，会存在这样的问题：</p><p>当占用锁的线程由于IO或者其他的原因(sleep方法)，使得该线程在某些阻塞了，但是此时线程又不会释放锁，所以其他需要得到锁的线程就会一直等待，从而影响了整个程序的运行效率，甚至会出现死锁的情况。(A线程在A1同步代码块中试图去执行B1同步代码块，而B线程在B1同步代码块中试图去执行A1同步代码块，此时，A线程和B线程就会互相等待，从而出现死锁。)</p><p>同时，使用synchronized关键字，在阻塞等待过程中的线程，是无法被中断的。</p><p>举个实际点的例子，当多个线程进行读写操作时，使用synchronized同步嘛，读和写会发生冲突，写和写也会发生冲突，这时候使用synchronized同步加锁是没有问题的，但是读跟读呢，好像两者并不相互影响。使用synchronized同步的话，就会导致性能问题了。</p><h2 id="Lock的优点"><a href="#Lock的优点" class="headerlink" title="Lock的优点"></a>Lock的优点</h2><p>相比于synchronized关键字，当我们使用Lock来解决这些同步问题时，可以实现更广泛的锁操作，实现更灵活的锁结构。</p><p>比如说会有以下优点:</p><ol><li>对于多个线程进行读写操作时，Lock提供了一个特殊的锁，ReentrantReadWriteLock锁，来使得多个线程可以同时进行读操作。</li><li>当一个线程要获得一个同步锁时，可以即时(或者延时)返回取得锁的结果，成功或者不成功，而不是想synchronized一样，在那里一直阻塞等待(使用tryLock()或者tryLock(long time, TimeUnit unit))。</li><li>在等待获得锁的时候，我们可以直接中断这个等待，也就是说，能够响应中断(lockInterruptibly())。</li></ol><blockquote><p>但是相比synchronized关键字，使用Lock的同步锁，并不会自动释放该锁，该锁必须手动释放。当没有主动释放锁时，就有可能会出现死锁的情况。<strong>一般建议将加锁放在try里面，然后在finally中释放锁。</strong></p></blockquote><h2 id="Lock的注意事项"><a href="#Lock的注意事项" class="headerlink" title="Lock的注意事项"></a>Lock的注意事项</h2><p>三种形式的锁获取（可中断、不可中断和定时）在其性能特征、排序保证或其他实现质量上可能会有所不同。而且，对于给定的 <code>Lock</code> 类，可能没有中断<em>正在进行的</em> 锁获取的能力。因此，并不要求实现为所有三种形式的锁获取定义相同的保证或语义，也不要求其支持中断正在进行的锁获取。实现必需清楚地对每个锁定方法所提供的语义和保证进行记录。还必须遵守此接口中定义的中断语义，以便为锁获取中断提供支持：完全支持中断，或仅在进入方法时支持中断。</p><p>由于中断通常意味着取消，而通常又很少进行中断检查，因此，相对于普通方法返回而言，实现可能更喜欢响应某个中断。即使出现在另一个操作后的中断可能会释放线程锁时也是如此。实现应记录此行为。</p><h2 id="Lock接口"><a href="#Lock接口" class="headerlink" title="Lock接口"></a>Lock接口</h2><p>在java.util.concurrent.locks包中，Lock接口是一个最基本的接口之一。</p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ul><li>void lock()                                       //获取锁</li><li>void lockInterruptibly()               //如果当前线程没有被中断，则获取锁</li><li>Condition newCondition()          //返回绑定到此Lock实例的新Condition实例</li><li>boolean tryLock()                         //仅在调用时锁空闲状态时才获取锁，返回获取结果</li><li>boolean tryLock(long time, TimeUnit unit)    //如果锁在给定的等待时间内空闲，并且当前线程未被中断，则获取锁，返回获取结果</li><li>void unlock()                                //释放锁</li></ul><blockquote><p>newCondition()方法一般是用在线程协作的情况下的，在这里暂时不说。</p></blockquote><h3 id="lock"><a href="#lock" class="headerlink" title="lock()"></a>lock()</h3><p>这个方法会比较常用，实现起来的效果跟synchronized关键字一样。使用lock()方法尝试去获取锁，如果获取不到锁，则会一直等待，等待过程中，不可响应中断。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Lock lock = ...;</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//doSomething();</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">    <span class="comment">//e.printStackTrace();</span></span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里之所以使用try-catch-finally结构，是为了保证无论在什么情况下，这个锁都可以被释放。</p><h3 id="tryLock-与tryLock-long-time-TimeUnit-unit"><a href="#tryLock-与tryLock-long-time-TimeUnit-unit" class="headerlink" title="tryLock()与tryLock(long time, TimeUnit unit)"></a>tryLock()与tryLock(long time, TimeUnit unit)</h3><p>这两个方法都是有返回值的，tryLock()方法会即时的返回获取锁的结果，如果在调用的时候成功获取到了锁，则返回true，否则返回false，相比lock()方法，它不会在那里一直等待，直到获取成功。tryLock(long time, TimeUnit unit)方法类似于tryLock()方法，但是它允许等待一段时间，在这段时间内，如果得到锁，返回true，否则在这段时间后，返回false。time参数指定时间，而unit参数指定时间单位。</p><blockquote><p>值得注意的是，tryLock(long time, TimeUnit unit)支持响应中断，而tryLock()不支持，关于响应中断，见下面的lockInterruptibly()方法。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Lock lock = ...;</span><br><span class="line"><span class="keyword">if</span>(lock.tryLock())&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="comment">//doSomething();</span></span><br><span class="line">    &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">        <span class="comment">//e.printStackTrace();</span></span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等待50s</span></span><br><span class="line"><span class="keyword">boolean</span> rs = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    rs = lock.tryLock(<span class="number">50L</span>, TimeUnit.SECONDS);</span><br><span class="line">&#125;<span class="keyword">catch</span>(InterruptedException ie)&#123;</span><br><span class="line"><span class="comment">//这里对中断产生的异常进行捕获处理，但是一般的做法更应该抛出给上一级处理，参见下面</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(rs)&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="comment">//doSomething();</span></span><br><span class="line">        </span><br><span class="line">    &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">        <span class="comment">//e.printStackTrace();</span></span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="lockInterruptibly"><a href="#lockInterruptibly" class="headerlink" title="lockInterruptibly()"></a>lockInterruptibly()</h3><p>同lock()方法一样，会一直等待获取锁，但是，它是可以响应中断的，也就是说，在它等待获取锁的过程中，可以由于调用Thread.interrupt()方法来中断这个阻塞的等待过程，从而抛出一个中断异常。</p><blockquote><p>在一个线程正常执行时，是不会被interrupt()方法中断的，只有在阻塞等待过程中的线程才会被interrupt()方法中断。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function() <span class="keyword">throws</span> InterruptedException&#123;</span><br><span class="line">    Lock lock = ...;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="comment">//doSomething();</span></span><br><span class="line">    &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">        <span class="comment">//e.printStackTrace();</span></span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><p>ReentrantLock，意思是“可重入锁”。ReentrantLock是唯一实现了Lock接口的类，并且在ReenTrantLock中提供了更多的方法，以实现更加广泛的锁操作。</p><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><ul><li><p>ReentrantLock()                     //创建一个ReentrantLock的实例</p></li><li><p>ReentrantLock(boolean fair)    //创建一个具有给定公平策略的ReentrantLock</p><p>这里说一下第二个构造方法，公平参数的作用。当设置为true时，在多个线程的争用下，这些锁将倾向于将访问全授予等待时间最长的线程。否则此锁将无法保证任何特定的访问顺序。与采用默认设置(不公平)相比，使用公平锁的程序在许多线程访问时表现为很低的总体吞吐量(即速度很慢，常常极其慢)，但是在获得锁和保证锁分配的均衡性时差异较小。不过要注意的是，公平锁不能保证线程调度的公平性。因此，使用公平锁的众多线程中的一员可能获得多倍的成功机会，这种情况发生在其他活动线程没有被处理并且目前并未持有锁时。还要注意的是，未定时的 tryLock 方法并没有使用公平设置。因为即使其他线程正在等待，只要该锁是可用的，此方法就可以获得成功。</p></li></ul><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><ul><li>boolean isFair()                                  //该锁是否是公平的</li><li>boolean isLocked()                            //该锁是否被获取了</li><li>boolean isHeldByCurrentThread()    //当前线程是否获得该锁</li><li>int getQueuedLength()                      //返回正等待获取此锁的线程估计数</li><li>boolean hasQueuedThread(Thread thread)    //指定线程是否在等该获取该锁</li><li>boolean hasQueuedThreads()            //是否有线程在等待获取该锁</li></ul><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><ol><li>关于公平参数的</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLockTest1</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        ReentrantLockTest1 test = <span class="keyword">new</span> ReentrantLockTest1();</span><br><span class="line">        Thread a = <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">                test.waitTime(<span class="string">"a"</span>, <span class="number">3000</span>);</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;;</span><br><span class="line">        Thread b = <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">                test.waitTime(<span class="string">"b"</span>, <span class="number">2000</span>);</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;;</span><br><span class="line">        Thread c = <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">                test.waitTime(<span class="string">"c"</span>, <span class="number">3000</span>);</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;;</span><br><span class="line">        a.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>); <span class="comment">//保证a先执行</span></span><br><span class="line">        b.start();</span><br><span class="line">        <span class="comment">//Thread.sleep(10); //保证b比c要先等待</span></span><br><span class="line">        c.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">waitTime</span><span class="params">(String n, <span class="keyword">long</span> time)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"线程"</span> + n + <span class="string">"开始执行"</span>);</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            System.out.println(n + <span class="string">"得到了锁"</span>);</span><br><span class="line">            <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">            <span class="keyword">while</span>(System.currentTimeMillis()-start&lt;time)&#123;</span><br><span class="line">                ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            </span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            System.out.println(n + <span class="string">"释放了锁"</span>);</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">root@dcLunatic:~# java ReentrantLockTest1 </span><br><span class="line">线程a开始执行</span><br><span class="line">a得到了锁</span><br><span class="line">线程b开始执行</span><br><span class="line">线程c开始执行</span><br><span class="line">a释放了锁</span><br><span class="line">b得到了锁</span><br><span class="line">b释放了锁</span><br><span class="line">c得到了锁</span><br><span class="line">c释放了锁</span><br><span class="line">root@dcLunatic:~# java ReentrantLockTest1 </span><br><span class="line">线程a开始执行</span><br><span class="line">a得到了锁</span><br><span class="line">线程b开始执行</span><br><span class="line">线程c开始执行</span><br><span class="line">a释放了锁</span><br><span class="line">c得到了锁</span><br><span class="line">c释放了锁</span><br><span class="line">b得到了锁</span><br><span class="line">b释放了锁</span><br></pre></td></tr></table></figure><p>两次执行结果，两次b都会比c先被调度执行函数waitTime，但是在第一次的时候，是b先获得锁，在第二次的时候却是c先获得锁了，按照先后执行顺序而言，这里的b在等待获取锁的时间应该会比c要长一点点的。但他们在等待获取锁的机会是相同的，所以谁先谁后都是有可能的。</p><p>如果这里要使得b如果比c执行了waitTime函数，然后b必先在c之前得到锁的话，就可以考虑加上公平参数了。(当然，上面你也可以加Thread.sleep(10)来保证b在c之前执行)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java并发中lock的使用&quot;&gt;&lt;a href=&quot;#Java并发中lock的使用&quot; class=&quot;headerlink&quot; title=&quot;Java并发中lock的使用&quot;&gt;&lt;/a&gt;Java并发中lock的使用&lt;/h1&gt;&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot;
      
    
    </summary>
    
    
      <category term="java" scheme="http://dcLunatic.github.io/tags/java/"/>
    
      <category term="Lock" scheme="http://dcLunatic.github.io/tags/Lock/"/>
    
      <category term="锁" scheme="http://dcLunatic.github.io/tags/%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>Java多线程</title>
    <link href="http://dcLunatic.github.io/2018/09/21/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>http://dcLunatic.github.io/2018/09/21/Java多线程/</id>
    <published>2018-09-21T05:36:26.000Z</published>
    <updated>2018-09-21T05:38:45.620Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java多线程"><a href="#java多线程" class="headerlink" title="java多线程"></a>java多线程</h1><blockquote><p>线程，是程序执行的最小单元（进程是基本单位）。</p></blockquote><h2 id="线程的状态机"><a href="#线程的状态机" class="headerlink" title="线程的状态机"></a>线程的状态机</h2><h3 id="状态机转换图"><a href="#状态机转换图" class="headerlink" title="状态机转换图"></a>状态机转换图</h3><p><img src="/images/multi-thread/mthread1.png" alt="1"></p><h3 id="状态说明"><a href="#状态说明" class="headerlink" title="状态说明"></a>状态说明</h3><h4 id="新建状态-new"><a href="#新建状态-new" class="headerlink" title="新建状态(new)"></a>新建状态(new)</h4><p>当线程对象创建后，即进入了新建状态，如: <code>Thread t = new MyThread();</code></p><h4 id="可执行状态-Runnable"><a href="#可执行状态-Runnable" class="headerlink" title="可执行状态(Runnable)"></a>可执行状态(Runnable)</h4><p>当调用线程的start()方法时，线程即进入可执行状态。但是在这个状态下的线程，何时真正的执行取决于cpu的调度机制，并不是说执行了start()方法后，线程就立即执行了。</p><h4 id="执行状态-Running"><a href="#执行状态-Running" class="headerlink" title="执行状态(Running)"></a>执行状态(Running)</h4><p>当cpu开始调度处于可执行状态的线程时，换句话说，当可执行状态的线程获取到cpu时，线程才开始执行，进入到执行状态。也就是说，线程要进入到执行状态，就必须由可执行状态转变而来。</p><h4 id="阻塞状态-Blocked"><a href="#阻塞状态-Blocked" class="headerlink" title="阻塞状态(Blocked)"></a>阻塞状态(Blocked)</h4><p>处于执行状态的进程，会因为某种原因，暂时放弃对cpu的使用权，停止执行，此时就进入阻塞状态，直到进入可执行状态，线程才有机会重新执行。根据不同的阻塞原因，可分为以下三种阻塞：</p><ul><li>等待阻塞：运行状态中的线程执行wait()方法</li><li>同步阻塞：运行状态中的线程获取synchronized同步锁失败</li><li>其他阻塞：运行状态中的线程执行sleep()方法或join()方法或者发出了I/O请求（当sleep()超时，或者join()等待线程终止或者超时，或者I/O处理完毕时，才会进入就绪状态）</li></ul><h4 id="死亡状态-Dead"><a href="#死亡状态-Dead" class="headerlink" title="死亡状态(Dead)"></a>死亡状态(Dead)</h4><p>线程执行完了或者因为某些原因退出了run()方法，该线程会终止生命周期。</p><blockquote><p>这里说的就只有五个状态，还可以从上面的阻塞状态分出一个TIMED_WAITING，该状态表示：</p><p>等待另一个线程来执行取决于指定等待时间的操作的线程处于这种状态。 </p></blockquote><h2 id="Java中多线程的实现"><a href="#Java中多线程的实现" class="headerlink" title="Java中多线程的实现"></a>Java中多线程的实现</h2><p>在Java中，多线程的实现主要有四种方法：继承Thread类、实现Runnable接口、实现Callable接口、通过FutureTask包装器来创建Thread线程、使用ExecutorService、Callable、Future实现有返回结果的线程。</p><h3 id="继承Thread类创建线程"><a href="#继承Thread类创建线程" class="headerlink" title="继承Thread类创建线程"></a>继承Thread类创建线程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="title">extents</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello world!\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String... args)</span></span>&#123;</span><br><span class="line">        Thread _thread = <span class="keyword">new</span> MyThread();</span><br><span class="line">        _thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现Runnable接口创建线程"><a href="#实现Runnable接口创建线程" class="headerlink" title="实现Runnable接口创建线程"></a>实现Runnable接口创建线程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello world!\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String... args)</span></span>&#123;</span><br><span class="line">        Thread _thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable());</span><br><span class="line">        _thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="以上两种方式的联系"><a href="#以上两种方式的联系" class="headerlink" title="以上两种方式的联系"></a>以上两种方式的联系</h3><p>其实Thread类，其实也是一个对Runnable接口的实现类，而在Runnable接口中，有这么一个抽象的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而在Thread类中，是这么实现run()方法的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Runnable target;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">(Runnable target)</span></span>&#123;</span><br><span class="line">        init(<span class="keyword">null</span>, target, <span class="string">"Thread-"</span> + nextThreadNum(), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这里init()方法的其他实现就省略了</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ThreadGroup g, Runnable target, String name,<span class="keyword">long</span> stackSize, AccessControlContext acc)</span></span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target != <span class="keyword">null</span>)&#123;</span><br><span class="line">            target.run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而当我们使用第一种方式继承Thread类然后自己实现run()方法时，其实就是把上面的run()方法重写了，而第二种方法实现Runnable接口然后再作为Thread的构造参数传递，最后调用的就是自己的run()方法了，两种方式启示都是差不多的，<strong>都是没有返回值的</strong>。</p><p><strong>实现Runnable接口相对于继承Thread类来说，有如下的优势:</strong></p><ul><li>适合多个相同程序代码的线程去处理同一资源</li><li>可以避免由于java单继承特性带来的局限</li><li>增强健壮性。代码可以被多个线程共享，代码与数据是独立的。</li></ul><h3 id="实现Callable接口通过FutureTask包装器来创建Thread线程"><a href="#实现Callable接口通过FutureTask包装器来创建Thread线程" class="headerlink" title="实现Callable接口通过FutureTask包装器来创建Thread线程"></a>实现Callable接口通过FutureTask包装器来创建Thread线程</h3><p>Callable接口的定义如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function">V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FutureTask包装器的相关 部分定义如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//保证callable任务只执行一次</span></span><br><span class="line">        <span class="keyword">if</span>(state != NEW || !UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, runnerOffset, <span class="keyword">null</span>, Thread.currentThread()))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Callable&lt;V&gt; c = callable;</span><br><span class="line">            <span class="keyword">if</span>(c != <span class="keyword">null</span> &amp;&amp; state == NEW)&#123;</span><br><span class="line">                V result;</span><br><span class="line">                <span class="keyword">boolean</span> ran;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//执行任务</span></span><br><span class="line">                    result = c.call();</span><br><span class="line">                    ran = <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                    result = <span class="keyword">null</span>;</span><br><span class="line">                    ran = <span class="keyword">false</span>;</span><br><span class="line">                    setException(ex);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (ran)</span><br><span class="line">                    set(result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            runner = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">int</span> s = state;</span><br><span class="line">             <span class="comment">//判断该任务是否正在响应中断，如果中断没有完成，则等待中断操作完成</span></span><br><span class="line">        <span class="keyword">if</span> (s &gt;= INTERRUPTING)</span><br><span class="line">            handlePossibleCancellationInterrupt(s);       </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Runnable</span>, <span class="title">Future</span>&lt;<span class="title">V</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello world!\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello world!"</span>；</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span></span>&#123;</span><br><span class="line">    Callable&lt;String&gt; oneCallable = <span class="keyword">new</span> SomeCallable();</span><br><span class="line">    <span class="comment">//FutureTask&lt;Integer&gt;是一个包装器，它通过接受Callable&lt;Integer&gt;来创建，它同时实现了Future和Runnable接口。</span></span><br><span class="line">    FutureTask&lt;String&gt; oneTask = <span class="keyword">new</span> FutureTask&lt;String&gt;(oneCallable);</span><br><span class="line">    Thread oneThread = <span class="keyword">new</span> Thread(oneTask);</span><br><span class="line">    oneThread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过一系列构造调用后（上面没有列出），最终还是会调用到run()方法，然后在run()方法中再调用call()方法。</p><p>有关FutureTask可以考虑看下这篇<a href="https://blog.csdn.net/shenhao19901114/article/details/80255751" target="_blank" rel="noopener">文章</a>，或者等我有空再写写。</p><h3 id="使用ExecutorService、Callable、Future实现有返回结果的多线程"><a href="#使用ExecutorService、Callable、Future实现有返回结果的多线程" class="headerlink" title="使用ExecutorService、Callable、Future实现有返回结果的多线程"></a>使用ExecutorService、Callable、Future实现有返回结果的多线程</h3><p>ExecutorService、Callable、Future三个接口实际上都是属于Executor框架。返回结果的线程是在JDK1.5中引入的新特征。可返回值的任务必须实现Callable接口。类似的，无返回值的任务必须实现Runnable接口。</p><p>执行Callable任务后，可以获取一个Future的对象，在该对象上调用get就可以获取到Callable任务返回的Object了。</p><blockquote><p>注意：get方法是阻塞的，即：线程无返回结果，get方法会一直等待。</p></blockquote><p>再结合线程池接口ExecutorService就可以实现传说中有返回结果的多线程了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;  </span><br><span class="line"><span class="keyword">import</span> java.util.Date;  </span><br><span class="line"><span class="keyword">import</span> java.util.List;  </span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">* 有返回值的线程 </span></span><br><span class="line"><span class="comment">*/</span>  </span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException,  </span></span><br><span class="line"><span class="function">    InterruptedException </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"----程序开始运行----"</span>);  </span><br><span class="line">        Date date1 = <span class="keyword">new</span> Date();  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> taskSize = <span class="number">5</span>;  </span><br><span class="line">        <span class="comment">// 创建一个线程池  </span></span><br><span class="line">        ExecutorService pool = Executors.newFixedThreadPool(taskSize);  </span><br><span class="line">        <span class="comment">// 创建多个有返回值的任务  </span></span><br><span class="line">        List&lt;Future&gt; list = <span class="keyword">new</span> ArrayList&lt;Future&gt;();  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; taskSize; i++) &#123;  </span><br><span class="line">            Callable c = <span class="keyword">new</span> MyCallable(i + <span class="string">" "</span>);  </span><br><span class="line">            <span class="comment">// 执行任务并获取Future对象  </span></span><br><span class="line">            Future f = pool.submit(c);  </span><br><span class="line">            <span class="comment">// System.out.println("&gt;&gt;&gt;" + f.get().toString());  </span></span><br><span class="line">            list.add(f);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">// 关闭线程池  </span></span><br><span class="line">        pool.shutdown();  </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取所有并发任务的运行结果  </span></span><br><span class="line">        <span class="keyword">for</span> (Future f : list) &#123;  </span><br><span class="line">            <span class="comment">// 从Future对象上获取任务的返回值，并输出到控制台  </span></span><br><span class="line">            System.out.println(<span class="string">"&gt;&gt;&gt;"</span> + f.get().toString());  </span><br><span class="line">        &#125;  </span><br><span class="line"></span><br><span class="line">        Date date2 = <span class="keyword">new</span> Date();  </span><br><span class="line">        System.out.println(<span class="string">"----程序结束运行----，程序运行时间【"</span>  </span><br><span class="line">                           + (date2.getTime() - date1.getTime()) + <span class="string">"毫秒】"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Object</span>&gt; </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> String taskNum;  </span><br><span class="line"></span><br><span class="line">    MyCallable(String taskNum) &#123;  </span><br><span class="line">        <span class="keyword">this</span>.taskNum = taskNum;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"&gt;&gt;&gt;"</span> + taskNum + <span class="string">"任务启动"</span>);  </span><br><span class="line">        Date dateTmp1 = <span class="keyword">new</span> Date();  </span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);  </span><br><span class="line">        Date dateTmp2 = <span class="keyword">new</span> Date();  </span><br><span class="line">        <span class="keyword">long</span> time = dateTmp2.getTime() - dateTmp1.getTime();  </span><br><span class="line">        System.out.println(<span class="string">"&gt;&gt;&gt;"</span> + taskNum + <span class="string">"任务终止"</span>);  </span><br><span class="line">        <span class="keyword">return</span> taskNum + <span class="string">"任务返回运行结果,当前任务时间【"</span> + time + <span class="string">"毫秒】"</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码说明：<br>上述代码中Executors类，提供了一系列工厂方法用于创建线程池，返回的线程池都实现了ExecutorService接口。<br>public static ExecutorService newFixedThreadPool(int nThreads)<br>创建固定数目线程的线程池。<br>public static ExecutorService newCachedThreadPool()<br>创建一个可缓存的线程池，调用execute 将重用以前构造的线程（如果线程可用）。如果现有线程没有可用的，则创建一个新线程并添加到池中。终止并从缓存中移除那些已有 60 秒钟未被使用的线程。<br>public static ExecutorService newSingleThreadExecutor()<br>创建一个单线程化的Executor。<br>public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize)<br>创建一个支持定时及周期性的任务执行的线程池，多数情况下可用来替代Timer类。ExecutoreService提供了submit()方法，传递一个Callable，或Runnable，返回Future。如果Executor后台线程池还没有完成Callable的计算，这调用返回Future对象的get()方法，会阻塞直到计算完成。</p><h2 id="线程状态之间的切换"><a href="#线程状态之间的切换" class="headerlink" title="线程状态之间的切换"></a>线程状态之间的切换</h2><h3 id="wait-、notify-、notifyAll-等方法"><a href="#wait-、notify-、notifyAll-等方法" class="headerlink" title="wait()、notify()、notifyAll()等方法"></a>wait()、notify()、notifyAll()等方法</h3><p>这几个放那广发都是定义在Object类里面的，而不是在Thread中。</p><p>原因：先梳理一下，这几个方法和synchronized一样，都是会对“对象的同步锁”进行操作的，wait会让当前线程释放它所持有的“同步锁”，否则其他线程获取不到的话就没办法执行了；其次，notify或者notifyAll也是根据“对象的同步锁”来确定是否要唤醒等待线程的。</p><blockquote><p>负责唤醒等待线程的那个线程(我们称为“<strong>唤醒线程</strong>”)，它只有在获取“该对象的同步锁”(<strong>这里的同步锁必须和等待线程的同步锁是同一个</strong>)，并且调用notify()或notifyAll()方法之后，才能唤醒等待线程。虽然，等待线程被唤醒；但是，它不能立刻执行，因为唤醒线程还持有“该对象的同步锁”。必须等到唤醒线程释放了“对象的同步锁”之后，等待线程才能获取到“对象的同步锁”进而继续运行。</p></blockquote><p>而“同步锁”是由对象所持有的，并且每一个对象有且仅有一个，所以这些函数就都是定义在Object对象中的。</p><ul><li>wait():**让当前线程处于“阻塞状态”，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，当前线程被唤醒，进入可执行状态</li><li><strong>wait(long timeout):</strong>让当前线程处于“阻塞状态”，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者超时的时候，当前线程被唤醒，进入可执行状态</li><li><strong>wait(long timeout, int nanos):</strong>让当前线程处于“阻塞状态”，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者超时的时候，或者其他线程中断当前线程的时候，当前线程被唤醒，进入可执行状态</li><li><strong>notify():</strong>唤醒在此对象监视器上等待的单个线程。</li><li><strong>notifyAll():</strong>唤醒在此对象监视器上等待的所有线程。<h3 id="yield-方法"><a href="#yield-方法" class="headerlink" title="yield()方法"></a>yield()方法</h3>顾名思义，yield()方法的作用就是让步，它会放弃当前所占用的cpu资源，使得其他的线程有机会去执行，然后自己从执行状态转变到可执行状态，但是，也有可能线程yield()后之后还是继续执行的，这一切都是取决于cpu的调度时机。<blockquote><p>wait会释放锁，但yield不会释放锁。</p></blockquote></li></ul><h3 id="sleep-方法"><a href="#sleep-方法" class="headerlink" title="sleep()方法"></a>sleep()方法</h3><p>类似于wait方法，但是sleep()不会释放所持有的锁。</p><h3 id="join-方法"><a href="#join-方法" class="headerlink" title="join()方法"></a>join()方法</h3><ul><li><p><strong>join():</strong>使得当前线程的<strong>父线程</strong>进入阻塞状态，直到当前线程执行完毕后，父线程才会继续执行。</p><p>eg: 在A线程中调用了B线程的join()方法时，表示只有当B线程执行完毕时，A线程才能继续执行。</p></li><li><p><strong>join(long timeout):</strong>在父线程等待子线程执行多久之后就变成并行执行</p><p>eg: 如果A线程中掉用B线程的join(10)，则表示A线程会等待B线程执行10毫秒，10毫秒过后，A、B线程并行执行。需要注意的是，jdk规定，join(0)的意思不是A线程等待B线程0秒，而是A线程等待B线程无限时间，直到B线程执行完毕，即join(0)等价于join()。</p></li><li><p><strong>join(long timeout, int nanos):</strong>在父线程等待子线程执行多久之后就变成并行执行。或者某个进程结束后执行。</p></li></ul><p>join方法需要在线程进入到可执行状态后执行才有意义，也就是说，要在start()后执行。</p><p>其底层的实现是依赖于wait()方法，所以join也会释放锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">long</span> millis)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> base = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">long</span> now = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"timeout value is negative"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (millis == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">                wait(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">                <span class="keyword">long</span> delay = millis - now;</span><br><span class="line">                <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                wait(delay);</span><br><span class="line">                now = System.currentTimeMillis() - base;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>从源码中可以看到：join方法的原理就是调用相应线程的wait方法进行等待操作的，例如A线程中调用了B线程的join方法，则相当于在A线程中调用了B线程的wait方法，当B线程执行完（或者到达等待时间），B线程会自动调用自身的notifyAll方法唤醒A线程，从而达到同步的目的。</p><h3 id="interrupt-、interrupted-、isInterrupted-方法"><a href="#interrupt-、interrupted-、isInterrupted-方法" class="headerlink" title="interrupt()、interrupted()、isInterrupted()方法"></a>interrupt()、interrupted()、isInterrupted()方法</h3><p>如果我们要创建一个线程是很简单的，只需要怎样怎样就可以了，但是要停止一个线程，却不能简单的使用Thread.stop()方法。（这里不说那种使用切换状态变量的值控制线程状态的方法）</p><p>在java中，java的中断机制是一种协作机制，也就是说通过中断并不能直接终止另一个线程，而需要被中断的线程自己处理中断。</p><p>interrupt()方法和stop()方法的差别：</p><p>interrupt()方法是设置线程的中断状态，让用户自己选择时间地点去结束线程；而stop()方法会在代码的运行处直接抛出一个ThreadDeath错误，这是一个java.lang.Error的子类。所以直接使用stop()方法就有可能造成对象的不一致性。</p><p>有这么一个状态值，记录着中断状态，interrupt status，是这样定义的</p><p><code>private volatile Interrupttible blocker;</code></p><p>默认情况下，blocker = null;</p><p>如果调用interrupt0()方法，会设置或者清除该中断状态的值。</p><p>#### </p><p>简单介绍一下这几个方法：</p><ul><li><p><strong>public void interrupt()</strong>:</p><p>中断线程，如果线程处于阻塞状态，则中断过程会受阻，这时候会清除中断状态的值，并抛出一个异常<code>InterruptedException</code></p></li><li><p><strong>public static boolean interrupted()</strong>:</p><p>测试当前线程是否已经中断。线程中断被忽略，因为在中断时不处于活动状态的线程将由此返回 false 的方法反映出来。<strong>此方法会清除中断状态的值</strong>。</p><p>如果当前线程已经中断，则返回 <code>true</code>；否则返回 <code>false</code>。</p></li><li><p><strong>public boolean isInterrupted():</strong></p><p>测试线程是否已经中断。线程中断被忽略，因为在中断时不处于活动状态的线程将由此返回 false 的方法反映出来。<strong>此方法不会影响中断状态的值</strong>。</p><p>如果当前线程已经中断，则返回 <code>true</code>；否则返回 <code>false</code>。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">interrupted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> currentThread().isInterrupted(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInterrupted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> isInterrupted(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//是否要清除中断状态的值</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">isInterrupted</span><span class="params">(<span class="keyword">boolean</span> ClearInterrupted)</span></span>;</span><br></pre></td></tr></table></figure><p>很多naive方法，就没有继续往下看了，推荐一篇<a href="https://www.jianshu.com/p/1492434f2810" target="_blank" rel="noopener">文章</a>，对底层的c++源码有所涉及。</p><h2 id="线程终止"><a href="#线程终止" class="headerlink" title="线程终止"></a>线程终止</h2><p>Thread中的stop()和suspend()方法，由于固有的不安全性，已经建议不再使用！</p><p>一般都是围绕着interrupt方法来实现这功能。</p><h3 id="终止处于“阻塞状态”的线程"><a href="#终止处于“阻塞状态”的线程" class="headerlink" title="终止处于“阻塞状态”的线程"></a>终止处于“阻塞状态”的线程</h3><p>我们通过“中断”方式终止处于“阻塞状态”的线程。<br>当线程由于被调用了sleep(), wait(), join()等方法而进入阻塞状态；若此时调用线程的interrupt()将线程的中断标记设为true。由于处于阻塞状态，中断标记会被清除，同时产生一个InterruptedException异常。将InterruptedException放在适当的位置就能终止线程，形式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 执行任务...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;  </span><br><span class="line">        <span class="comment">// 由于产生InterruptedException异常，退出while(true)循环，线程终止！</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="终止处于“运行状态”的线程"><a href="#终止处于“运行状态”的线程" class="headerlink" title="终止处于“运行状态”的线程"></a>终止处于“运行状态”的线程</h3><ul><li><p><strong>通过中断标记终止线程</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!isInterrupted()) &#123;</span><br><span class="line">        <span class="comment">// 执行任务...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>通过额外的变量标记终止线程</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> flag= <span class="keyword">true</span>;</span><br><span class="line"><span class="comment">//将flag定义为volatile类型，是为了保证flag的可见性。即其它线程通过stopTask()修改了flag之后，本线程能看到修改后的flag的值。</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">stopTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    flag = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (flag) &#123;</span><br><span class="line">        <span class="comment">// 执行任务...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="终止任何状态的线程"><a href="#终止任何状态的线程" class="headerlink" title="终止任何状态的线程"></a>终止任何状态的线程</h3><p>将两者结合起来就可以了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1. isInterrupted()保证，只要中断标记为true就终止线程。</span></span><br><span class="line">        <span class="keyword">while</span> (!isInterrupted()) &#123;</span><br><span class="line">            <span class="comment">// 执行任务...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;  </span><br><span class="line">        <span class="comment">// 2. InterruptedException异常保证，当InterruptedException异常产生时，线程被终止。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="关键字volatile与synchronized"><a href="#关键字volatile与synchronized" class="headerlink" title="关键字volatile与synchronized"></a>关键字volatile与synchronized</h2><h3 id="java内存模型图"><a href="#java内存模型图" class="headerlink" title="java内存模型图"></a>java内存模型图</h3><p><img src="/images/multi-thread/mthread4.png" alt="4"></p><h3 id="内存可见性问题"><a href="#内存可见性问题" class="headerlink" title="内存可见性问题"></a>内存可见性问题</h3><p>每一个线程都有一个属于自己的本地空间，当线程执行时，如果需要什么，会从主内存中读取对应变量的副本到本地空间，然后对该变量操作完成后，在某个时间再把这个变量同步到主内存中。</p><p>在这里，就会存在着一个问题：内存可见性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isRunning = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isRunning</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isRunning;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRunning</span><span class="params">(<span class="keyword">boolean</span> isRunning)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.isRunning = isRunning;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"进入到run方法中了"</span>);</span><br><span class="line">        <span class="keyword">while</span> (isRunning == <span class="keyword">true</span>) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"线程执行完成了"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Run</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            RunThread thread = <span class="keyword">new</span> RunThread();</span><br><span class="line">            thread.start();</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            thread.setRunning(<span class="keyword">false</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们使用JVM -server参数执行这个程序的时候，RunThread线程并不会终止，出现了死循环。</p><blockquote><p>64位的jdk默认就是启用server模式的。</p></blockquote><h2 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h2><h3 id="什么情况下会产生线程安全问题"><a href="#什么情况下会产生线程安全问题" class="headerlink" title="什么情况下会产生线程安全问题"></a>什么情况下会产生线程安全问题</h3><p>当有多个线程在操作共享的数据且操作共享数据的线程代码有多条时，就会产生线程安全问题。</p><p>很经典的例子就是生产者-消费者模型了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//消费者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    Product p = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(Product p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.p = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p.status)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++)&#123;</span><br><span class="line">                p.pop();</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//生产者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Productor</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    Product p = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Productor</span><span class="params">(Product p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.p = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p.status)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++)&#123;</span><br><span class="line">                p.push();</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//产品</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">10000</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> status = <span class="keyword">false</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">()</span></span>&#123;</span><br><span class="line">        count++;</span><br><span class="line">        System.out.println(<span class="string">"Productor push(): "</span> + count);</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">10</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> buf = count;</span><br><span class="line">        <span class="keyword">if</span>(buf%<span class="number">2</span>==<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"Consumer pop(): "</span> + buf--);</span><br><span class="line">            count--;    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">10</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String... args)</span></span>&#123;</span><br><span class="line">        Product p = <span class="keyword">new</span> Product();</span><br><span class="line">        <span class="comment">//for(int i = 0; i &lt; 20; i++)&#123;</span></span><br><span class="line">            Thread consumer = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Consumer(p));</span><br><span class="line">            Thread productor = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Productor(p));</span><br><span class="line">            consumer.start();</span><br><span class="line">            productor.start();</span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line">        p.status = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="同步锁"><a href="#同步锁" class="headerlink" title="同步锁"></a>同步锁</h3><p>同步函数使用的锁是 <em>this</em>。</p><p>静态的同步函数使用的锁是该函数所属 <em>字节码文件对象</em> ，可以用 getClass()方法获取，也可以用 <em>当前类名.class</em>  表示。</p><p><strong>同步函数和同步代码块的区别：</strong></p><p>同步函数的锁是固定的this。</p><p>同步代码块的锁是任意的对象。</p><p>建议使用同步代码块。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ticket</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span>  <span class="keyword">int</span> num = <span class="number">100</span>;</span><br><span class="line"><span class="comment">//  Object obj = new Object();</span></span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"><span class="comment">//      System.out.println("this:"+this.getClass());</span></span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span>(flag)</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">synchronized</span>(Ticket.class)<span class="comment">//(this.getClass())</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(num&gt;<span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">try</span>&#123;Thread.sleep(<span class="number">10</span>);&#125;<span class="keyword">catch</span> (InterruptedException e)&#123;&#125;                     </span><br><span class="line">                        System.out.println(Thread.currentThread().getName()+<span class="string">".....obj...."</span>+num--);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)</span><br><span class="line">                <span class="keyword">this</span>.show();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span><span class="comment">//同步函数</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;Thread.sleep(<span class="number">10</span>);&#125;<span class="keyword">catch</span> (InterruptedException e)&#123;&#125;</span><br><span class="line">             </span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">".....function...."</span>+num--);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StaticSynFunctionLockDemo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Ticket t = <span class="keyword">new</span> Ticket();</span><br><span class="line"> </span><br><span class="line"><span class="comment">//      Class clazz = t.getClass();</span></span><br><span class="line"><span class="comment">//     </span></span><br><span class="line"><span class="comment">//      Class clazz = Ticket.class;</span></span><br><span class="line"><span class="comment">//      System.out.println("t:"+t.getClass());</span></span><br><span class="line"> </span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(t);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(t);</span><br><span class="line"> </span><br><span class="line">        t1.start();</span><br><span class="line">        <span class="keyword">try</span>&#123;Thread.sleep(<span class="number">10</span>);&#125;<span class="keyword">catch</span>(InterruptedException e)&#123;&#125;</span><br><span class="line">        t.flag = <span class="keyword">false</span>;</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>同步嵌套时，两个线程你拿了我的锁，我拿了你的锁，都不释放，造成死锁。</p><p><img src="/images/multi-thread/mthread3.png" alt="3"></p><p>一个死锁情况的例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Testa</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> flag;</span><br><span class="line">    Testa(<span class="keyword">boolean</span> flag) &#123;</span><br><span class="line">        <span class="keyword">this</span>.flag = flag;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)</span><br><span class="line">                <span class="keyword">synchronized</span> (MyLock.locka) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">"..if   locka...."</span>);</span><br><span class="line">                    <span class="keyword">synchronized</span> (MyLock.lockb) &#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">"..if   lockb...."</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)</span><br><span class="line">                <span class="keyword">synchronized</span> (MyLock.lockb) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">"..else  lockb...."</span>);</span><br><span class="line">                    <span class="keyword">synchronized</span> (MyLock.locka) &#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">"..else   locka...."</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLock</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Object locka = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Object lockb = <span class="keyword">new</span> Object();</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeadLockTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Testa a = <span class="keyword">new</span> Testa(<span class="keyword">true</span>);</span><br><span class="line">        Testa b = <span class="keyword">new</span> Testa(<span class="keyword">false</span>);</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(a);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(b);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线程间的通信"><a href="#线程间的通信" class="headerlink" title="线程间的通信"></a>线程间的通信</h2><h3 id="synchronized同步"><a href="#synchronized同步" class="headerlink" title="synchronized同步"></a>synchronized同步</h3><h3 id="while轮询"><a href="#while轮询" class="headerlink" title="while轮询"></a>while轮询</h3><h3 id="wait-notify机制"><a href="#wait-notify机制" class="headerlink" title="wait/notify机制"></a>wait/notify机制</h3><h3 id="管道通信"><a href="#管道通信" class="headerlink" title="管道通信"></a>管道通信</h3><h2 id="废话"><a href="#废话" class="headerlink" title="废话"></a>废话</h2><blockquote><p>针对多线程使用的变量如果不是volatile或者final修饰的，很有可能产生不可预知的结果（另一个线程修改了这个值，但是之后在某线程看到的是修改之前的值）。其实道理上讲同一实例的同一属性本身只有一个副本。但是多线程是会缓存值的，本质上，volatile就是不去缓存，直接取值。在线程安全的情况下加volatile会牺牲性能。</p></blockquote><h2 id="各个类与接口之间关系图（引用自SayNight的一篇文章）"><a href="#各个类与接口之间关系图（引用自SayNight的一篇文章）" class="headerlink" title="各个类与接口之间关系图（引用自SayNight的一篇文章）"></a>各个类与接口之间关系图（引用自<a href="https://github.com/SayNight/Document/tree/master/java/image" target="_blank" rel="noopener">SayNight</a>的一篇文章）</h2><p><img src="/images/multi-thread/mthread2.png" alt="2"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;java多线程&quot;&gt;&lt;a href=&quot;#java多线程&quot; class=&quot;headerlink&quot; title=&quot;java多线程&quot;&gt;&lt;/a&gt;java多线程&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;线程，是程序执行的最小单元（进程是基本单位）。&lt;/p&gt;
&lt;/blockqu
      
    
    </summary>
    
    
      <category term="java" scheme="http://dcLunatic.github.io/tags/java/"/>
    
      <category term="多线程" scheme="http://dcLunatic.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java函数式接口——转</title>
    <link href="http://dcLunatic.github.io/2018/09/21/Java%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3/"/>
    <id>http://dcLunatic.github.io/2018/09/21/Java函数式接口/</id>
    <published>2018-09-21T05:30:14.000Z</published>
    <updated>2018-09-21T05:32:04.294Z</updated>
    
    <content type="html"><![CDATA[<h1 id="转-深入学习Java8中的函数式接口-——出自www-sohu-com-a-123958799-465959"><a href="#转-深入学习Java8中的函数式接口-——出自www-sohu-com-a-123958799-465959" class="headerlink" title="(转)深入学习Java8中的函数式接口                     ——出自www.sohu.com/a/123958799_465959"></a>(转)深入学习Java8中的函数式接口                     ——出自<a href="http://www.sohu.com/a/123958799_465959" target="_blank" rel="noopener">www.sohu.com/a/123958799_465959</a></h1><p>引言</p><p>目前由于系统已经全面切换为JDK8，所以有必要系统的了解一下Java8的一些新特性，以便后续在日常工作中可以使用一些高级特性来提高编程效率。</p><p>因为Java8引入了函数式接口，在java.util.function包含了几大类函数式接口声明。这里第一篇主要研究一下Function相关的接口。</p><p>FunctionalInterface注解</p><p>Java8的新引入，包含函数式的设计，接口都有@FunctionalInterface的注解。就像这个注解的注释说明一样，它注解在接口层面，且注解的接口要有且仅有一个抽象方法。具体就是说，注解在Inteface上，且interface里只能有一个抽象方法，可以有default方法。因为从语义上来讲，一个函数式接口需要通过一个<strong><em>逻辑上的</em></strong>方法表达一个单一函数。那理解这个单一就很重要了，单一不是说限制你一个interface里只有一个抽象方法，单是多个方法的其他方法需要是继承自Object的public方法，或者你要想绕过，就自己实现default。函数式接口自己本身一定是只有一个抽象方法。同时，如果是Object类的public方法，也是不允许的。官方的说明翻译如下：</p><p>如果一个接口I，I有一组抽象方法集合M，且这些方法都不是Object类的public签名方法，那么如果存在一个M中的方法m，满足：</p><p>m的签名是所有M中方法签名的子签名。</p><p>m对于M中的每个方法都是返回类型可替换的。 此时，接口I是一个函数式接口。</p><p>怎么理解，看几个例子。</p><p>比如：你声明一个接口：</p><p><img src="http://img.mp.itc.cn/upload/20170110/012b8c1a0bec4db3afcfb76918e6e6b8.png" alt="img"></p><p>这会编译错，编译器会告诉你<em>no target method</em>。而如果加一个方法：</p><p><img src="http://img.mp.itc.cn/upload/20170110/17f0153ea3594e029f27628f5668f6a2.png" alt="img"></p><p>这就OK了，一个函数式接口声明好了。再加一个呢？</p><p><img src="http://img.mp.itc.cn/upload/20170110/722584407a7d4fc49f9e451716d9cc52.png" alt="img"></p><p>不ok，明确说了只有一个抽象方法嘛。但是如果换一种函数签名：</p><p><img src="http://img.mp.itc.cn/upload/20170110/105552f28ea84e4c90accb2caca0ffde.png" alt="img"></p><p>错误依旧，因为这个方法签名是Object类的public方法。而再改一下：</p><p><img src="http://img.mp.itc.cn/upload/20170110/79b8592fa5154590a183291f2e7ebc54.png" alt="img"></p><p>这就OK了。一个抽象方法，一个Object的public方法，相安无事。Object还有其他方法，clone方法试试会怎么样？</p><p><img src="http://img.mp.itc.cn/upload/20170110/597231984d374d27aa0fbf111f8614ee.png" alt="img"></p><p>这又不行了，因为前面明确说了，要是Object的public方法，而clone是protected的。</p><p>所以总结一句话就是：</p><p>函数式接口，有且仅有一个抽象方法，Object的public方法除外。</p><p>因为Java本身支持多接口实现，你定义一个Class可以implements多个interface。所以这个限制也没什么影响，如果想约定一个函数式接口来统一，也可以做一些默认的实现来达到一个接口多个抽象方法的目的，比如下面这种做法：</p><p>一个普通接口NonFunc：</p><p><img src="http://img.mp.itc.cn/upload/20170110/5f0d5bec5cb3454884607dfb0c430053.png" alt="img"></p><p>函数式接口Func：</p><p><img src="http://img.mp.itc.cn/upload/20170110/a99073f1579d4735acc9e7e595a20ed0_th.png" alt="img"></p><p>实现的测试类：</p><p><img src="http://img.mp.itc.cn/upload/20170110/cd04c58b20d34c29a9a60c74c7f8dc2b_th.jpeg" alt="img"></p><p>函数式接口的一大特性就是可以被lambda表达式和函数引用表达式代替。也就是说声明这样的接口，是可以灵活的以方法来传参。看个例子：</p><p><img src="http://img.mp.itc.cn/upload/20170110/5961eaa7b65d469aa04ae67a2b81b88b_th.jpeg" alt="img"></p><p>上面例子列举了一个lambda模式和一个方法引用模式，这样就可以利用函数式编程强大的能力，将方法作为参数了。</p><p>另一个大的话题是针对上文的<strong><em>逻辑上的方法</em></strong>。所谓逻辑上，就是说当你出现函数式接口多重继承其他接口时，如果继承的多个接口有相同的方法签名，那么也是OK的。而这种相同签名的方法，也包括了泛型的情况，以下的声明中的Z接口，都是函数式接口。</p><p><img src="http://img.mp.itc.cn/upload/20170110/0dc3e1f4871a4aa7bc7082c4802b9a35.png" alt="img"></p><p>但是要注意的是，这种泛型的支持，是因为函数式接口的官方声明规范里要求类型可替换和子签名，不是因为泛型擦除。</p><p>比如下面的例子就不是函数式接口：</p><p><img src="http://img.mp.itc.cn/upload/20170110/ba47c313487c47a3bcfafc498be7bc62.jpeg" alt="img"></p><p>最后，Java8里关于函数式接口的包是java.util.function，里面全部是函数式接口。主要包含几大类：Function、Predicate、Supplier、Consumer和*Operator（没有Operator接口，只有类似BinaryOperator这样的接口）。后面依次展开详细说明一下。</p><p><strong>Function</strong></p><p>关于Function接口，其接口声明是一个函数式接口，其抽象表达函数为</p><p><img src="http://img.mp.itc.cn/upload/20170110/ff5302c5d96348c88d35587658b13fd2.png" alt="img"></p><p>函数意为将参数T传递给一个函数，返回R。即$R=Function(T)$</p><p>其默认实现了3个default方法，分别是compose、andThen和identity，对应的函数表达为：compose对应$V=Function(ParamFunction(T))$，体现嵌套关系；andThen对应$V=ParamFunction(Function(T))$，转换了嵌套的顺序；还有identity对应了一个传递自身的函数调用对应$Function(T)=T$。从这里看出来，compose和andThen对于两个函数f和g来说，f.compose(g)等价于g.andThen(f)。看个例子：</p><p><img src="http://img.mp.itc.cn/upload/20170110/54749aa942fd4ae9b52910a5f9b2e5b6.jpeg" alt="img"></p><p><strong>高阶函数</strong></p><p>只是普通的lambda表达式，其能力有限。我们会希望引入更强大的函数能力——高阶函数，可以定义任意同类计算的函数。</p><p>比如这个函数定义，参数是z，返回值是一个Function，这个Function本身又接受另一个参数y，返回z+y。于是我们可以根据这个函数，定义任意加法函数：</p><p><img src="http://img.mp.itc.cn/upload/20170110/ac75024f4a1d49f79402c23628742072.jpeg" alt="img"></p><p>由于高阶函数接受一个函数作为参数，结果返回另一个函数，所以是典型的函数到函数的映射。</p><p>BiFunction提供了二元函数的一个接口声明，举例来说：</p><p><img src="http://img.mp.itc.cn/upload/20170110/197523ac84f347bb9b911e6976b8927d.png" alt="img"></p><p>其输出结果将是：f(z)=x*y, when x=3,y=5, then f(z)=15。</p><p>二元函数没有compose能力，只是默认实现了andThen。</p><p>有了一元和二元函数，那么可以通过组合扩展出更多的函数可能。</p><p>Function接口相关的接口包括：</p><p>BiFunction ：R apply(T t, U u);接受两个参数，返回一个值，代表一个二元函数；</p><p>DoubleFunction ：R apply(double value);只处理double类型的一元函数；</p><p>IntFunction ：R apply(int value);只处理int参数的一元函数；</p><p>LongFunction ：R apply(long value);只处理long参数的一元函数；</p><p>ToDoubleFunction：double applyAsDouble(T value);返回double的一元函数；</p><p>ToDoubleBiFunction：double applyAsDouble(T t, U u);返回double的二元函数；</p><p>ToIntFunction：int applyAsInt(T value);返回int的一元函数；</p><p>ToIntBiFunction：int applyAsInt(T t, U u);返回int的二元函数；</p><p>ToLongFunction：long applyAsLong(T value);返回long的一元函数；</p><p>ToLongBiFunction：long applyAsLong(T t, U u);返回long的二元函数；</p><p>DoubleToIntFunction：int applyAsInt(double value);接受double返回int的一元函数；</p><p>DoubleToLongFunction：long applyAsLong(double value);接受double返回long的一元函数；</p><p>IntToDoubleFunction：double applyAsDouble(int value);接受int返回double的一元函数；</p><p>IntToLongFunction：long applyAsLong(int value);接受int返回long的一元函数；</p><p>LongToDoubleFunction：double applyAsDouble(long value);接受long返回double的一元函数；</p><p>LongToIntFunction：int applyAsInt(long value);接受long返回int的一元函数；</p><p><strong>Operator</strong></p><p>Operator其实就是Function，函数有时候也叫作算子。算子在Java8中接口描述更像是函数的补充，和上面的很多类型映射型函数类似。</p><p>算子Operator包括：UnaryOperator和BinaryOperator。分别对应单元算子和二元算子。</p><p>算子的接口声明如下：</p><p><img src="http://img.mp.itc.cn/upload/20170110/be923310193e40a8a79646a56637b151.png" alt="img"></p><p>二元算子的声明：</p><p><img src="http://img.mp.itc.cn/upload/20170110/ccc7c75d5f854cfb9c9768830a46775b_th.jpeg" alt="img"></p><p>很明显，算子就是一个针对同类型输入输出的一个映射。在此接口下，只需声明一个泛型参数T即可。对应上面的例子：</p><p><img src="http://img.mp.itc.cn/upload/20170110/bbab03dd95824b719dfdfecf6f91d8d1_th.jpeg" alt="img"></p><p>例子里补充一点的是，BinaryOperator提供了两个默认的static快捷实现，帮助实现二元函数min(x,y)和max(x,y)，使用时注意的是排序器可别传反了：）</p><p>其他的Operator接口：（不解释了）</p><p>LongUnaryOperator：long applyAsLong(long operand);</p><p>IntUnaryOperator：int applyAsInt(int operand);</p><p>DoubleUnaryOperator：double applyAsDouble(double operand);</p><p>DoubleBinaryOperator：double applyAsDouble(double left, double right);</p><p>IntBinaryOperator：int applyAsInt(int left, int right);</p><p>LongBinaryOperator：long applyAsLong(long left, long right);</p><p><strong>Predicate</strong></p><p>predicate是一个谓词函数，主要作为一个谓词演算推导真假值存在，其意义在于帮助开发一些返回bool值的Function。本质上也是一个单元函数接口，其抽象方法test接受一个泛型参数T，返回一个boolean值。等价于一个Function的boolean型返回值的子集。</p><p><img src="http://img.mp.itc.cn/upload/20170110/dd98482e6b78438e960e12c6e206f13e.png" alt="img"></p><p>其默认方法也封装了and、or和negate逻辑。写个小例子看看：</p><p><img src="http://img.mp.itc.cn/upload/20170110/7839cfba31a54de49d6e8bda8202b389_th.jpeg" alt="img"></p><p>Predicate在Stream中有应用，Stream的filter方法就是接受Predicate作为入参的。这个具体在后面使用Stream的时候再分析深入。</p><p>其他Predicate接口：</p><p>BiPredicate：boolean test(T t, U u);接受两个参数的二元谓词</p><p>DoublePredicate：boolean test(double value);入参为double的谓词函数</p><p>IntPredicate：boolean test(int value);入参为int的谓词函数</p><p>LongPredicate：boolean test(long value);入参为long的谓词函数</p><p><strong>Consumer</strong></p><p>看名字就可以想到，这像谓词函数接口一样，也是一个Function接口的特殊表达——接受一个泛型参数，不需要返回值的函数接口。</p><p><img src="http://img.mp.itc.cn/upload/20170110/289a5e7cfca14ea1911d8b691c7a5042.png" alt="img"></p><p>这个接口声明太重要了，对于一些纯粹consume型的函数，没有Consumer的定义真无法被Function家族的函数接口表达。因为Function一定需要一个泛型参数作为返回值类型（当然不排除你使用Function来定义，但是一直返回一个无用的值）。比如下面的例子，如果没有Consumer，类似的行为使用Function表达就一定需要一个返回值。</p><p><img src="http://img.mp.itc.cn/upload/20170110/302f866e17104aee80e42c8b20053674_th.png" alt="img"></p><p>其他Consumer接口：</p><p>BiConsumer：void accept(T t, U u);接受两个参数</p><p>DoubleConsumer：void accept(double value);接受一个double参数</p><p>IntConsumer：void accept(int value);接受一个int参数</p><p>LongConsumer：void accept(long value);接受一个long参数</p><p>ObjDoubleConsumer：void accept(T t, double value);接受一个泛型参数一个double参数</p><p>ObjIntConsumer：void accept(T t, int value);接受一个泛型参数一个int参数</p><p>ObjLongConsumer：void accept(T t, long value);接受一个泛型参数一个long参数</p><p><strong>Supplier</strong></p><p>最后说的是一个叫做Supplier的函数接口，其声明如下：</p><p><img src="http://img.mp.itc.cn/upload/20170110/ecc9f0ea65584d2bbf55e0bf0c75f7ad.png" alt="img"></p><p>其简洁的声明，会让人以为不是函数。这个抽象方法的声明，同Consumer相反，是一个只声明了返回值，不需要参数的函数（这还叫函数？）。也就是说Supplier其实表达的不是从一个参数空间到结果空间的映射能力，而是表达一种生成能力，因为我们常见的场景中不止是要consume（Consumer）或者是简单的map（Function），还包括了new这个动作。而Supplier就表达了这种能力。</p><p>比如你要是返回一个常量，那可以使用类似的做法：</p><p>这保证supplier对象输出的一直是1。</p><p>如果是要利用构造函数的能力呢？就可以这样：</p><p><img src="http://img.mp.itc.cn/upload/20170110/4281b4926d2c47c3900d69a9e128cd37.png" alt="img"></p><p>这样的输出可以看到，全部的对象都是new出来的。</p><p>这样的场景在Stream计算中会经常用到，具体在分析Java 8中Stream的时候再深入。</p><p>其他Supplier接口：</p><p>BooleanSupplier：boolean getAsBoolean();返回boolean</p><p>DoubleSupplier：double getAsDouble();返回double</p><p>IntSupplier：int getAsInt();返回int</p><p>LongSupplier：long getAsLong();返回long</p><p><strong>总结</strong></p><p>整个函数式接口的大概总结如下：</p><p><img src="http://img.mp.itc.cn/upload/20170110/a2628994ebda43eca98c787a8b2577ba_th.jpeg" alt="img"></p><p><strong>-END-</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;转-深入学习Java8中的函数式接口-——出自www-sohu-com-a-123958799-465959&quot;&gt;&lt;a href=&quot;#转-深入学习Java8中的函数式接口-——出自www-sohu-com-a-123958799-465959&quot; class=&quot;hea
      
    
    </summary>
    
    
      <category term="java" scheme="http://dcLunatic.github.io/tags/java/"/>
    
      <category term="函数式接口" scheme="http://dcLunatic.github.io/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>ngrok简单使用</title>
    <link href="http://dcLunatic.github.io/2018/09/21/ngrok%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
    <id>http://dcLunatic.github.io/2018/09/21/ngrok简单使用/</id>
    <published>2018-09-21T05:26:37.000Z</published>
    <updated>2018-09-21T05:29:23.944Z</updated>
    
    <content type="html"><![CDATA[<h1 id="内网穿透–ngrok的简单使用"><a href="#内网穿透–ngrok的简单使用" class="headerlink" title="内网穿透–ngrok的简单使用"></a>内网穿透–ngrok的简单使用</h1><h2 id="下载ngrok"><a href="#下载ngrok" class="headerlink" title="下载ngrok"></a>下载ngrok</h2><p><a href="https://ngrok.com/download" target="_blank" rel="noopener">https://ngrok.com/download</a></p><p>下载一个符合自己操作系统版本的ngrok</p><h2 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h2><p>linux下的话，unzip /path/to/ngrok.zip</p><h2 id="设置authtoken"><a href="#设置authtoken" class="headerlink" title="设置authtoken"></a>设置authtoken</h2><p>访问<a href="https://dashboard.ngrok.com/auth来获得你的authtoken" target="_blank" rel="noopener">https://dashboard.ngrok.com/auth来获得你的authtoken</a></p><p>然后到对应的目录下，运行</p><p><code>./ngrok authtoken &lt;YOUR_AUTH_TOKEN&gt;</code></p><h2 id="启用"><a href="#启用" class="headerlink" title="启用"></a>启用</h2><p><code>./ngrok http 80</code>穿透映射到80端口</p><p>可以看到以下运行结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ngrok by @inconshreveable                                       (Ctrl+C to quit)</span><br><span class="line">                                                                                </span><br><span class="line">Session Status                online                                            </span><br><span class="line">Account                       dcLunatic (Plan: Free)                            </span><br><span class="line">Version                       2.2.8                                             </span><br><span class="line">Region                        United States (us)                                </span><br><span class="line">Web Interface                 http://127.0.0.1:4040                             </span><br><span class="line">Forwarding                    http://14ac334c.ngrok.io -&gt; localhost:80          </span><br><span class="line">Forwarding                    https://14ac334c.ngrok.io -&gt; localhost:80         </span><br><span class="line">                                                                                </span><br><span class="line">Connections                   ttl     opn     rt1     rt5     p50     p90       </span><br><span class="line">                              0       0       0.00    0.00    0.00    0.00</span><br></pre></td></tr></table></figure><p>访问<code>http://14ac334c.ngrok.io</code>即可</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;内网穿透–ngrok的简单使用&quot;&gt;&lt;a href=&quot;#内网穿透–ngrok的简单使用&quot; class=&quot;headerlink&quot; title=&quot;内网穿透–ngrok的简单使用&quot;&gt;&lt;/a&gt;内网穿透–ngrok的简单使用&lt;/h1&gt;&lt;h2 id=&quot;下载ngrok&quot;&gt;&lt;a h
      
    
    </summary>
    
    
      <category term="内网穿透" scheme="http://dcLunatic.github.io/tags/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"/>
    
      <category term="ngrok" scheme="http://dcLunatic.github.io/tags/ngrok/"/>
    
  </entry>
  
  <entry>
    <title>内网穿透——转</title>
    <link href="http://dcLunatic.github.io/2018/09/21/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E2%80%94%E2%80%94%E8%BD%AC/"/>
    <id>http://dcLunatic.github.io/2018/09/21/内网穿透——转/</id>
    <published>2018-09-21T05:25:39.000Z</published>
    <updated>2018-09-21T05:29:46.930Z</updated>
    
    <content type="html"><![CDATA[<h1 id="转-一分钟实现内网穿透（ngrok服务器搭建）"><a href="#转-一分钟实现内网穿透（ngrok服务器搭建）" class="headerlink" title="(转)一分钟实现内网穿透（ngrok服务器搭建）"></a>(转)一分钟实现内网穿透（ngrok服务器搭建）</h1><blockquote><p>忘记了这篇文章是从哪儿转载的了，如果作者有看到，请下方联系留言谢谢。</p></blockquote><p><strong>简单来说内网穿透的目的是：让外网能访问你本地的应用，例如在外网打开你本地<a href="http://127.0.0.1指向的Web站点。" target="_blank" rel="noopener">http://127.0.0.1指向的Web站点。</a></strong></p><p>最近公司的花生壳到期了，要续费，发现价格一直在涨，都是5年以上的老用户，旗舰版都没有实现内网完全穿透，打算自己动手替换这个服务，中间走了不少的弯路，这里记录一些文字为大家提供参考。</p><p>随着开发与运行移动互联网的应用越来越多对打通内外网的需要也更加迫切，如微信开发、IOS与Android开发等。</p><p>虽然租用VPS、ECS等服务器可以解决很多问题但高性能的外网服务器价格非常贵还有数据安全问题，我选择的是公网服务器仅做代理与轻量应用，复杂的应用部署到内网服务器再穿透访问。</p><h1 id="一、内网穿透概要"><a href="#一、内网穿透概要" class="headerlink" title="一、内网穿透概要"></a>一、内网穿透概要</h1><p>为了理解内网穿透我们先来了解几个概念：</p><h2 id="1-1、IP地址"><a href="#1-1、IP地址" class="headerlink" title="1.1、IP地址"></a>1.1、IP地址</h2><p>网络中唯一定位一台设备的逻辑地址，类似我们的电话号码</p><p>在互联网中我们访问一个网站或使用一个网络服务最终都需要通过IP定位到每一台主机，如访问baidu网站：</p><p><img src="http://images2017.cnblogs.com/blog/63651/201709/63651-20170903170722046-1051742415.png" alt="img"></p><p>其中119.75.213.61就是一个公网的IP地址，他最终指向了一台服务器。</p><p>IP地址是IP协议提供的一种统一的地址格式，它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。</p><p>内网IP可以同时出现在多个不同的局域网络中，如A公司的U1用户获得了192.168.0.5，B公司的U3用户也可以获得192.168.0.5；但公网IP是唯一的，因为我们只有一个Internet。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//局域网可使用的网段（私网地址段）有三大段：</span><br><span class="line">10.0.0.0~10.255.255.255（A类）</span><br><span class="line">172.16.0.0~172.31.255.255（B类）</span><br><span class="line">192.168.0.0~192.168.255.255（C类）</span><br></pre></td></tr></table></figure><h2 id="1-2、域名"><a href="#1-2、域名" class="headerlink" title="1.2、域名"></a>1.2、域名</h2><p>域名是IP的别名，便于记忆，域名最终通过DNS解析成IP地址。</p><p><img src="http://images2017.cnblogs.com/blog/63651/201709/63651-20170903220051733-158569545.png" alt="img"></p><p>IP V4是一个32位的数字，IP V6有128位，要记住一串毫无意义的数字非常困难，域名解决了这个问题。</p><p>如<a href="http://www.zhangguo.com.cn就是一个域名，cn表示地区，com表示商业机构，zhangguo是公司名称，www是主机名" target="_blank" rel="noopener">www.zhangguo.com.cn就是一个域名，cn表示地区，com表示商业机构，zhangguo是公司名称，www是主机名</a></p><p><img src="http://images2017.cnblogs.com/blog/63651/201709/63651-20170903172918812-661389359.png" alt="img"></p><p>DNS查询过程如下，最终将域名变成IP地址</p><p><img src="http://images2017.cnblogs.com/blog/63651/201709/63651-20170903172617749-201355603.png" alt="img"></p><h2 id="1-3、NAT"><a href="#1-3、NAT" class="headerlink" title="1.3、NAT"></a>1.3、NAT</h2><p>NAT（Network Address Translation）即网络地址转换，NAT能将其本地地址转换成全球IP地址。</p><p>内网的一些主机本来已经分配到了本地IP地址（如局域网DHCP分配的IP），但现在又想和因特网上的主机通信（并不需要加密）时，可使用NAT方法。</p><p>通过使用少量的公有IP 地址代表较多的私有IP 地址的方式，将有助于减缓可用的IP地址空间的枯竭。</p><p>NAT不仅能解决了lP地址不足与共享上网的问题，而且还能够有效地避免来自网络外部的攻击，隐藏并保护网络内部的计算机。</p><p>多路由器可完成NAT功能。</p><p>NAT的实现方式：</p><p><strong>静态转换</strong>是指将内部网络的私有IP地址转换为公有IP地址，IP地址对是一对一。</p><p><strong>动态转换</strong>是指将内部网络的私有IP地址转换为公用IP地址时，IP地址是不确定的，是随机的。</p><p><strong>端口多路复用</strong>（Port address Translation,PAT)，内部网络的所有主机均可共享一个合法外部IP地址实现对Internet的访问，从而可以最大限度地节约IP地址资源。同时又可隐藏网络内部的所有主机，有效避免来自internet的攻击。因此，目前网络中应用最多的就是端口多路复用方式。</p><p><strong>应用程序级网关技术</strong>（Application Level Gateway）ALG：传统的NAT技术只对IP层和传输层头部进行转换处理，ALG它能对这些应用程序在通信时所包含的地址信息也进行相应的NAT转换。</p><p><img src="http://images2017.cnblogs.com/blog/63651/201709/63651-20170903180507983-878090856.png" alt="img"></p><p><img src="http://images2017.cnblogs.com/blog/63651/201709/63651-20170903180820046-1185506268.png" alt="img"></p><h2 id="1-4、Proxy"><a href="#1-4、Proxy" class="headerlink" title="1.4、Proxy"></a>1.4、Proxy</h2><p>Proxy即代理，被广泛应用于计算机领域，主要分为正向代理与反向代理：</p><h3 id="1-4-1、正向代理"><a href="#1-4-1、正向代理" class="headerlink" title="1.4.1、正向代理"></a>1.4.1、正向代理</h3><p>比如X花店代A,B,C,D,E五位男生向Candy女生送匿名的生日鲜花，这里的X花店就是5位顾客的代理，花店代理的是客户，隐藏的是客户。这就是我们常说的代理。</p><p>正向代理隐藏了真实的请求客户端。服务端不知道真实的客户端是谁，客户端请求的服务都被代理服务器代替来请求，某些科学上网工具扮演的就是典型的正向代理角色。用浏览器访问<a href="http://www.google.com时被墙了，于是你可以在国外搭建一台代理服务器，让代理帮我去请求google.com，代理把请求返回的相应结构再返回给我。" target="_blank" rel="noopener">http://www.google.com时被墙了，于是你可以在国外搭建一台代理服务器，让代理帮我去请求google.com，代理把请求返回的相应结构再返回给我。</a></p><p><img src="http://images2017.cnblogs.com/blog/63651/201709/63651-20170903203834015-540568079.png" alt="img"></p><p>当多个客户端访问服务器时服务器不知道真正访问自己的客户端是那一台。正向代理中,proxy和client同属一个LAN,对server透明;</p><p><img src="http://images2017.cnblogs.com/blog/63651/201709/63651-20170903203855702-1545660519.png" alt="img"></p><h3 id="1-4-2、反向代理"><a href="#1-4-2、反向代理" class="headerlink" title="1.4.2、反向代理"></a>1.4.2、反向代理</h3><p>拨打10086客服电话，接线员可能有很多个，调度器会智能的分配一个接线员与你通话。这里的调度器就是一个代理，只不过他代理的是接线员，客户端不能确定真正与自己通话的人，隐藏与保护的是目标对象。</p><p>反向代理隐藏了真实的服务端，当我们请求 ww.baidu.com 的时候，就像拨打10086一样，背后可能有成千上万台服务器为我们服务，但具体是哪一台，你不知道，也不需要知道，你只需要知道反向代理服务器是谁就好了，ww.baidu.com 就是我们的反向代理服务器，反向代理服务器会帮我们把请求转发到真实的服务器那里去。Nginx就是性能非常好的反向代理服务器，用来做负载均衡。</p><p><img src="http://images2017.cnblogs.com/blog/63651/201709/63651-20170903215407530-525466235.png" alt="img"></p><p>反向代理中,proxy和server同属一个LAN,对client透明。</p><p><img src="http://images2017.cnblogs.com/blog/63651/201709/63651-20170903215437624-924164745.png" alt="img"></p><p><a href="https://www.zhihu.com/question/24723688" target="_blank" rel="noopener">了解更多关于代理内容请点击这里</a>。</p><h2 id="1-5、DDNS"><a href="#1-5、DDNS" class="headerlink" title="1.5、DDNS"></a>1.5、DDNS</h2><p>DDNS即动态域名解析，是将用户的动态IP地址映射到一个固定的域名解析服务上，用户每次连接网络的时候，客户端程序就会通过信息传递把该主机的动态IP地址传送给位于服务商主机上的服务器程序，服务程序负责提供DNS服务并实现动态域名解析。就是说DDNS捕获用户每次变化的IP地址，然后将其与域名相对应，这样域名就可以始终解析到非固定IP的服务器上，互联网用户通过本地的域名服务器获得网站域名的IP地址，从而可以访问网站的服务。</p><h2 id="1-6、为什么需要内网穿透"><a href="#1-6、为什么需要内网穿透" class="headerlink" title="1.6、为什么需要内网穿透"></a>1.6、为什么需要内网穿透</h2><p>当内网中的主机没有静态IP地址要被外网稳定访问时可以使用内网穿透</p><p>在互联网中唯一定位一台主机的方法是通过公网的IP地址，但固定IP是一种非常稀缺的资源，不可能给每个公司都分配一个，且许多中小公司不愿意为高昂的费用买单，多数公司直接或间接的拨号上网，电信部门会给接入网络的用户分配IP地址，以前上网用户少的时候基本分配的都是临时的静态IP地址，租约过了之后可能会更换成另一个IP地址，这样外网访问就不稳定，因为内网的静态IP地址一直变化，为了解决这个问题可以使用动态域名解析的办法变换域名指向的静态IP地址。但是现在越来越多的上网用户使得临时分配的静态IP地址也不够用了，电信部门开始分配一些虚拟的静态IP地址，这些IP是公网不能直接访问的，如以125开头的一些IP地址，以前单纯的动态域名解析就不好用了。</p><h2 id="1-7、内网穿透的定义与障碍"><a href="#1-7、内网穿透的定义与障碍" class="headerlink" title="1.7、内网穿透的定义与障碍"></a>1.7、内网穿透的定义与障碍</h2><p>简单来说实现不同局域网内的主机之间通过互联网进行通信的技术叫内网穿透。</p><p><strong>障碍一</strong>：位于局域网内的主机有两套 IP 地址，一套是局域网内的 IP 地址，通常是动态分配的，仅供局域网内的主机间通信使用；一套是经过网关转换后的外网 IP 地址，用于与外网程序进行通信。</p><p><img src="http://images2017.cnblogs.com/blog/63651/201709/63651-20170903222716265-734414443.png" alt="img"></p><p><strong>障碍二：</strong>位于不同局域网内的两台主机，即使是知道了对方的 IP 地址和端口号，“一厢情愿”地将数据包发送过去，对方也是接收不到的。</p><p>因为出于安全起见，除非是主机主动向对方发出了连接请求（这时会在该主机的数据结构中留下一条记录），否则，当主机接收到数据包时，如果在其数据结构中查询不到对应的记录，那些不请自来的数据包将会被丢弃。</p><p><img src="http://images2017.cnblogs.com/blog/63651/201709/63651-20170903222946327-630478233.png" alt="img"></p><p>解决办法：要想解决以上两大障碍，我们需要借助一台具有公网 IP 的服务器进行桥接。</p><h1 id="二、常见的内网穿透产品"><a href="#二、常见的内网穿透产品" class="headerlink" title="二、常见的内网穿透产品"></a>二、常见的内网穿透产品</h1><h2 id="2-1、花生壳"><a href="#2-1、花生壳" class="headerlink" title="2.1、花生壳"></a>2.1、花生壳</h2><p>花生壳既是内网穿透软件、内网映射软件,也是端口映射软件。规模最大，较正规，完善。</p><p>收费高，使用简单</p><p>官网：<a href="http://www.oray.com/" target="_blank" rel="noopener">http://www.oray.com/</a></p><p><img src="http://images2017.cnblogs.com/blog/63651/201709/63651-20170903223553296-127372763.png" alt="img"></p><h2 id="2-2、Nat123"><a href="#2-2、Nat123" class="headerlink" title="2.2、Nat123"></a>2.2、Nat123</h2><p>nat123是内网端口映射与动态域名解析软件，在内网启动映射后，可在外网访问连接内网网站等应用。整个网站我都没有找到客服电话，网友发了一些反面的评价</p><p>收费，使用简单</p><p>官网：<a href="http://www.nat123.com/" target="_blank" rel="noopener">http://www.nat123.com</a></p><p><img src="http://images2017.cnblogs.com/blog/63651/201709/63651-20170903224544358-530495055.png" alt="img"></p><h2 id="2-3、NATAPP"><a href="#2-3、NATAPP" class="headerlink" title="2.3、NATAPP"></a>2.3、NATAPP</h2><p>NATAPP基于ngrok的国内内网穿透服务，免费版会强制更换域名，临时用一下可以</p><p>收费，使用简单</p><p>官网：<a href="https://natapp.cn/" target="_blank" rel="noopener">https://natapp.cn/</a></p><p><img src="http://images2017.cnblogs.com/blog/63651/201709/63651-20170903230700515-51395586.png" alt="img"></p><h2 id="2-4、frp与其它"><a href="#2-4、frp与其它" class="headerlink" title="2.4、frp与其它"></a>2.4、frp与其它</h2><p>frp 是一个高性能的反向代理应用，可以帮助您轻松地进行内网穿透，对外网提供服务，支持 tcp, http, https 等协议类型，并且 web 服务支持根据域名进行路由转发。</p><p>开源免费</p><p>使用相对复杂，需要代理服务器支持</p><p>官网：<a href="https://github.com/fatedier/frp" target="_blank" rel="noopener">https://github.com/fatedier/frp</a></p><p>文档：<a href="http://www.cnblogs.com/%E6%9F%A5%E7%9C%8B%E5%B8%AE%E5%8A%A9%E6%96%87%E6%A1%A3" target="_blank" rel="noopener">查看帮助文档</a>，<a href="http://www.jianshu.com/p/e8e26bcc6fe6" target="_blank" rel="noopener">简书示例</a></p><p>利用处于内网或防火墙后的机器，对外网环境提供 http 或 https 服务。</p><p>对于 http, https 服务支持基于域名的虚拟主机，支持自定义域名绑定，使多个域名可以共用一个80端口。</p><p>利用处于内网或防火墙后的机器，对外网环境提供 tcp 和 udp 服务，例如在家里通过 ssh 访问处于公司内网环境内的主机。</p><p><img src="http://images2017.cnblogs.com/blog/63651/201709/63651-20170903230243390-1884154202.png" alt="img"></p><p>因为frp 仍然处于前期开发阶段，未经充分测试与验证，不推荐用于生产环境，所有我选择了ngrok，资料比较多。</p><p>还有如圣剑内网通、ngrok（开源免费）、<a href="https://post.smzdm.com/p/564494/" target="_blank" rel="noopener">更多办法</a></p><h1 id="三、ngrok"><a href="#三、ngrok" class="headerlink" title="三、ngrok"></a>三、ngrok</h1><p>ngrok是一个反向代理，通过在公共的端点和本地运行的Web服务器之间建立一个安全的通道。ngrok可捕获和分析所有通道上的流量，便于后期分析与响应。</p><p>开源免费</p><p>官网：<a href="https://ngrok.com/" target="_blank" rel="noopener">https://ngrok.com/</a></p><p>源码：<a href="https://github.com/inconshreveable/ngrok" target="_blank" rel="noopener">https://github.com/inconshreveable/ngrok</a></p><p><img src="http://images2017.cnblogs.com/blog/63651/201709/63651-20170903231759108-1604638644.png" alt="img"></p><p>ngrok1.x开源，ngrok2.x不开源</p><p>ngrok使用go语言开发，源代码分为客户端与服务器端。</p><p>国内免费服务器：<a href="http://ngrok.ciqiuwl.cn/" target="_blank" rel="noopener">http://ngrok.ciqiuwl.cn/</a>，更多免费服务器请大家挖掘，资源共享，我随时更新：）</p><p>如果有服务器，仅客户端的使用是不复杂的，以上面的免费服务器为示例完成内网穿透</p><p>现在假定我的本地已成功部署了一个网站，访问地址为127.0.0.1，想内网穿透后被公网上的用户访问，一般步骤如下：</p><p><strong>步骤1、下载windows版本的客户端，解压。一般在为你提供代理服务器的网站上找你要下载的客户端：</strong></p><p><img src="http://images2017.cnblogs.com/blog/63651/201709/63651-20170904074155741-1985350688.png" alt="img"></p><p><strong>步骤2、在命令（cmd）行下进入到ngrok客户端目录下</strong></p><p><img src="http://images2017.cnblogs.com/blog/63651/201709/63651-20170904074622538-2039616441.png" alt="img"></p><p><strong>步骤3、执行 ngrok -config=ngrok.cfg -subdomain xxx 80 //(xxx 是你自定义的域名前缀)，建议批处理</strong></p><p><img src="http://images2017.cnblogs.com/blog/63651/201709/63651-20170904074833194-727903866.png" alt="img"></p><p>如果连接成功，会提示如下信息：</p><p><img src="http://images2017.cnblogs.com/blog/63651/201709/63651-20170904075020679-5581075.png" alt="img"></p><p>这一步如果你认为太麻烦，可以直接运行目录下的start.bat批处理文件就不用进DOS环境了。运行start.bat直接跳过2，3步</p><p><strong>步骤4、如果开启成功 你就可以使用 xxx.ngrok.xiaomiqiu.cn 来访问你本机的 127.0.0.1:80 的服务了，当然你必须确定的是你本机的Web是可以正常访问的。</strong></p><p><img src="http://images2017.cnblogs.com/blog/63651/201709/63651-20170904075516819-714643885.png" alt="img"></p><p><strong>注意：</strong></p><p>如果你自己有顶级域名，想通过自己的域名来访问本机的项目，那么先将自己的顶级域名解析到120.25.161.137(域名需要已备案哦，80端口必须备案)，然后执行 ngrok -config=ngrok.cfg -hostname xxx.xxx.xxx 80 //(xxx.xxx.xxx是你自定义的顶级域名)</p><h1 id="四、ubuntu下生成ngrok服务器主程序"><a href="#四、ubuntu下生成ngrok服务器主程序" class="headerlink" title="四、ubuntu下生成ngrok服务器主程序"></a>四、ubuntu下生成ngrok服务器主程序</h1><h2 id="4-1、步骤与先决条件"><a href="#4-1、步骤与先决条件" class="headerlink" title="4.1、步骤与先决条件"></a>4.1、步骤与先决条件</h2><p>如果你只是临时穿透或调试用，到第三步基本就可以了，但如果想作为稳定的商业服务，用别人的服务器还是受制于人，这里我们准备搭建自己的ngrok服务器。大致的步骤如下：</p><p><img src="http://images2017.cnblogs.com/blog/63651/201709/63651-20170904091831007-845981599.png" alt="img"></p><p>ngrok服务器可以是多种平台，如windows、Linux（CentOS、Debian、Ubuntu等）、Mac OS等。</p><p><strong>编译源代码生成应用强烈建议大家使用linux环境，windows肯定可以成功，但非常麻烦，我在windows操作系统上兜了一个大圈圈。</strong></p><p><strong>先决条件：</strong></p><p>a)、您有一台公网上的服务器，如阿里云的ECS</p><p>b)、您有一个域名，最好ICP备案成功，不然80端口没有办法使用，不过像微信开发是不使用80端口的，可以用nginx代理转换。</p><h2 id="4-2、安装ubuntu操作系统"><a href="#4-2、安装ubuntu操作系统" class="headerlink" title="4.2、安装ubuntu操作系统"></a>4.2、安装ubuntu操作系统</h2><p>在linux环境下编译ngrok的源代码比windows下 方便很多，这里我们选择使用ubuntu，获得ubuntu的方法有如下几种：</p><p>1）、全新安装ubuntu系统</p><p>2）、申请VPS服务器， 阿里云、腾讯云、华为云、百度云、新浪云等，仅编译一下这种方法不错</p><p>3）、在虚拟机中安装ubuntu系统</p><p>综合考虑我选择了在虚拟机中安装ubuntu操作系统</p><p><img src="http://images2017.cnblogs.com/blog/63651/201709/63651-20170901231607218-263480294.png" alt="img"></p><h3 id="4-2-1、安装VMware虚拟机"><a href="#4-2-1、安装VMware虚拟机" class="headerlink" title="4.2.1、安装VMware虚拟机"></a>4.2.1、安装VMware虚拟机</h3><p>VMware Workstation是一款功能强大的虚拟机软件，在不影响本机操作系统的情况下，用户可以在虚拟机中同时运行不同版本的操作系统，用于开发、测试以及部署工作。</p><p>VMware Workstation 12 pro下载：<a href="https://download3.vmware.com/software/wkst/file/VMware-workstation-full-12.1.0-3272444.exe" target="_blank" rel="noopener">VMware-workstation-full-12.1.0-3272444.exe</a></p><p>序列号：5A02H-AU243-TZJ49-GTC7K-3C61N（商业应用请购买正式版权，这里仅为学习使用）</p><p>1）、双击VMware Workstation 12安装文件，或者右键管理员身份打开，提示是否允许更改，点击是；</p><p>2）、打开VMware安装向导，点击下一步；</p><p>　<img src="http://images2015.cnblogs.com/blog/665662/201609/665662-20160901095230340-1199843460.png" alt="技术分享"></p><p>3）、VMware Workstation 12激活步骤：</p><p>　　方法一、首次开启直接输入上文密钥，即可激活；<br>　　方法二、首次开启选择试用，进入试用后按一下步骤激活：</p><p>　　a、打开虚拟机主界面，点击“帮助”—“输入许可证密钥”；</p><p>　　<img src="http://images2015.cnblogs.com/blog/665662/201609/665662-20160901095741496-122939039.png" alt="技术分享"></p><p>　　b、在密钥输入框输入永久许可证密钥5A02H-AU243-TZJ49-GTC7K-3C61N，确定；<a href="http://www.mamicode.com/info-detail-1509515.html" target="_blank" rel="noopener">更多</a></p><h3 id="4-2-2、安装ubuntu到虚拟机"><a href="#4-2-2、安装ubuntu到虚拟机" class="headerlink" title="4.2.2、安装ubuntu到虚拟机"></a>4.2.2、安装ubuntu到虚拟机</h3><p><strong>1)、下载ubuntu操作系统镜像</strong></p><p>下载地址：<a href="https://www.ubuntu.com/download/desktop" target="_blank" rel="noopener">https://www.ubuntu.com/download/desktop</a></p><p>这里我下载的是ubuntu-16.04.3-desktop-amd64.iso</p><p><img src="http://images2017.cnblogs.com/blog/63651/201709/63651-20170904095831304-2034050308.png" alt="img"></p><p><strong>2)、在VMware中安装ubuntu</strong></p><p>打开VMware点击“创建新的虚拟机”</p><p><img src="http://images2017.cnblogs.com/blog/63651/201709/63651-20170904100150288-1332147180.png" alt="img"></p><p>向导选择自定义</p><p><img src="https://img-blog.csdn.net/20160116162359619" alt="这里写图片描述"></p><p>然后下一步再下一步，直到这里，稍后再安装系统</p><p><img src="https://img-blog.csdn.net/20160116165229845" alt="这里写图片描述"></p><p>后面设置处理器和内存的，电脑配置好的可以试试，否则采用默认的，博主这里是采用默认的，然后下一，直到这里，选择将虚拟机存储为单个磁盘：</p><p><img src="https://img-blog.csdn.net/20160116170122312" alt="这里写图片描述"></p><p>个人建议至少20G硬盘空间，内存建议给1.5G，当然也要看电脑本身的配置，1G的内存跑起来比较卡。</p><p>其它的步骤比较简单，更多细节可以参考这里，<a href="http://blog.csdn.net/u013142781/article/details/50529030" target="_blank" rel="noopener">《VMware Ubuntu安装详细过程》</a>。</p><h3 id="4-2-3、配置ubuntu系统"><a href="#4-2-3、配置ubuntu系统" class="headerlink" title="4.2.3、配置ubuntu系统"></a>4.2.3、配置ubuntu系统</h3><p>当ubuntu系统安装成功后，在虚拟机中可以启动ubuntu系统，启动后的系统如下：</p><p><img src="http://images2017.cnblogs.com/blog/63651/201709/63651-20170904101154476-1764294876.png" alt="img"></p><p>ubuntu系统的使用还是有许多内容的，这里需要设置的内容如下：</p><p><strong>a)、设置上网</strong></p><p>就是在ubuntu中可以访问外网，可以使用多种形式</p><p><img src="http://images2017.cnblogs.com/blog/63651/201709/63651-20170904101320163-1606868137.png" alt="img"></p><p><strong>b)、设置语言</strong></p><p>可以选择使用中文版的ubuntu语言环境</p><p><img src="http://images2017.cnblogs.com/blog/63651/201709/63651-20170904101834679-1277234633.png" alt="img"></p><p><strong>c)、设置屏幕分辨率</strong></p><p>如果不设置默认的屏幕比较小</p><p><img src="http://images2017.cnblogs.com/blog/63651/201709/63651-20170904102149054-1857013152.png" alt="img"></p><p><strong>d)、设置以root超级管理员的身份登录</strong></p><p>许多操作要求管理身份</p><p><img src="http://images2017.cnblogs.com/blog/63651/201709/63651-20170904102826538-1421210972.png" alt="img"></p><p><strong>e)、安装VMware Tools工具</strong></p><p>只有在VMware虚拟机中安装好了VMware Tools，才能实现主机与虚拟机之间的文件共享，同时可支持自由拖拽的功能，鼠标也可在虚拟机与主机之间自由移动（不用再按ctrl+alt），且虚拟机屏幕也可实现全屏化。<br>VMware Tools是VMware虚拟机中自带的一种增强工具，相当于VirtualBox中的增强功能（Sun VirtualBox Guest Additions），是VMware提供的增强虚拟显卡和硬盘性能、以及同步虚拟机与主机时钟的驱动程序。</p><p> <img src="http://images2017.cnblogs.com/blog/63651/201709/63651-20170904110228554-466046297.png" alt="img"></p><p>注意如果这里是灰色的需要您将linux.iso镜像加载到虚拟光驱中，一般在VM的安装目录下有，如果没有您需要自行下载。</p><p>说明：ubuntu的使用不是本文的重点，相关操作请大家自行查找。</p><h2 id="4-3、生成ngrok服务器与客户端应用程序"><a href="#4-3、生成ngrok服务器与客户端应用程序" class="headerlink" title="4.3、生成ngrok服务器与客户端应用程序"></a>4.3、生成ngrok服务器与客户端应用程序</h2><h3 id="4-3-1-导出源代码"><a href="#4-3-1-导出源代码" class="headerlink" title="4.3.1. 导出源代码"></a>4.3.1. 导出源代码</h3><p>ngrok的源代码托管在github上，可以先在ubuntu下安装git再将ngrok的源代码克隆到本地。</p><p><img src="http://images2017.cnblogs.com/blog/63651/201709/63651-20170904104430257-26581308.png" alt="img"></p><p>其实也可以直接下载到本地后解压，这里使用命令行完成。</p><p>启动ubuntu，开打命令行（终端），如下所示：</p><p><img src="http://images2017.cnblogs.com/blog/63651/201709/63651-20170904104218679-1537052551.png" alt="img"></p><p>以root身份执行如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mkdir ngrok #创建名称为ngrok的目录</span><br><span class="line"></span><br><span class="line">apt-get update #更新包管理器</span><br><span class="line"></span><br><span class="line">apt-get install git  #安装git</span><br><span class="line"></span><br><span class="line">git clone https://github.com/inconshreveable/ngrok.git ngrok2 #将ngrok源代码克隆回本地</span><br></pre></td></tr></table></figure><p>成功执行后如下所示：</p><p><img src="http://images2017.cnblogs.com/blog/63651/201709/63651-20170904105615835-1335450212.png" alt="img"></p><p>导出成功后的源代码：</p><p><img src="http://images2017.cnblogs.com/blog/63651/201709/63651-20170904105847351-1780908089.png" alt="img"></p><p>PS. 直接在服务器上下载的话实在太慢，可以先在本地下载好，然后用ftp放到服务器上去直接用，如果安装了VMware tools直接拖进去就可以了。</p><h3 id="4-3-2-安装Go语言开发环境"><a href="#4-3-2-安装Go语言开发环境" class="headerlink" title="4.3.2. 安装Go语言开发环境"></a>4.3.2. 安装Go语言开发环境</h3><p>直接在命令模式下执行如下指令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install golang #安装go语言</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><p><img src="http://images2017.cnblogs.com/blog/63651/201709/63651-20170904110813679-2025712360.png" alt="img"></p><h3 id="4-3-3-更改ngrok域名"><a href="#4-3-3-更改ngrok域名" class="headerlink" title="4.3.3. 更改ngrok域名"></a>4.3.3. 更改ngrok域名</h3><p>在自己的域名管理中添加解析A记录，如下所示：</p><p><img src="http://images2017.cnblogs.com/blog/63651/201709/63651-20170904112044444-141101928.png" alt="img"></p><p>将*.ngrok与ngrok都指向您的主机IP。</p><p>默认的域名是ngrok自己的，要替换成您自己的域名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export GOPATH=/usr/local/ngrok/  #设置环境变量，Go语言的安装位置</span><br><span class="line">export NGROK_DOMAIN=&quot;ngrok.yourdomain.com&quot;  #设置环境变量，ngrok域名</span><br></pre></td></tr></table></figure><p>PS. ngrok名称可以任意，推荐名称为ngrok或者tunnel </p><h3 id="4-3-4-为域名生成证书"><a href="#4-3-4-为域名生成证书" class="headerlink" title="4.3.4. 为域名生成证书"></a>4.3.4. 为域名生成证书</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">openssl genrsa -out rootCA.key 2048</span><br><span class="line">openssl req -x509 -new -nodes -key rootCA.key -subj &quot;/CN=$NGROK_DOMAIN&quot; -days 5000 -out rootCA.pem</span><br><span class="line">openssl genrsa -out server.key 2048</span><br><span class="line">openssl req -new -key server.key -subj &quot;/CN=$NGROK_DOMAIN&quot; -out server.csr</span><br><span class="line">openssl x509 -req -in server.csr -CA rootCA.pem -CAkey rootCA.key -CAcreateserial -out server.crt -days 5000</span><br></pre></td></tr></table></figure><p>生成后的结果如下：</p><p><img src="http://images2017.cnblogs.com/blog/63651/201709/63651-20170904112706007-1362500678.png" alt="img"></p><p>证书如下：</p><p><img src="http://images2017.cnblogs.com/blog/63651/201709/63651-20170904112841616-675146273.png" alt="img"></p><h3 id="4-3-5-拷贝证书到指定位置"><a href="#4-3-5-拷贝证书到指定位置" class="headerlink" title="4.3.5. 拷贝证书到指定位置"></a>4.3.5. 拷贝证书到指定位置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cp rootCA.pem assets/client/tls/ngrokroot.crt  #复制rootCA.pem到assets/client/tls/并更名为ngrokroot.crt</span><br><span class="line">cp server.crt assets/server/tls/snakeoil.crt #复制server.crt到assets/server/tls/并更名为snakeoil.crt</span><br><span class="line">cp server.key assets/server/tls/snakeoil.key #复制server.key到assets/server/tls/并更名为snakeoil.key</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="http://images2017.cnblogs.com/blog/63651/201709/63651-20170904113404319-181716920.png" alt="img"></p><h3 id="4-3-6-编译"><a href="#4-3-6-编译" class="headerlink" title="4.3.6. 编译"></a>4.3.6. 编译</h3><p> 由于go语言的特性，在编译时直接生成机器码，所以在运行过程中并不需要go的环境（非托管应用）。在ngrok目录下，运行一下命令分别生成对应的客户端与服务端。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#win服务端</span><br><span class="line">GOOS=windows GOARCH=386 make release-server </span><br><span class="line">#win客户端</span><br><span class="line">GOOS=windows GOARCH=386 make release-client</span><br><span class="line">#linux服务端</span><br><span class="line">GOOS=linux GOARCH=386 make release-server</span><br><span class="line">#linux客户端</span><br><span class="line">GOOS=linux GOARCH=386 make release-client</span><br></pre></td></tr></table></figure><p>生成完成后，在工作目录的bin文件夹下，产生对应的文件。以编译windows平台为例，会产生“ngrok.exe”与“ngrokd.exe”这两个文件，前者客户端，后者需要运行在公网服务器上。</p><p>因为项目中引用了一些外部资源，生成会耗费一些时间，对网络也有一定的要求，太慢会中短，命令执行下如：</p><p><img src="http://images2017.cnblogs.com/blog/63651/201709/63651-20170904121943022-153887904.png" alt="img"></p><p>生成结果：</p><p><img src="http://images2017.cnblogs.com/blog/63651/201709/63651-20170904122128351-799567752.png" alt="img"></p><p>这里我还生成了两个运行在windows服务器与客户端的应用：</p><p><img src="http://images2017.cnblogs.com/blog/63651/201709/63651-20170904122421788-2012822383.png" alt="img"></p><p>ngrok.exe是客户端，ngrokd.exe是服务端，下面是比较连续的操作结果。</p><p><img src="http://images2017.cnblogs.com/blog/63651/201709/63651-20170901231940155-475363716.png" alt="img"></p><p><img src="http://images2017.cnblogs.com/blog/63651/201709/63651-20170901232038108-311206220.png" alt="img"></p><h1 id="五、部署服务器端主程序"><a href="#五、部署服务器端主程序" class="headerlink" title="五、部署服务器端主程序"></a>五、部署服务器端主程序</h1><h2 id="5-1、部署到Windows-Server服务器"><a href="#5-1、部署到Windows-Server服务器" class="headerlink" title="5.1、部署到Windows Server服务器"></a>5.1、部署到Windows Server服务器</h2><p> 将生成的ngrokd.exe文件复制到windows服务器中，当然如果要部署到linux中也是没有问题的。</p><p>这里我将ngrokd.exe放在c:\grokeServer目录下：</p><p><img src="http://images2017.cnblogs.com/blog/63651/201709/63651-20170904122657647-1349116821.png" alt="img"></p><p>为了方便，我编写了一个批处理文件：ngrokserver2.bat</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ngrokd.exe -tlsKey=&quot;snakeoil.key&quot; -tlsCrt=&quot;snakeoil.crt&quot; -domain=&quot;ngrok.你的域名.com&quot; -httpAddr=&quot;:801&quot; -httpsAddr=&quot;:802&quot;</span><br></pre></td></tr></table></figure><p>点击批处理运行结果如下：</p><p><img src="http://images2017.cnblogs.com/blog/63651/201709/63651-20170904123813882-909153274.png" alt="img"></p><p>绑定的域名换成自己的域名，http使用801端口，https使用802端口，供客户端连接的管道端口设置为4443端口，必须前面的域名相同。</p><p>为了安全许多服务器会将端口屏蔽，我使用的是ECS服务器，默认801，802都是关闭的，需要手动开启，在阿里云的后台添加开放的端口就可了：</p><p><img src="http://images2017.cnblogs.com/blog/63651/201709/63651-20170901232916530-1378823649.png" alt="img"></p><h2 id="5-2、一键部署ngrok服务器（CentOS、Debian、Ubuntu）"><a href="#5-2、一键部署ngrok服务器（CentOS、Debian、Ubuntu）" class="headerlink" title="5.2、一键部署ngrok服务器（CentOS、Debian、Ubuntu）"></a>5.2、一键部署ngrok服务器（CentOS、Debian、Ubuntu）</h2><p>如果编译生成ngrok的源代码生成应用太麻烦，你可以选择网友写的工具，支持一键部署到安装平台：CentOS、Debian、Ubuntu。</p><p><a href="https://github.com/clangcn/ngrok-one-key-install" target="_blank" rel="noopener">https://github.com/clangcn/ngrok-one-key-install</a></p><h1 id="六、部署ngrok客户端"><a href="#六、部署ngrok客户端" class="headerlink" title="六、部署ngrok客户端"></a>六、部署ngrok客户端</h1><p>这里的客户端就是您的web应用程序所运行的主机，将ubuntu生成的ngrok.exe客户端应用复制到您的系统中：</p><p><img src="http://images2017.cnblogs.com/blog/63651/201709/63651-20170904124357101-756344082.png" alt="img"></p><p>添加配置文件ngrok.cfg:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">server_addr: &quot;ngrok.你的域名.com:4443&quot;</span><br><span class="line">trust_host_root_certs: false</span><br></pre></td></tr></table></figure><p> 添加批处理start.bat，如果只运行一次直接在命令行下输入命令也是一样的效果，内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ngrok.exe -subdomain kyt -config=ngrok.cfg 8987</span><br></pre></td></tr></table></figure><p>其中8987为端口号，运行成功的结果如下所示： </p><p><img src="http://images2017.cnblogs.com/blog/63651/201709/63651-20170901232646890-104118921.png" alt="img"></p><p>看到这个界面时说明已成功了。</p><h1 id="七、启动客户端并测试"><a href="#七、启动客户端并测试" class="headerlink" title="七、启动客户端并测试"></a>七、启动客户端并测试</h1><p>打开浏览器，输入您映射后的域名就可以穿透内网访问您的web服务器了。</p><p><img src="http://images2017.cnblogs.com/blog/63651/201709/63651-20170901233244765-547813455.png" alt="img"></p><h1 id="八、总结"><a href="#八、总结" class="headerlink" title="八、总结"></a>八、总结</h1><p>一开始选择错了平台，在windows花了不少时间，在ubuntu下顺利完成。</p><p>无论是客户端还是服务器端最好都做成服务，更方便与稳定。</p><p>由于服务器上同时运行着IIS，故服务端Ngrok启动时无法使用80端口，所以在上面，我使用了801作为Ngrok服务器的http端口，使用IIS的代理功能可以解决这个问题，<a href="http://www.it165.net/admin/html/201604/7486.html" target="_blank" rel="noopener">点击这里</a>。当然也可以使用nginx将80转换成其它端口。</p><p>许多内容都参考了网友的文章。</p><p><strong>如果服务器搭建好了，只运行客户端穿透内网一分钟够了：）。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;转-一分钟实现内网穿透（ngrok服务器搭建）&quot;&gt;&lt;a href=&quot;#转-一分钟实现内网穿透（ngrok服务器搭建）&quot; class=&quot;headerlink&quot; title=&quot;(转)一分钟实现内网穿透（ngrok服务器搭建）&quot;&gt;&lt;/a&gt;(转)一分钟实现内网穿透（ngr
      
    
    </summary>
    
    
      <category term="内网穿透" scheme="http://dcLunatic.github.io/tags/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>Java克隆</title>
    <link href="http://dcLunatic.github.io/2018/09/21/Java%E5%85%8B%E9%9A%86/"/>
    <id>http://dcLunatic.github.io/2018/09/21/Java克隆/</id>
    <published>2018-09-21T05:03:00.000Z</published>
    <updated>2018-09-21T05:04:26.417Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java中的Clone"><a href="#Java中的Clone" class="headerlink" title="Java中的Clone"></a>Java中的Clone</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>clone，顾名思义，就是复制克隆的意思，我们可以通过clone()方法，来获得一个相同的对象。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>如果我们自定义的类要可以被复制，那么类必须实现Cloneable中接clone()方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String... args)</span></span>&#123;</span><br><span class="line">        Test t1 = <span class="keyword">new</span> Test();</span><br><span class="line">        Test t2 = t1.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="深克隆与浅克隆"><a href="#深克隆与浅克隆" class="headerlink" title="深克隆与浅克隆"></a>深克隆与浅克隆</h2><p>但是呢，在java中，我们知道有一些对象是存放在栈区，一些是存放在堆中的，存放在堆中的对象，一般都是由一个在栈中的变量指向它的。</p><p>那么，当我们在调用clone()方法的时候，是在复制对象呢，还是复制它的引用呢？</p><p>假如我们把上面的代码修改一下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String... args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Test t1 = <span class="keyword">new</span> Test();</span><br><span class="line">        Test t2 = (Test)t1.clone();</span><br><span class="line">        System.out.println(<span class="string">"t1 == t2 ? "</span> + (t1.b == t2.b));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">public</span> String b;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">(<span class="keyword">int</span> a, String b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.a = a;</span><br><span class="line">        <span class="keyword">this</span>.b = b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行之后，结果是true，也就是说t1跟t2中的String对象b都是同一个。</p><p>而这是为什么呢</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java中的Clone&quot;&gt;&lt;a href=&quot;#Java中的Clone&quot; class=&quot;headerlink&quot; title=&quot;Java中的Clone&quot;&gt;&lt;/a&gt;Java中的Clone&lt;/h1&gt;&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;head
      
    
    </summary>
    
    
      <category term="java" scheme="http://dcLunatic.github.io/tags/java/"/>
    
      <category term="克隆" scheme="http://dcLunatic.github.io/tags/%E5%85%8B%E9%9A%86/"/>
    
  </entry>
  
  <entry>
    <title>Java字节和字符的区别</title>
    <link href="http://dcLunatic.github.io/2018/09/21/Java%E5%AD%97%E8%8A%82%E5%92%8C%E5%AD%97%E7%AC%A6%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://dcLunatic.github.io/2018/09/21/Java字节和字符的区别/</id>
    <published>2018-09-21T05:01:39.000Z</published>
    <updated>2018-09-21T05:02:40.137Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java中字符char与字节byte的区别"><a href="#Java中字符char与字节byte的区别" class="headerlink" title="Java中字符char与字节byte的区别"></a>Java中字符char与字节byte的区别</h1><h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>byte是字节数据类型，是有符号型的，占1个字节，大小范围是-128~127；而char是字符类型的，在java中，用2个字节的Unicode码来表示一个字符，是无符号类型的，自然的，范围是0~65535。</p><h2 id="区别与转换"><a href="#区别与转换" class="headerlink" title="区别与转换"></a>区别与转换</h2><ul><li><p>byte是有符号类型的，占8位；而char是无符号类型的，占16位。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> c = (<span class="keyword">char</span>) -<span class="number">3</span>; <span class="comment">// char不能识别负数，必须强制转换否则报错，即使强制转换之后，也无法识别  </span></span><br><span class="line">System.out.println(c);  </span><br><span class="line"><span class="keyword">byte</span> d1 = <span class="number">1</span>;  </span><br><span class="line"><span class="keyword">byte</span> d2 = -<span class="number">1</span>;  </span><br><span class="line"><span class="keyword">byte</span> d3 = <span class="number">127</span>; <span class="comment">// 如果是byte d3 = 128;会报错  </span></span><br><span class="line"><span class="keyword">byte</span> d4 = -<span class="number">128</span>; <span class="comment">// 如果是byte d4 = -129;会报错  </span></span><br><span class="line">System.out.println(d1);  </span><br><span class="line">System.out.println(d2);  </span><br><span class="line">System.out.println(d3);  </span><br><span class="line">System.out.println(d4);</span><br></pre></td></tr></table></figure><p><strong>结果：</strong><br>?<br>1<br>-1<br>127<br>-128</p></li><li><p>char可以表示中文字符，而byte不可以</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> e1 = <span class="string">'中'</span>, e2 = <span class="string">'国'</span>;  </span><br><span class="line"><span class="keyword">byte</span> f= (<span class="keyword">byte</span>) <span class="string">'中'</span>; <span class="comment">//必须强制转换否则报错  </span></span><br><span class="line">System.out.println(e1);  </span><br><span class="line">System.out.println(e2);  </span><br><span class="line">System.out.println(f);</span><br></pre></td></tr></table></figure><p><strong>结果：</strong><br>中<br>国<br>45</p></li></ul><ul><li><p>当char和byte都是英文字符时，可以相互转换。（对应的int类型也可以与之互相转换）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span> g = <span class="string">'b'</span>;   <span class="comment">//b对应ASCII是98  </span></span><br><span class="line"><span class="keyword">char</span> h = (<span class="keyword">char</span>) g;  </span><br><span class="line"><span class="keyword">char</span> i = <span class="number">85</span>;    <span class="comment">//U对应ASCII是85  </span></span><br><span class="line"><span class="keyword">int</span> j = <span class="string">'h'</span>;    <span class="comment">//h对应ASCII是104  </span></span><br><span class="line">System.out.println(g);  </span><br><span class="line">System.out.println(h);  </span><br><span class="line">System.out.println(i);  </span><br><span class="line">System.out.println(j);</span><br></pre></td></tr></table></figure><p><strong>结果：</strong></p><p>98</p><p>b</p><p>U</p><p>104</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java中字符char与字节byte的区别&quot;&gt;&lt;a href=&quot;#Java中字符char与字节byte的区别&quot; class=&quot;headerlink&quot; title=&quot;Java中字符char与字节byte的区别&quot;&gt;&lt;/a&gt;Java中字符char与字节byte的区别&lt;/
      
    
    </summary>
    
    
      <category term="java" scheme="http://dcLunatic.github.io/tags/java/"/>
    
      <category term="字节与字符的区别" scheme="http://dcLunatic.github.io/tags/%E5%AD%97%E8%8A%82%E4%B8%8E%E5%AD%97%E7%AC%A6%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    
  </entry>
  
  <entry>
    <title>Java IO性能分析</title>
    <link href="http://dcLunatic.github.io/2018/09/21/Java-IO%E5%88%86%E6%9E%90/"/>
    <id>http://dcLunatic.github.io/2018/09/21/Java-IO分析/</id>
    <published>2018-09-21T05:00:23.000Z</published>
    <updated>2018-09-21T05:01:13.578Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-IO性能分析"><a href="#Java-IO性能分析" class="headerlink" title="Java IO性能分析"></a>Java IO性能分析</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>程序中的IO操作可以说是很常见，很常见的，所以在IO操作这方面的性能就很有必要进行一些分析然后改进程序，IO操作非常容易导致性能的瓶颈。</p><p>本文主要涉及的是传统的IO(TIO)，少部分涉及到新型IO(NIO以及NIO2)，在分析方面，对要从对磁盘文件的读写进行分析，其他网络IO，窗口IO等不做过多的分析。</p><p>这里的IO基本都属于低级IO。</p><h2 id="TIO-分析"><a href="#TIO-分析" class="headerlink" title="TIO 分析"></a>TIO 分析</h2><h3 id="常规IO操作类型"><a href="#常规IO操作类型" class="headerlink" title="常规IO操作类型"></a>常规IO操作类型</h3><ol><li>使用单字节/字符进行读写，直接调用read() 和 write(int)方法</li><li>建立缓冲区，进行块读写，调用read(char/byte[] buf)和write(char/byte[] buf)等方法</li><li>使用io包中的缓冲读写类</li></ol><h3 id="耗时测试"><a href="#耗时测试" class="headerlink" title="耗时测试"></a>耗时测试</h3><blockquote><p>因为java的字符流类在底层进行字节读取后，再转换成字符返回，所以需要花费更多的时间，所以这里就不比较字符流中各个操作的差别了，差别类似于字节流的，而且会更加明显。</p></blockquote><p>先写一些工具方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WriteDataTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">generateByte</span><span class="params">(String filename, <span class="keyword">long</span> size)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(filename);</span><br><span class="line">        <span class="keyword">if</span>(!file.exists())</span><br><span class="line">            file.createNewFile();</span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(file);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">long</span> i = <span class="number">0</span>; i &lt; size; i++)&#123;</span><br><span class="line">            fos.write((<span class="keyword">int</span>)(Math.random()*<span class="number">128</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        fos.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">generateBytes</span><span class="params">(String filename, <span class="keyword">long</span> size, <span class="keyword">int</span> byteSize)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(filename);</span><br><span class="line">        <span class="keyword">if</span>(!file.exists())</span><br><span class="line">            file.createNewFile();</span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(file);</span><br><span class="line">        <span class="keyword">if</span>(byteSize &lt; <span class="number">1</span>)</span><br><span class="line">            byteSize = <span class="number">512</span>;</span><br><span class="line">        <span class="keyword">if</span>(byteSize &gt; size)</span><br><span class="line">            byteSize = (<span class="keyword">int</span>)size;</span><br><span class="line">        <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[byteSize];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">long</span> i = <span class="number">0</span>; i &lt; size; i += byteSize)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; byteSize; j++)</span><br><span class="line">                buf[j] = (<span class="keyword">byte</span>)(<span class="keyword">int</span>)(Math.random()*<span class="number">128</span>);</span><br><span class="line">            fos.write(buf);</span><br><span class="line">        &#125;</span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">generateBuffer</span><span class="params">(String filename, <span class="keyword">long</span> size, <span class="keyword">int</span> bufferSize)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(filename);</span><br><span class="line">        <span class="keyword">if</span>(!file.exists())</span><br><span class="line">            file.createNewFile();</span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(file);</span><br><span class="line">        BufferedOutputStream bos;</span><br><span class="line">        <span class="keyword">if</span>(bufferSize &lt; <span class="number">1</span>)</span><br><span class="line">            bos = <span class="keyword">new</span> BufferedOutputStream(fos);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            bos = <span class="keyword">new</span> BufferedOutputStream(fos, bufferSize);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">long</span> i = <span class="number">0</span>; i &lt; size; i++)&#123;</span><br><span class="line">            bos.write((<span class="keyword">int</span>)(Math.random()*<span class="number">128</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        bos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTimer</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> startTime = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> endTime = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> costTime = -<span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(startTime != -<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        startTime = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">stop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(startTime == -<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        endTime = System.currentTimeMillis();</span><br><span class="line">        costTime = endTime - startTime;</span><br><span class="line">        startTime = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getTime</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> costTime;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span> + costTime;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="比较三种IO方式写的耗时"><a href="#比较三种IO方式写的耗时" class="headerlink" title="比较三种IO方式写的耗时"></a>比较三种IO方式写的耗时</h4><p>测试三种方式生成10次不同大小的数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String... args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"Generating data..."</span>);</span><br><span class="line">    <span class="keyword">long</span>[] size = <span class="keyword">new</span> <span class="keyword">long</span>[]&#123;<span class="number">128</span>*<span class="number">1024</span>, <span class="number">256</span>*<span class="number">1024</span>, <span class="number">512</span>*<span class="number">1024</span>, <span class="number">1024</span>*<span class="number">1024</span>, <span class="number">2</span>*<span class="number">1024</span>*<span class="number">1024</span>, <span class="number">4</span>*<span class="number">1024</span>*<span class="number">1024</span>, <span class="number">8</span>*<span class="number">1024</span>*<span class="number">1024</span>&#125;;</span><br><span class="line">    String[] sizeName = <span class="keyword">new</span> String[]&#123;<span class="string">"128K"</span>, <span class="string">"256K"</span>, <span class="string">"512K"</span>, <span class="string">"1M"</span>, <span class="string">"2M"</span>, <span class="string">"4M"</span>, <span class="string">"8M"</span>&#125;;</span><br><span class="line">    String filename = <span class="string">"TestData"</span>;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">10</span>;</span><br><span class="line">    MyTimer timer = <span class="keyword">new</span> MyTimer();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size.length; i++)&#123;</span><br><span class="line">        timer.start();</span><br><span class="line">        System.out.println(<span class="string">"&gt;&gt; generateBytes"</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; count; j++)&#123;</span><br><span class="line">            generateBytes(filename, size[i], <span class="number">1024</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        timer.stop();</span><br><span class="line">        System.out.printf(<span class="string">"size: %s  costTime: %dms  avergeTime: %.2fms\n"</span>, sizeName[i], timer.getTime(), (<span class="keyword">double</span>)(timer.getTime() / (count*<span class="number">1.0</span>)));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        timer.start();</span><br><span class="line">        System.out.println(<span class="string">"&gt;&gt; generateBuffer"</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; count; j++)&#123;</span><br><span class="line">            generateBuffer(filename, size[i], <span class="number">1024</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        timer.stop();</span><br><span class="line">        System.out.printf(<span class="string">"size: %s  costTime: %dms  avergeTime: %.2fms\n"</span>, sizeName[i], timer.getTime(), (<span class="keyword">double</span>)(timer.getTime() / (count*<span class="number">1.0</span>)));</span><br><span class="line"></span><br><span class="line">        timer.start();</span><br><span class="line">        System.out.println(<span class="string">"&gt;&gt; generateByte"</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; count; j++)&#123;</span><br><span class="line">            generateByte(filename, size[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        timer.stop();</span><br><span class="line">        System.out.printf(<span class="string">"size: %s  costTime: %dms  avergeTime: %.2fms\n"</span>, sizeName[i], timer.getTime(), (<span class="keyword">double</span>)(timer.getTime() / (count*<span class="number">1.0</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"\nDone."</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">Generating data...</span><br><span class="line">&gt;&gt; generateBytes</span><br><span class="line">size: 128K  costTime: 53ms  avergeTime: 5.30ms</span><br><span class="line">&gt;&gt; generateBuffer</span><br><span class="line">size: 128K  costTime: 53ms  avergeTime: 5.30ms</span><br><span class="line">&gt;&gt; generateByte</span><br><span class="line">size: 128K  costTime: 2024ms  avergeTime: 202.40ms</span><br><span class="line">&gt;&gt; generateBytes</span><br><span class="line">size: 256K  costTime: 76ms  avergeTime: 7.60ms</span><br><span class="line">&gt;&gt; generateBuffer</span><br><span class="line">size: 256K  costTime: 78ms  avergeTime: 7.80ms</span><br><span class="line">&gt;&gt; generateByte</span><br><span class="line">size: 256K  costTime: 4026ms  avergeTime: 402.60ms</span><br><span class="line">&gt;&gt; generateBytes</span><br><span class="line">size: 512K  costTime: 159ms  avergeTime: 15.90ms</span><br><span class="line">&gt;&gt; generateBuffer</span><br><span class="line">size: 512K  costTime: 156ms  avergeTime: 15.60ms</span><br><span class="line">&gt;&gt; generateByte</span><br><span class="line">size: 512K  costTime: 8022ms  avergeTime: 802.20ms</span><br><span class="line">&gt;&gt; generateBytes</span><br><span class="line">size: 1M  costTime: 294ms  avergeTime: 29.40ms</span><br><span class="line">&gt;&gt; generateBuffer</span><br><span class="line">size: 1M  costTime: 298ms  avergeTime: 29.80ms</span><br><span class="line">&gt;&gt; generateByte</span><br><span class="line">size: 1M  costTime: 16606ms  avergeTime: 1660.60ms</span><br><span class="line">&gt;&gt; generateBytes</span><br><span class="line">size: 2M  costTime: 619ms  avergeTime: 61.90ms</span><br><span class="line">&gt;&gt; generateBuffer</span><br><span class="line">size: 2M  costTime: 667ms  avergeTime: 66.70ms</span><br><span class="line">&gt;&gt; generateByte</span><br><span class="line">size: 2M  costTime: 34323ms  avergeTime: 3432.30ms</span><br><span class="line">&gt;&gt; generateBytes</span><br><span class="line">size: 4M  costTime: 1269ms  avergeTime: 126.90ms</span><br><span class="line">&gt;&gt; generateBuffer</span><br><span class="line">size: 4M  costTime: 1272ms  avergeTime: 127.20ms</span><br><span class="line">&gt;&gt; generateByte</span><br><span class="line">size: 4M  costTime: 68344ms  avergeTime: 6834.40ms</span><br><span class="line">&gt;&gt; generateBytes</span><br><span class="line">size: 8M  costTime: 2491ms  avergeTime: 249.10ms</span><br><span class="line">&gt;&gt; generateBuffer</span><br><span class="line">size: 8M  costTime: 2622ms  avergeTime: 262.20ms</span><br><span class="line">&gt;&gt; generateByte</span><br><span class="line">size: 8M  costTime: 139931ms  avergeTime: 13993.10ms</span><br><span class="line"></span><br><span class="line">Done.</span><br></pre></td></tr></table></figure><p><strong>明显，单字节的读写明显慢于其他两种方式的读写，而块读写在这里的速度稍快于缓冲读写，下面会进行更加仔细的测试</strong></p><h4 id="块读写方式的块大小对速度的影响"><a href="#块读写方式的块大小对速度的影响" class="headerlink" title="块读写方式的块大小对速度的影响"></a>块读写方式的块大小对速度的影响</h4><p>对generateBytes方法的缓冲区块大小进行测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String... args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"Generating data..."</span>);</span><br><span class="line">    <span class="keyword">long</span> size = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">    String filename = <span class="string">"1M"</span>;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">10</span>;</span><br><span class="line">    MyTimer timer = <span class="keyword">new</span> MyTimer();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; <span class="number">4096</span>; i *= <span class="number">2</span>)&#123;</span><br><span class="line">        System.out.println(<span class="string">"byteSize: "</span> + i);</span><br><span class="line">        timer.start();</span><br><span class="line">        System.out.println(<span class="string">"&gt;&gt; generateBytes"</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; count; j++)&#123;</span><br><span class="line">            generateBytes(filename, size, i);</span><br><span class="line">        &#125;</span><br><span class="line">        timer.stop();</span><br><span class="line">        System.out.printf(<span class="string">"count: %d  costTime: %dms  avergeTime: %.2fms\n"</span>, count, timer.getTime(), timer.getTime() / (count*<span class="number">1.0</span>));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"\nDone."</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Generating data...</span><br><span class="line">byteSize: 128</span><br><span class="line">&gt;&gt; generateBytes</span><br><span class="line">count: 10  costTime: 456ms  avergeTime: 45.60ms</span><br><span class="line">byteSize: 256</span><br><span class="line">&gt;&gt; generateBytes</span><br><span class="line">count: 10  costTime: 337ms  avergeTime: 33.70ms</span><br><span class="line">byteSize: 512</span><br><span class="line">&gt;&gt; generateBytes</span><br><span class="line">count: 10  costTime: 307ms  avergeTime: 30.70ms</span><br><span class="line">byteSize: 1024</span><br><span class="line">&gt;&gt; generateBytes</span><br><span class="line">count: 10  costTime: 290ms  avergeTime: 29.00ms</span><br><span class="line">byteSize: 2048</span><br><span class="line">&gt;&gt; generateBytes</span><br><span class="line">count: 10  costTime: 304ms  avergeTime: 30.40ms</span><br><span class="line">byteSize: 4096</span><br><span class="line">&gt;&gt; generateBytes</span><br><span class="line">count: 10  costTime: 278ms  avergeTime: 27.80ms</span><br><span class="line">byteSize: 8192</span><br><span class="line">&gt;&gt; generateBytes</span><br><span class="line">count: 10  costTime: 287ms  avergeTime: 28.70ms</span><br><span class="line">byteSize: 16384</span><br><span class="line">&gt;&gt; generateBytes</span><br><span class="line">count: 10  costTime: 279ms  avergeTime: 27.90ms</span><br><span class="line">byteSize: 32768</span><br><span class="line">&gt;&gt; generateBytes</span><br><span class="line">count: 10  costTime: 286ms  avergeTime: 28.60ms</span><br><span class="line"></span><br><span class="line">Done.</span><br></pre></td></tr></table></figure><p><strong>根据上面的运行结果，可以看出块大小对读写速度是有影响的，不过也不是说块大小越大读写速度越快，到后面速度增长幅度很小</strong></p><h4 id="缓冲读写的缓冲区大小对读写速度的影响"><a href="#缓冲读写的缓冲区大小对读写速度的影响" class="headerlink" title="缓冲读写的缓冲区大小对读写速度的影响"></a>缓冲读写的缓冲区大小对读写速度的影响</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String... args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"Generating data..."</span>);</span><br><span class="line">    <span class="keyword">long</span> size = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">    String filename = <span class="string">"1M"</span>;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">10</span>;</span><br><span class="line">    MyTimer timer = <span class="keyword">new</span> MyTimer();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; <span class="number">4096</span> * <span class="number">16</span>; i *= <span class="number">2</span>)&#123;</span><br><span class="line">        System.out.println(<span class="string">"byteSize: "</span> + i);</span><br><span class="line">        timer.start();</span><br><span class="line">        System.out.println(<span class="string">"&gt;&gt; generateBuffer"</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; count; j++)&#123;</span><br><span class="line">            generateBuffer(filename, size, i);</span><br><span class="line">        &#125;</span><br><span class="line">        timer.stop();</span><br><span class="line">        System.out.printf(<span class="string">"count: %d  costTime: %dms  avergeTime: %.2fms\n"</span>, count, timer.getTime(), timer.getTime() / (count*<span class="number">1.0</span>));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"\nDone."</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">Generating data...</span><br><span class="line">byteSize: 2</span><br><span class="line">&gt;&gt; generateBuffer</span><br><span class="line">count: 10  costTime: 9106ms  avergeTime: 910.60ms</span><br><span class="line">byteSize: 4</span><br><span class="line">&gt;&gt; generateBuffer</span><br><span class="line">count: 10  costTime: 4740ms  avergeTime: 474.00ms</span><br><span class="line">byteSize: 8</span><br><span class="line">&gt;&gt; generateBuffer</span><br><span class="line">count: 10  costTime: 2581ms  avergeTime: 258.10ms</span><br><span class="line">byteSize: 16</span><br><span class="line">&gt;&gt; generateBuffer</span><br><span class="line">count: 10  costTime: 1408ms  avergeTime: 140.80ms</span><br><span class="line">byteSize: 32</span><br><span class="line">&gt;&gt; generateBuffer</span><br><span class="line">count: 10  costTime: 877ms  avergeTime: 87.70ms</span><br><span class="line">byteSize: 64</span><br><span class="line">&gt;&gt; generateBuffer</span><br><span class="line">count: 10  costTime: 599ms  avergeTime: 59.90ms</span><br><span class="line">byteSize: 128</span><br><span class="line">&gt;&gt; generateBuffer</span><br><span class="line">count: 10  costTime: 459ms  avergeTime: 45.90ms</span><br><span class="line">byteSize: 256</span><br><span class="line">&gt;&gt; generateBuffer</span><br><span class="line">count: 10  costTime: 397ms  avergeTime: 39.70ms</span><br><span class="line">byteSize: 512</span><br><span class="line">&gt;&gt; generateBuffer</span><br><span class="line">count: 10  costTime: 361ms  avergeTime: 36.10ms</span><br><span class="line">byteSize: 1024</span><br><span class="line">&gt;&gt; generateBuffer</span><br><span class="line">count: 10  costTime: 341ms  avergeTime: 34.10ms</span><br><span class="line">byteSize: 2048</span><br><span class="line">&gt;&gt; generateBuffer</span><br><span class="line">count: 10  costTime: 307ms  avergeTime: 30.70ms</span><br><span class="line">byteSize: 4096</span><br><span class="line">&gt;&gt; generateBuffer</span><br><span class="line">count: 10  costTime: 297ms  avergeTime: 29.70ms</span><br><span class="line">byteSize: 8192</span><br><span class="line">&gt;&gt; generateBuffer</span><br><span class="line">count: 10  costTime: 294ms  avergeTime: 29.40ms</span><br><span class="line">byteSize: 16384</span><br><span class="line">&gt;&gt; generateBuffer</span><br><span class="line">count: 10  costTime: 306ms  avergeTime: 30.60ms</span><br><span class="line">byteSize: 32768</span><br><span class="line">&gt;&gt; generateBuffer</span><br><span class="line">count: 10  costTime: 306ms  avergeTime: 30.60ms</span><br><span class="line"></span><br><span class="line">Done.</span><br></pre></td></tr></table></figure><p><strong>跟块读写一样，缓冲区大小对缓冲读写的速度有所影响，越到后面变化幅度越小</strong></p><h4 id="块读写块大小跟缓冲读写缓冲大小一致时，速度的差别"><a href="#块读写块大小跟缓冲读写缓冲大小一致时，速度的差别" class="headerlink" title="块读写块大小跟缓冲读写缓冲大小一致时，速度的差别"></a>块读写块大小跟缓冲读写缓冲大小一致时，速度的差别</h4><p>测试不同缓冲大小下，两者之间的速度</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; <span class="number">4096</span> * <span class="number">16</span>; i *= <span class="number">2</span>)&#123;</span><br><span class="line">        System.out.println(<span class="string">"byteSize: "</span> + i);</span><br><span class="line">        timer.start();</span><br><span class="line">        System.out.println(<span class="string">"&gt;&gt; generateBytes"</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; count; j++)&#123;</span><br><span class="line">            generateBytes(filename, size, i);</span><br><span class="line">        &#125;</span><br><span class="line">        timer.stop();</span><br><span class="line">        System.out.printf(<span class="string">"count: %d  costTime: %dms  avergeTime: %.2fms\n"</span>, count, timer.getTime(), timer.getTime() / (count*<span class="number">1.0</span>));</span><br><span class="line"></span><br><span class="line">        timer.start();</span><br><span class="line">        System.out.println(<span class="string">"&gt;&gt; generateBuffer"</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; count; j++)&#123;</span><br><span class="line">            generateBuffer(filename, size, i);</span><br><span class="line">        &#125;</span><br><span class="line">        timer.stop();</span><br><span class="line">        System.out.printf(<span class="string">"count: %d  costTime: %dms  avergeTime: %.2fms\n"</span>, count, timer.getTime(), timer.getTime() / (count*<span class="number">1.0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"\nDone."</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">Generating data...</span><br><span class="line">byteSize: 2</span><br><span class="line">&gt;&gt; generateBytes</span><br><span class="line">count: 10  costTime: 8532ms  avergeTime: 853.20ms</span><br><span class="line">&gt;&gt; generateBuffer</span><br><span class="line">count: 10  costTime: 8558ms  avergeTime: 855.80ms</span><br><span class="line">byteSize: 4</span><br><span class="line">&gt;&gt; generateBytes</span><br><span class="line">count: 10  costTime: 4405ms  avergeTime: 440.50ms</span><br><span class="line">&gt;&gt; generateBuffer</span><br><span class="line">count: 10  costTime: 4441ms  avergeTime: 444.10ms</span><br><span class="line">byteSize: 8</span><br><span class="line">&gt;&gt; generateBytes</span><br><span class="line">count: 10  costTime: 2395ms  avergeTime: 239.50ms</span><br><span class="line">&gt;&gt; generateBuffer</span><br><span class="line">count: 10  costTime: 2368ms  avergeTime: 236.80ms</span><br><span class="line">byteSize: 16</span><br><span class="line">&gt;&gt; generateBytes</span><br><span class="line">count: 10  costTime: 1326ms  avergeTime: 132.60ms</span><br><span class="line">&gt;&gt; generateBuffer</span><br><span class="line">count: 10  costTime: 1340ms  avergeTime: 134.00ms</span><br><span class="line">byteSize: 32</span><br><span class="line">&gt;&gt; generateBytes</span><br><span class="line">count: 10  costTime: 821ms  avergeTime: 82.10ms</span><br><span class="line">&gt;&gt; generateBuffer</span><br><span class="line">count: 10  costTime: 814ms  avergeTime: 81.40ms</span><br><span class="line">byteSize: 64</span><br><span class="line">&gt;&gt; generateBytes</span><br><span class="line">count: 10  costTime: 559ms  avergeTime: 55.90ms</span><br><span class="line">&gt;&gt; generateBuffer</span><br><span class="line">count: 10  costTime: 559ms  avergeTime: 55.90ms</span><br><span class="line">byteSize: 128</span><br><span class="line">&gt;&gt; generateBytes</span><br><span class="line">count: 10  costTime: 419ms  avergeTime: 41.90ms</span><br><span class="line">&gt;&gt; generateBuffer</span><br><span class="line">count: 10  costTime: 458ms  avergeTime: 45.80ms</span><br><span class="line">byteSize: 256</span><br><span class="line">&gt;&gt; generateBytes</span><br><span class="line">count: 10  costTime: 350ms  avergeTime: 35.00ms</span><br><span class="line">&gt;&gt; generateBuffer</span><br><span class="line">count: 10  costTime: 367ms  avergeTime: 36.70ms</span><br><span class="line">byteSize: 512</span><br><span class="line">&gt;&gt; generateBytes</span><br><span class="line">count: 10  costTime: 338ms  avergeTime: 33.80ms</span><br><span class="line">&gt;&gt; generateBuffer</span><br><span class="line">count: 10  costTime: 333ms  avergeTime: 33.30ms</span><br><span class="line">byteSize: 1024</span><br><span class="line">&gt;&gt; generateBytes</span><br><span class="line">count: 10  costTime: 312ms  avergeTime: 31.20ms</span><br><span class="line">&gt;&gt; generateBuffer</span><br><span class="line">count: 10  costTime: 309ms  avergeTime: 30.90ms</span><br><span class="line">byteSize: 2048</span><br><span class="line">&gt;&gt; generateBytes</span><br><span class="line">count: 10  costTime: 300ms  avergeTime: 30.00ms</span><br><span class="line">&gt;&gt; generateBuffer</span><br><span class="line">count: 10  costTime: 303ms  avergeTime: 30.30ms</span><br><span class="line">byteSize: 4096</span><br><span class="line">&gt;&gt; generateBytes</span><br><span class="line">count: 10  costTime: 292ms  avergeTime: 29.20ms</span><br><span class="line">&gt;&gt; generateBuffer</span><br><span class="line">count: 10  costTime: 317ms  avergeTime: 31.70ms</span><br><span class="line">byteSize: 8192</span><br><span class="line">&gt;&gt; generateBytes</span><br><span class="line">count: 10  costTime: 284ms  avergeTime: 28.40ms</span><br><span class="line">&gt;&gt; generateBuffer</span><br><span class="line">count: 10  costTime: 297ms  avergeTime: 29.70ms</span><br><span class="line">byteSize: 16384</span><br><span class="line">&gt;&gt; generateBytes</span><br><span class="line">count: 10  costTime: 297ms  avergeTime: 29.70ms</span><br><span class="line">&gt;&gt; generateBuffer</span><br><span class="line">count: 10  costTime: 310ms  avergeTime: 31.00ms</span><br><span class="line">byteSize: 32768</span><br><span class="line">&gt;&gt; generateBytes</span><br><span class="line">count: 10  costTime: 323ms  avergeTime: 32.30ms</span><br><span class="line">&gt;&gt; generateBuffer</span><br><span class="line">count: 10  costTime: 291ms  avergeTime: 29.10ms</span><br><span class="line"></span><br><span class="line">Done.</span><br></pre></td></tr></table></figure><p>生成4M数据，然后每次重复25次，从块大小128开始测试的结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">Generating data...</span><br><span class="line">byteSize: 128</span><br><span class="line">&gt;&gt; generateBytes</span><br><span class="line">count: 25  costTime: 3896ms  avergeTime: 155.84ms</span><br><span class="line">&gt;&gt; generateBuffer</span><br><span class="line">count: 25  costTime: 3932ms  avergeTime: 157.28ms</span><br><span class="line">byteSize: 256</span><br><span class="line">&gt;&gt; generateBytes</span><br><span class="line">count: 25  costTime: 3151ms  avergeTime: 126.04ms</span><br><span class="line">&gt;&gt; generateBuffer</span><br><span class="line">count: 25  costTime: 3194ms  avergeTime: 127.76ms</span><br><span class="line">byteSize: 512</span><br><span class="line">&gt;&gt; generateBytes</span><br><span class="line">count: 25  costTime: 2831ms  avergeTime: 113.24ms</span><br><span class="line">&gt;&gt; generateBuffer</span><br><span class="line">count: 25  costTime: 2854ms  avergeTime: 114.16ms</span><br><span class="line">byteSize: 1024</span><br><span class="line">&gt;&gt; generateBytes</span><br><span class="line">count: 25  costTime: 2665ms  avergeTime: 106.60ms</span><br><span class="line">&gt;&gt; generateBuffer</span><br><span class="line">count: 25  costTime: 2690ms  avergeTime: 107.60ms</span><br><span class="line">byteSize: 2048</span><br><span class="line">&gt;&gt; generateBytes</span><br><span class="line">count: 25  costTime: 2578ms  avergeTime: 103.12ms</span><br><span class="line">&gt;&gt; generateBuffer</span><br><span class="line">count: 25  costTime: 2643ms  avergeTime: 105.72ms</span><br><span class="line">byteSize: 4096</span><br><span class="line">&gt;&gt; generateBytes</span><br><span class="line">count: 25  costTime: 2516ms  avergeTime: 100.64ms</span><br><span class="line">&gt;&gt; generateBuffer</span><br><span class="line">count: 25  costTime: 2544ms  avergeTime: 101.76ms</span><br><span class="line">byteSize: 8192</span><br><span class="line">&gt;&gt; generateBytes</span><br><span class="line">count: 25  costTime: 2502ms  avergeTime: 100.08ms</span><br><span class="line">&gt;&gt; generateBuffer</span><br><span class="line">count: 25  costTime: 2539ms  avergeTime: 101.56ms</span><br><span class="line">byteSize: 16384</span><br><span class="line">&gt;&gt; generateBytes</span><br><span class="line">count: 25  costTime: 2607ms  avergeTime: 104.28ms</span><br><span class="line">&gt;&gt; generateBuffer</span><br><span class="line">count: 25  costTime: 2561ms  avergeTime: 102.44ms</span><br><span class="line">byteSize: 32768</span><br><span class="line">&gt;&gt; generateBytes</span><br><span class="line">count: 25  costTime: 2500ms  avergeTime: 100.00ms</span><br><span class="line">&gt;&gt; generateBuffer</span><br><span class="line">count: 25  costTime: 5704ms  avergeTime: 228.16ms</span><br><span class="line"></span><br><span class="line">Done.</span><br></pre></td></tr></table></figure><p><strong>这里的话，块读写的要比缓冲读写的快一点点，(如果这里读写更多的数据，重复更多次，差距会明显一些)</strong></p><h3 id="测试结论"><a href="#测试结论" class="headerlink" title="测试结论"></a>测试结论</h3><ol><li>同等情况下，单字节读写速度远远比不上块读写或者缓冲读写，大概50倍左右吧，原因是因为每读写一次，都需要从文件中去读写，大量读写操作时，开销太大。</li><li>块读写时，块大小会影响读写速度，越大速度越快，但是影响幅度会越来越小；缓冲读写也一样。块大小适当就好了，太大会导致内存问题，太小又会导致读写速度过慢。建议1024或者2048。缓冲读写的话，无特殊情况，使用默认的就可以了，无需自己手动指定。</li><li>块读写跟缓冲读写相比，块读写要快上一些，主要原因是因为缓冲读写其实也是在原有的基础上进行的装饰封装而已，在这过程中，就会多了很多不必要的操作，比如过多的“无必要的”栈调用。所以速度会比块读写要慢一些。</li></ol><h3 id="使用RandomAccessFile类进行读写"><a href="#使用RandomAccessFile类进行读写" class="headerlink" title="使用RandomAccessFile类进行读写"></a>使用RandomAccessFile类进行读写</h3><p>这种方式的读写会更加灵活，跟C/C++的文件读写很想象，可以使用seek()函数来移动当前在文件中的位置，更方便更灵活的读取数据。同时也提供一些其他的write和read方法，可以更加方便读写不同类型的数据。</p><p>读写的时候，也是分两种方式，一种直接单字节读写，一种是自己建立缓冲区，然后进行块读写。</p><h3 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h3><p>在jdk中的io，也就是java.io包中的东西，都是线程安全的，虽然这里的线程安全做得很不错，但是当如果我的程序单单只运行在一个线程下的，加上这些线程安全的保证就是没有必要的了，即使JVM会进行优化，但是还是会拖慢读写速度；其次，自己也完全可以通过自己的方式实现线程安全的。</p><blockquote><p>当你确定你的代码运行在单一线程环境下，或者你自己添加了同步保护时，建议使用com.liferay.portal.kernel.io.unsync包中的IO类。它们能大幅提高你的应用的IO性能。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java-IO性能分析&quot;&gt;&lt;a href=&quot;#Java-IO性能分析&quot; class=&quot;headerlink&quot; title=&quot;Java IO性能分析&quot;&gt;&lt;/a&gt;Java IO性能分析&lt;/h1&gt;&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;head
      
    
    </summary>
    
    
      <category term="java" scheme="http://dcLunatic.github.io/tags/java/"/>
    
      <category term="IO" scheme="http://dcLunatic.github.io/tags/IO/"/>
    
      <category term="性能分析" scheme="http://dcLunatic.github.io/tags/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
</feed>
